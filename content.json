{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Ajax","text":"AjaxAJAX即Asynchronous JavaScript and XML (异步的JavaScript和XML)，一种创建交互式网页应用的网页开发技术方案。之前我们在页面进行操作的时候往往会导致整个页面进行刷新，这样的体验往往不是很好，使用ajax发送请求的时候可以在后台处理请求和响应，例如在用户登录的时候提示用户当前输入的用户名是否正确，或者验证密码等等操作。 原生Ajax原生的ajax是基于XmlHttpRequest对象进行操作的，因此要使用原生ajax先来看看XmlHttpRequest对象的主要方法和属性： 方法：1234567891011121314151617181920212223242526272829303132333435363738 用于创建请求 参数： method： 请求方式（字符串类型），如：POST、GET、DELETE... url： 要请求的地址（字符串类型） async： 是否异步（布尔类型） b. void send(String body) 用于发送请求 参数： body： 要发送的数据（字符串类型） c. void setRequestHeader(String header,String value) 用于设置请求头 参数： header： 请求头的key（字符串类型） vlaue： 请求头的value（字符串类型） d. String getAllResponseHeaders() 获取所有响应头 返回值： 响应头数据（字符串类型） e. String getResponseHeader(String header) 获取响应头中指定header的值 参数： header： 响应头的key（字符串类型） 返回值： 响应头中指定的header对应的值 f. void abort() 终止请求&lt;/pre&gt; 属性：1234567891011121314151617181920212223 状态值（整数） 详细： 0-未初始化，尚未调用open()方法； 1-启动，调用了open()方法，未调用send()方法； 2-发送，已经调用了send()方法，未接收到响应； 3-接收，已经接收到部分响应数据； 4-完成，已经接收到全部响应数据； b. Function onreadystatechange 当readyState的值改变时自动触发执行其对应的函数（回调函数） c. String responseText 服务器返回的数据（字符串类型） d. XmlDocument responseXML 服务器返回的数据（Xml对象） e. Number states 状态码（整数），如：200、404... f. String statesText 状态文本（字符串），如：OK、NotFound... 有了上面的知识我们来实现一个最简单的原生ajax请求 ajax_test.html: 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;test&quot; onclick=&quot;ajax_test();&quot;&gt; &lt;script&gt; function ajax_test() { var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;,'/ajax_receive/',true); //设置请求头 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset-UTF-8'); xhr.send(&quot;name=root;password=123&quot;); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ajax_receive处理函数： 1234def ajax_receive(request): if request.method == &quot;POST&quot;: print(request.POST) return HttpResponse(&quot;l&quot;) 点击按钮后台运行结果： 12[04/May/2018 15:20:21] &quot;GET /ajax_receive/?t=1 HTTP/1.1&quot; 200 2&lt;QueryDict: {'name': ['root'], 'password': ['123']}&gt; 需要注意的是，使用原生ajax发送数据的时候必须要设置请求头，否则无法正常接收解析发送过来的数据 JQuery的ajaxjquery的ajax也是基于XmlHttpRequest或者ActiveXObject的 常用参数及作用:1234567891011121314151617181920212223url：请求地址type：请求方式，GET、POST（1.9.0之后用method）headers：请求头data：要发送的数据contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)async：是否异步timeout：设置请求超时时间（毫秒）beforeSend：发送请求前执行的函数(全局)complete：完成之后执行的回调函数(全局)success：成功之后执行的回调函数(全局)error：失败之后执行的回调函数(全局)accepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型dataType：将服务器端返回的数据转换成指定类型 &quot;xml&quot;: 将服务器端返回的内容转换成xml&amp;#26684;式 &quot;text&quot;: 将服务器端返回的内容转换成普通文本&amp;#26684;式 &quot;html&quot;: 将服务器端返回的内容转换成普通文本&amp;#26684;式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本&amp;#26684;式 &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象 &quot;jsonp&quot;: JSONP &amp;#26684;式 使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数converters： 转换器，将服务器端的内容根据指定的dataType转换类型，并传值给success回调函数 示例1234567891011121314151617181920212223242526&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type=&quot;button&quot; onclick=&quot;JqSendRequest();&quot; value='Ajax请求' /&gt; &lt;/p&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../static/js/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function JqSendRequest(){ $.ajax({ url: &quot;/ajax_receive/&quot;, type: 'GET', dataType: 'text', data:{&quot;name&quot;:&quot;root&quot;}, success: function(data){ alert(data) } }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接收函数1234567def ajax_receive(request): if request.method == &quot;POST&quot;: print(request.POST) return HttpResponse(&quot;POST&quot;) if request.method == 'GET': print(request.GET) return HttpResponse(&quot;GET&quot;) 使用Ajax提交Form表单实现注册功能实例：首先需要对form表单做一下调整： 1234567891011121314&lt;form id=&quot;register_form&quot; onsubmit=&quot;return false&quot;&gt; &lt;h6&gt;用户名&lt;/h6&gt; &lt;input type=&quot;text&quot; placeholder=&quot;用户名&quot; name=&quot;username&quot; required=&quot;&quot;&gt; &lt;h6&gt;邮箱&lt;/h6&gt; &lt;input type=&quot;text&quot; class=&quot;email&quot; placeholder=&quot;邮箱&quot; name=&quot;Email&quot;&gt; &lt;h6&gt;密码&lt;/h6&gt; &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; name=&quot;password&quot;&gt; &lt;h6&gt;确认密码&lt;/h6&gt; &lt;input type=&quot;password&quot; placeholder=&quot;确认密码&quot; name=&quot;password&quot;&gt; &lt;div class=&quot;login-bottom&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;注 册&quot; onclick=&quot;login()&quot;&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 为了防止点击submit按钮的时候发生跳转，需要在form中添加 onsubmit=”return false”参数，再去掉常用的action，method参数，最后再给submit按钮绑定点击事件，至此form表单完成接下来就是js部分： 123456789101112131415161718192021&lt;script src=&quot;../../static/js/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function login() { $.ajax({ //几个参数需要注意一下 type: &quot;POST&quot;,//方法类型 dataType: &quot;json&quot;,//预期服务器返回的数据类型 url: &quot;/iot/register&quot;,//url data: $('#register_form').serialize(), success: function (data) { if (data['error'] == &quot;OK&quot;){ alert(&quot;注册成功&quot;) } else { alert(data['error']); } } }); } &lt;/script&gt; data: 将form表单内容序列化一下，通过post方法发送请求，在回调函数里面显示提示信息。 view函数： 123456789101112def register(request): res = {'error':None} if request.method == &quot;POST&quot;: name = request.POST.get(&quot;username&quot;) email= request.POST.get(&quot;Email&quot;) password =request.POST.getlist(&quot;password&quot;) print(password) if password[0] != password[1]: res['error'] = &quot;两次密码不同，请重新填写&quot; else: res['error'] = 'OK' return HttpResponse(json.dumps(res),content_type=&quot;application/json&quot;) 通过getlist方法获取列表多个值，判断两个密码是否相同，并把结果一json格式发送给前端。","link":"/2018/05/04/Ajax/"},{"title":"Arduino小游戏集合（俄罗斯方块）","text":"一：前期准备用到的硬件材料Arduino Mega2560 &amp;#43; LCD4884 Joystick Shiled屏幕分辨率为48*84 软件平台&amp;nbsp;Arduino IDE， 需要用到的库 U8glib, MsTime2 二：设计思路1：游戏整体界面标准的俄罗斯方块为行宽为10，列高为20，结合屏幕大小每个最小单位点设为2*2像素，共计七种方块，19种形状，使用[10][20]的二维数组存放方块位置信息，需要显示则将相应位置的数组值改为1，空白则为0。并在左侧显示下一个方块形状，右侧显示当前分数和等级 游戏界面如图所示 2：方块的产生、变换和移动我没有采用使用整体存放方块图形信息的方法，因为不知道怎么使用U8glib库旋转单个图形，采用的是一种比较笨的方法。每一种方块选取一个中心点，围绕这个中心点来绘制方块，移动的时候也是直接移动中心点然后重新在中心点绘制方块，总共有16种方块图形这里选取其中一种来做例子说明 方块的产生例如Z形方块 选取B为中心点，只需要获取B的坐标信息，设为(x,y)那么其他几个方块的坐标也能相应求出来，然后将二维数组中的这几个对应值设为1，循环绘制的时候就能显示出方块图形了 方块的变换和移动我们想要控制方块旋转的时候就需要重新获取方块生成的方式 在方块移动和变换的时候在这之前都需要先在二维数组中清空原有的方块信息，然后重新按照新的生成方式写入数组里面 方块检测每一次在移动和和变换的过程中还需要判断是否能够移动和变换，需要检测方块周围是否有足够的空间检测方法如下由于方块无法向上移动，所以上部不需要判断，我们只知道B的坐标，1-7号坐标可以根据B的坐标推断出来当我们需要右移动的时候就需要判断 2、4、6号位置是否已有方块阻挡或者到达边界，同理下移则需判断5、7号位置 三：详细设计1：按键检测LCD4884 Joystick Shiled带有一个摇杆按键，并且和A0脚连接，所以读取A0引脚值即可。 1234567891011121314void Control(){ switchVoltage = analogRead(0); if ( switchVoltage &amp;gt; 600 &amp;amp;&amp;amp; switchVoltage &amp;lt; 800 ) //上 dir = 1 ; else if ( switchVoltage &amp;gt; 180 &amp;amp;&amp;amp; switchVoltage &amp;lt; 400 ) //下 dir = 3; else if ( switchVoltage == 0 ) //左 dir = 4; else if ( switchVoltage &amp;gt; 400 &amp;amp;&amp;amp; switchVoltage &amp;lt; 600 ) //右 dir = 2; else if ( switchVoltage &amp;gt; 0 &amp;amp;&amp;amp; switchVoltage &amp;lt; 180 ) //确认 dir = 5;} 为了防止按键粘连，使用了MsTime2库定时扫描 12MsTimer2::set(100, Control); /*定时器中断按键的扫描*/MsTimer2::start(); 2：初始化在游戏运行之前，初始化屏幕亮度、游戏等级、随机数种子(防止每一次方块出现次数都相同、清空数组值以及方块中心点位置 1234567891011randomSeed(analogRead(1)); /*随机产生随机数序列以免方块的顺序为固定的*/block_num = random(1, 20); /*生成第一个方块信息block_num_next = random(1, 20) ; &lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;/*生成第二个方块x = 5 , y = 2;block_state_right = 0 ;block_state_left = 0;block_state_down = 0;level_now = 300;light_value = 50; &lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt; /*设置背光亮度*/pinMode(LCD_BACKLIGHT_PIN , OUTPUT);analogWrite(LCD_BACKLIGHT_PIN, light_value); 3：绘制游戏界面背景显示当前等级和分数，以及下一个方块形状，游戏的等级设置的是每次自动向下移动时延时的毫秒数，move_speed越小等级越高，方块向下移动也越来越快 123456789101112131415161718192021222324252627282930void interface(){ u8g.setFont(u8g_font_timR08); u8g.drawStr(57, 10, &amp;quot;Score&amp;quot;); u8g.drawStr(57, 30, &amp;quot;Grade&amp;quot;); u8g.drawStr(0, 10, &amp;quot;Next&amp;quot;); u8g.setPrintPos(70, 20); /*显示分数*/ u8g.print(score); /*显示等级*/ if ( move_speed &amp;lt;= 300) u8g.drawBox(60, 42, 3, 6); if ( move_speed &amp;lt;= 250) u8g.drawBox(65, 39, 3, 9); if ( move_speed &amp;lt;= 200) u8g.drawBox(70, 36, 3, 12); if ( move_speed &amp;lt;= 150) u8g.drawBox(75, 33, 3, 15); if (move_speed &amp;lt;= 100) u8g.drawBox(80, 30, 3, 18); /*显示下一个方块*/ create_box_next(1); for (int m = 0 ; m &amp;lt; 5 ; m&amp;#43;&amp;#43;) for (int n = 0 ; n &amp;lt; 5 ; n&amp;#43;&amp;#43;) { if ( block_next[m][n] == 1) u8g.drawBox(3 * m &amp;#43; 5, 3 * n &amp;#43; 15, 3, 3); } create_box_next(0);} 4：方块的生成形状太多，代码复用率太高只截取部分，每次移动或者变换的时候都需要调用这个函数来清除上一个方块的位置信息 123456789101112void create_box(int a ) /*调整block数组中的&amp;#20540;，参数为0的时候清除，参数为1时写入*/{ switch (block_num) { case 1: block[x][y &amp;#43; 1] = a; block[x][y - 1] = a; block[x - 1][y] = a; block[x][y] = a; break ; }｝ 5：方块的移动和变换每次移动和变换之前都得判断方块能否移动，能够移动还需要在移动之前清空原有的，不能移动的时候需要产生新的方块，这时候方块的中心点需要重置，并且当前形状的标号改为block_num_next的值，再重新随机生成一个数给block_num_next 123456789101112131415161718192021void block_go() /*方块的移动和变形*/{ block_fixed(); if (block_state_down == 1 ) /*方块不能下降的时候生成新的方块*/ { for (int m = 0; m &amp;lt; 10; m&amp;#43;&amp;#43;) { if (block[m][3] == 1) /*判断游戏是否结束*/ { game_over(); break; } } x = 5 , y = 2; /*设置初始中心点位置*/ block_num = block_num_next ; block_num_next = random(1, 20) ; block_state_right = 0 ; block_state_left = 0; block_state_down = 0; create_box(0); }} 变换方块形状，需要注意的是方块标号是连续的，每次变换的时候实际只是更改了当前方块的标号，为了防止从一个类型调到另一个类型需要做一些判断来限制标号更改的范围 1234567891011switch (dir) { case 1: /*变换方块形状*/ create_box(0); if ( block_num &amp;gt;= 1 &amp;amp;&amp;amp; block_num &amp;lt;= 4) /*防止变换的时候方块形状发生变换*/ { block_num&amp;#43;&amp;#43;; if (block_num &amp;gt; 4) block_num = 1; } } 6：判断方块能否移动每一种方块的判断方法都不同，需要根据当前方块标号做出不同的判断，判断结束会返回三个状态，block_state_left、block_state_down、block_state_right，这三个值为0的时候是可以向这个方向移动的 1234567891011121314151617181920void block_fixed() /*判断方块是否能够移动*/{ switch (block_num) { case 1: if (block[x - 2][y] == 1 || block[x - 1][y - 1] == 1 || block[x - 1][y &amp;#43; 1] == 1 || x &amp;lt;= 1) block_state_left = 1; else block_state_left = 0; if (block[x &amp;#43; 1][y] == 1 || block[x &amp;#43; 1][y - 1] == 1 || block[x &amp;#43; 1][y &amp;#43; 1] == 1 || x &amp;gt;= 9) block_state_right = 1; else block_state_right = 0; if (block[x - 1][y &amp;#43; 1] == 1 || block[x][y &amp;#43; 2] == 1 || y &amp;gt;= 18) block_state_down = 1; else block_state_down = 0; break; }} 7：绘制方块遍历二维数组，当值为1的时候则显示最小像素点 12345678910void draw_block() /*绘制方块*/{ int block_x , block_y; for (block_x = 0 ; block_x &amp;lt; 10 ; block_x &amp;#43;&amp;#43;) for (block_y = 0 ; block_y &amp;lt; 20 ; block_y &amp;#43;&amp;#43;) { if (block[block_x][block_y] == 1) u8g.drawBox(2 * block_x &amp;#43; 28 , 2 * block_y &amp;#43; 4 , 2 , 2); }} 8：计算得分遍历整个二维数组，判断有多少行全为1，然后再将数组中每一行都往下挪多少行 123456789101112131415161718192021222324void remove_block(){ int sum = 0, m, n, i = 0 , h; /*i：需要消除的行数，h:记录是哪一行需要消除*/ /*判断有多少行需要消除*/ for ( m = 19 ; m &amp;gt; 4; m--) { for ( n = 0 ; n &amp;lt; 10 ; n&amp;#43;&amp;#43;) sum &amp;#43;= block[n][m]; if (sum == 10) { i&amp;#43;&amp;#43;; score &amp;#43;= 10; h = m; block_state_down = 1 ; } else sum = 0; } /*当存在消行的情况下数组每一行都向下移动i个单位*/ for (i; i &amp;gt; 0; i--) for ( m = h; m &amp;gt;= 3; m--) for ( n = 0; n &amp;lt; 10; n&amp;#43;&amp;#43;) block[n][m] = block[n][m - 1];} 四：结语这个游戏是在一年前完成的，到今天很多细节忘得差不多了，只能凭借印象来大致的说明一下主要的流程和思路，代码中有很大一部分重用导致看起来很臃肿现在也懒得改了，有想折腾的可以尝试完善完善，另外其他的屏幕也是能适用的，只需要更改按键控制那个函数和u8glib那个头文件即可，但是分辨率就没办法了 源码连接，喜欢的还请赏个Star https://github.com/FanMLei/Arduino_Games 试玩视频: http://v.youku.com/v_show/id_XMzM5NjA0NjY2OA==.html?spm=a2h3j.8428770.3416059.1","link":"/2017/12/08/Arduino%E5%B0%8F%E6%B8%B8%E6%88%8F%E9%9B%86%E5%90%88%EF%BC%88%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%EF%BC%89/"},{"title":"Arduino语音天气预报（一）","text":"首先说一下项目预期的目标，通过板载的WiFi模块联网获取天气信息，使用屏幕将信息显示出来，配合板载的语音模块播放当天天气状况。 总体的设计思路：天气获取的网站是心知天气网免费的API（需要注册），400次/小时的请求足够日常使用了，当然也可以使用付费接口那样能获取更多的信息。当开发板通过API接口发送请求时网站会返回json&amp;#26684;式的信息，然后再通过json库将有用的信息解析出来，就能得到当天的天气信息了。然后将获取到的数据发送给屏幕进行处理，根据数据控制语音模块播放相应的语音文件。 下面简单的介绍一下心知天气的API 这个链接是获取实时天气状况 https://api.seniverse.com/v3/weather/now.json?key=APIPASSWORD&amp;location=地址&amp;language=返回的数据语言格式&amp;unit=温度单位 当发送正确的请求后将会收到服务器返回的json数据 1{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;北京,北京,中国&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;+08:00&quot;},&quot;now&quot;: {&quot;text&quot;:&quot;多云&quot;,&quot;code&quot;:&quot;4&quot;,&quot;temperature&quot;:&quot;25&quot;} ,&quot;last_update&quot;:&quot;2017-04-14T12:20:00+08:00&quot;}]} 拿到这些数据我们就可以解析出天气信息，本次需要用到的就这些了。更加详细的介绍请看 心知天气-天气数据API 这次我们用到的库有：ArduinoJson、ArduinoHttpClient、WiFi 首先我们需要在setup中连接上WiFi 1234Serial.begin(9600);Serial.print(&quot;connect....&quot;);while (WiFi.begin(ssid, pass) != WL_CONNECTED)Serial.println(&quot;connected&quot;); WiFi连接后发送API请求，并解析数据 123456789101112131415161718192021222324252627282930313233343536373839int httpCode = 0; String httpData; //发送http请求 httpCode = http.get(&quot;/v3/weather/now.json?key=&quot; + APIPASSWORD + &quot;&amp;location=zhengzhou&amp;language=en&amp;unit=c&quot;); //若是有返回就接收数据 if ( httpCode == 0) { Serial.println(&quot;startedRequest ok&quot;); httpCode = http.responseStatusCode(); if (httpCode &gt;= 0) { int bodyLen = http.contentLength(); //将接收到的字符存入string中，直到数据接收完毕 while ( (http.connected() || http.available()) &amp;&amp; (!http.endOfBodyReached())) { if (http.available()) { char c = http.read(); httpData += c; } else delay(1000); } //提取出关于天气的那一段字符串 data = httpData.substring((httpData.indexOf(&quot;\\&quot;now\\&quot;:&quot;) + 6), httpData.indexOf(&quot;,\\&quot;last&quot;)); //通过json库解析出相应的数据 DynamicJsonBuffer jsonBuffer; JsonObject&amp; root = jsonBuffer.parseObject(data); temperature = root[String(&quot;temperature&quot;)]; code = root[String(&quot;code&quot;)]; } } else Serial.print(&quot;Connect failed&quot;); http.stop(); //串口打印出温度 Serial.print(&quot;temperature is :&quot;): Serial.println(temperature); Serial.print(&quot;end&quot;); 关于json库的使用我了解的不是很多，就不做详细的说明。我在做的时候发现若是将整个返回的数据进行解析并得不到正确的信息，我猜测是因为返回的数据包含有其他的信息并不是json库所能解析的格式，因此我将接收到的字符存入到一个String类型的字符串中，然后截取其中一段（也就是上面黑色加粗的那一段）进行解析。需要注意的是json解析String类型的方式和char类型是不同的，具体还请参考ArduinoJson的示例。 最后的结果","link":"/2017/12/14/Arduino%E8%AF%AD%E9%9F%B3%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Arduino语音天气预报（三）","text":"这篇我们会讲如何使用板载的语音模块播放 这次用到的是串口语音模块，首先我们需要使用语音合成工具合成我们想要的语音存入内存卡中，然后呢当我们获取数据后发送相应的指令控制语音模块来播放对于的音频文件。 在这里不再说明如何合成音频文件了，直接切入正题。 这次我们主要用到的只有一条命令 –&gt; 播放指定目录下的文件 0x7E, 0x04, 0x44, 文件夹号, 文件号, 0xEF 因此音频文件存放位置和命名需要有一定的格式：例如 01号文件夹中存放诸如描述天气情况的语音，02号文件夹存放温度语音等等。命名也是有技巧的，例如我们可以根据天气代码来描述天气的语音，例如“今天天气晴”可命名为001，正好我们获取到的天气代码也是1这样我们就不用来处理这部分对于关系了。 还需要一点是在播放语音的过程中需要判断当前是否没有播放，这个可以通过模块上的一个引脚电平来判断，具体需要根据你自己的模块来设定，我的这个是当没有播放时电平为低，这样我们可以将引脚接入到Arduino的引脚上，通过读取引脚电压来判断。 这部分代码就不拿出来单独说明了，因为太简单了，而且会和硬件有较大的关系难免有人在使用的时候出现问题。 其实呢整个项目到这里已经完成了，但是我还想说一下有人可能直接烧代码会出现很多问题，那是因为我是用的并不是标准的Arduino开发板而是Fireduino使用Arduino平台开发而已，这块板子价值有点高只是做这个有点浪费而且我的也给弄坏了，理解了整个制作流程其实可以用更廉价的开发板来代替，例如NodeMCU、Arduino esp8266，而且所有的功能都能实现。 完整的项目演示 参考代码","link":"/2017/12/14/Arduino%E8%AF%AD%E9%9F%B3%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"Arduino语音天气预报（二）","text":"咱们接着上一篇来讲 作为天气预报的装置，若是只能在串口显示信息，那就没什么卵用了，还不如拿个手机看看省事，因此这篇将会讲一下如何使用外接屏幕显示信息。所用到的屏幕为串口彩屏，相较于普通的彩屏来说，串口屏的操作更为方便，也能更简单的制作画面较为复杂的界面，而且对于mcu没有任何要求只要能进行串口通信即可，因为串口屏内部本身是有主控的，串口屏可以根据指令自己绘图、操作控件。我们可以在页面上添加各种功能的控件，然后通过各种控件来显示信息达到我们想要的效果，如下图一样 举一个简单的例子：如果我们t5显示“1234”我们只需让mcu串口发送“t5.txt=”1234””就可以了 当我们将所有的信息都发送后就能得到下面这样的效果图 看到这里我们应该能够知道上一篇从心知天气获取到的信息远远没有这么多，这一次我们还需要从另外的地址获取更多的信息。 1https://api.seniverse.com/v3/weather/daily.json?key=APIPASSWORD&amp;location=地址&amp;language=返回的数据语言格式&amp;unit=温度单位&amp;start=起始时间（0：当天、1明天···）&amp;days=获取多少天的信息（从起始时间开始，免费的最多只有三天） 还是和上一篇一样黑色加粗的部分是需要根据自己情况进行修改的。这里由于Arduino处理中文很麻烦，因此语言我们最好选择英文，然后再同过其它代码转换成中文或其它。还需要提醒一下最好一天一天的获取信息，如start=0&amp;days=1，因为Arduinojson貌似是处理不了一个字符串包含多个json的数据格式。当连接成功后我们将会得到这样的数据： 1{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;Beijing&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;Beijing,Beijing,China&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;+08:00&quot;},&quot;daily&quot;:[{&quot;date&quot;:&quot;20170417&quot;,&quot;text_day&quot;:&quot;Cloudy&quot;,&quot;code_day&quot;:&quot;4&quot;,&quot;text_night&quot;:&quot;Cloudy&quot;,&quot;code_night&quot;:&quot;4&quot;,&quot;high&quot;:&quot;27&quot;,&quot;low&quot;:&quot;13&quot;,&quot;precip&quot;:&quot;&quot;,&quot;wind_direction&quot;:&quot;SW&quot;,&quot;wind_direction_degree&quot;:&quot;225&quot;,&quot;wind_speed&quot;:&quot;15&quot;,&quot;wind_scale&quot;:&quot;3&quot;}],&quot;last_update&quot;:&quot;2017-04-17T18:00:00+08:00&quot;}]} 这些信息里面包括白天天气、夜晚天气、最高气温、最低气温、风向、风速和风力等级，按照我们上一篇将的操作即可。这里我们只是获取了当天的全天天气，我们还要重复这样的操作获取第二天和第三的信息，好了到这里我们所有信息的获取就完成了，接下来就是如何将获取的信息传给屏幕并转化成中文。 12345678910data_day1 = httpData_day1.substring((httpData_day1.indexOf(&quot;\\&quot;daily\\&quot;&quot;) + 9), httpData.indexOf(&quot;],\\&quot;last&quot;));DynamicJsonBuffer jsonBuffer;JsonObject&amp; root = jsonBuffer.parseObject(data_day1);date1 = root[(&quot;date&quot;)].as&lt;String&gt;();temperature_low_day1 = root[String(&quot;low&quot;)];temperature_high_day1 = root[String(&quot;high&quot;)];code_day1 = root[String(&quot;code_day&quot;)];code_night1 = root[String(&quot;code_night&quot;)];wind_direction_day1 = root[(&quot;wind_direction&quot;)].as&lt;String&gt;();wind_scale_day1 = root[String(&quot;wind_scale&quot;)]; 数据的发送：我们所用到的指令大概有切图、控件的赋值这三种指令，切图指令是让屏幕显示当前天气的图片信息，天气图片可以在心知天气上下载，由于目前串口屏的上位机并不支持矢量图，因此我们需要将天气图片和背景图P在一起然后按照顺序导入这些图片。切图指令为picq x,y,w,h,pic_id pic_id为我们导入的图片序号，由于是显示天气实况pic_id的值应该是上一篇我们解析出来的天气代码“code” 天气图片的显示就完成了，下面就是发送其他的信息了。我们用到的大部分是文本控件使用到的指令为控件ID.txt=” “和控件ID.txt=控件ID.txt+” “前一种会将以前的字符给覆盖掉，后一种则是在原有的基础上增加。由于Arduino解析中文、发送中文字符比较麻烦，所以我选择是发送数字和字符，然后通过让串口屏进行处理并组合成中文，举个例子 123456//假设白天为晴天，对应的天气代码为0，夜晚为多云，对应天气代码为4，那么整天的天气情况用中文表示应该是晴转多云if(code_day1==0){ if(code_night1==4) g0.txt=&quot;晴转多云&quot;;} 总共大概有30中天气情况，这样就会有几百种组合了，看似麻烦其实只需要写一遍然后Ctrl+c 、Ctrl+v再稍微调整一下就行了，风向风力同样是这样处理的。（如果嫌麻烦，直接下载链接的tft文件直接烧进屏幕即可），关于屏幕显示的东西就这么多了，其他的以后再补充吧！！！ 演示视频（增加了loading动画）","link":"/2017/12/14/Arduino%E8%AF%AD%E9%9F%B3%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Django rest framework  认证组件源码分析","text":"Django rest framework的认证组件是最常用的几个组件之一，内部实现并不复杂，通过源码可以了解Django是如何处理请求的，在认证的过程中组件帮我们实现了哪些功能，以及如何实现我们自己的认证方法。 基础知识想要弄清楚rest framework的执行过程首先需要明白Django中CBV和FBV执行流程，http请求最最本质的就是一个socket，一个请求过来第一步就是做路由匹配，在FBV中因为视图本身就是一个函数，所以直接调用函数就可以了，但是CBV中视图是一个类而在这个类里面是我们编写的视图函数，所以比FBV多了一步如何找到那个函数并且执行它。 CBV中是基于反射实现请求方式不同执行不同的方法，我们在使用CBV来实现的时候，通常都是在路由中使用as_view方法。 1url(r'^dashboard$', views.Dashboard.as_view()) 这个方法存在于我们继承的父类View中，在as_view内部又会调用dispatch方法通过反射去找到对应的函数 所以总得来说，在CBV中一个请求过来的具体流程：url → view → as_view → dispatch 源码分析有了上面的基础接下来就比较容易理解了 首先在使用rest framework框架的时候 CBV不在是继承django的View了而是 rest framework的APIView，只是这个APIView也是继承django的View的，只不过是在原有的View中增加了很多功能而已，依然还是通过反射来实现的，所以跳过前面的内容直接到dispatch这部分 正式进入正题，restframework主要包含认证、解析器、分页和序列化四个大的部分，就对应上图框框内的几个部分，这几个部分流程大致相同，所以就以认证为例来具体说说他的流程 咱们接着上图继续往下一步一步走，首先会获取所有认证类的实例化对象。 如果自己写的类里面没有认证类，就会到基类中继续寻找，默认使用rest framework的配置文件中的认证类 1authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 拿到了认证所需要的类的对象，就继续返回到dispatch中，这时候request已经是增加内容了的request 返回dispatch之后回调用initial方法，在这个方法里面会执行所有之前我们添加的认证类、解析类 initial方法里面跳转比较频繁，这里截图就重叠到一起方便看，经过一路的跳转最终是执行了request对象的_authenticate方法 在_authenticate方法里面，会依次执行所有认证类的authenticate方法（由此我们也能知道如果我们想编写自己的认证类，那么认证部分需要放在authenticate方法里面），同时会将返回值赋值给request的user和auth属性 所以rest framework的认证流程总得来说就是","link":"/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"Django 实现Websocket","text":"django实现websocket大致上有两种方式，一种channels，一种是dwebsocket。channels依赖于redis，twisted等，相比之下使用dwebsocket要更为方便一些。 安装1pip install dwebsocket 配置123456789101112131415# setting.pyINSTALLED_APPS = [ ..... ..... 'dwebsocket',]MIDDLEWARE_CLASSES = [ ...... ...... 'dwebsocket.middleware.WebSocketMiddleware' # 为所有的URL提供websocket，如果只是单独的视图需要可以不选]WEBSOCKET_ACCEPT_ALL=True # 可以允许每一个单独的视图实用websockets&lt;/code&gt;&lt;/pre&gt; 简单使用模拟文件下载的简单示例 123456789101112131415161718from dwebsocket.decorators import accept_websocket@accept_websocketdef test(request): if not request.is_websocket(): # 判断是不是websocket连接 return render(request, 'websocket.html') else: download = Haproxy() t = threading.Thread(target=download.run) t.start() sent = [] while download.status: if len(download.res_dict) &amp;gt; len(sent): for i in download.res_dict.keys(): if i not in sent: sent.append(i) request.websocket.send(str(sent[-1]+str(download.res_dict[sent[-1]])).encode('utf-8')) # 发送消息到客户端 if not download.status: request.websocket.send('下载完成'.encode('utf-8')) 效果图 其他dwebsocket有两种装饰器：require_websocket和accept_websocekt，使用require_websocket装饰器会导致视图函数无法接收导致正常的http请求，一般情况使用accept_websocket方式就可以了。 dwebsocket的一些内置方法： request.is_websocket（）：判断请求是否是websocket方式，是返回true，否则返回false request.websocket： 当请求为websocket的时候，会在request中增加一个websocket属性。 WebSocket.wait（） 返回客户端发送的一条消息，没有收到消息则会导致阻塞。 WebSocket.read（） 和wait一样可以接受返回的消息，只是这种是非阻塞的，没有消息返回None。 WebSocket.count_messages（）返回消息的数量。 WebSocket.has_messages（）返回是否有新的消息过来。 WebSocket.send（message）像客户端发送消息，message为byte类型。","link":"/2018/09/21/Django%20%E5%AE%9E%E7%8E%B0Websocket/"},{"title":"Django+Vue前后端分离项目的部署","text":"前后端分离项目的部署主要使用Nginx和uwsgi来实现，把Nginx换成Apache也是可以的，看个人喜好。Nginx主要处理静态文件，uwsgi用来部署Django项目，处理其他请求。 uwsgi安装uwsgi1pip3 install uwsgi 测试uwsgi首先创建一个test.py文件 123def application(env, start_response): start_response('200 OK', [('Content-Type','text/html')])return [b&quot;Hello World&quot;] 在文件目录下使用命令 1uwsgi --http :80 --wsgi-file test.py 访问我们的网站，能够得到Hello World，则uwsgi安装成功 部署django项目为了以后使用方便，可先创建一个目录存放uwsgi配置文件 123mkdir website_uwsgicd website_uwsgivim uwsgi.ini 配置文件内容如下 1234567891011121314151617[uwsgi]chdir = /home/iot/IOTPlatform #项目根目录module = IOTPlatform.wsgi:application # wsgihttp = :8000master = TrueProcesses = 4 #最大进程数harakiri = 60 # max-requests = 5000# socket = 127.0.0.1:8000uid = 1000gid = 2000pidfile = /home/iot/website_uwsgi/master.piddaemonize = /home/iot/website_uwsgi/mysite.logvacuum = True 部分选项的含义：chdir : 项目根目录路径module： 入口文件http：监听的IP和端口，socket也是，如果使用Nginx做反向代理就应该选择socket方式，因为nginx反向代理使用的是socket方式，在这个项目中没有使用方向代理所以选用了http的方式master：是否启动主进程processes: 设置进程数目harakiri: 请求超时时间max-requests:每个工作进程设置请求数的上限pidfile:指定pid文件daemonize: 日志文件 uwsgi配置文件写好了，使用命令启动： uwsgi --ini uwsgi.ini 启动完成之后，使用ps -aux | grep uwsgi 查看是否有4个进程来判断uwsgi是否启动成功，另外可以使用接口工具访问接口看是否有正常的数据 其他的一些命令 uwsgi –reload master.pid 重启服务 uwsgi –stop master.pid 停止服务 部署静态文件静态文件有两种方式 通过django路由访问 通过nginx直接访问 方式1需要在根目录的URL文件中增加 url(r’^$’, TemplateView.as_view(template_name=”index.html”)),作为入口，在setting中更改静态资源位置 123# settings.pySTATIC_URL = '/static/'STATICFILES_DIRS = (os.path.join(BASE_DIR, &quot;dist/static&quot;)) # 静态文件目录位置 方式2安装nginx: apt-get install nginx配置nginx: cd /etc/nginx首先在 nginx的可用配置目录下新建我们的配置文件 1234567891011121314151617181920cd sites-available/vim mysite.confserver { listen 80; server_name iotplatform; charset utf-8; client_max_body_size 75M; location /static { alias /home/iot/IOTPlatform/dist/static; } location /media { alias /home/iot/media; } location / { root /home/iot/IOTPlatform/dist; index index.html; try_files $uri $uri/ /index.html; }} 再使用命令测试我们的配置文件是否有问题 12ln -s /etc/nginx/sites-available/mysite.conf /etc/nginx/sites-enabled/mysite.confnginx -t 没有问题使用 service nginx restart 重启nginx服务，这样就能访问到静态文件了 关于反向代理的问题反向代理的配置文件： 12345678910111213141516server { listen 80; server_name iotplatform; charset utf-8; client_max_body_size 75M; location /static { alias /home/iot/IOTPlatform/dist/static } location /media { alias /home/iot/media } location / { uwsgi_pass 127.0.0.1:8000; include /etc/nginx/uwsgi_params; }} 使用nginx -t测试的时候出现nginx: [emerg] open() “/etc/nginx/conf/uwsgi_params” failed (2: No such file or directory) in /etc/nginx/nginx.conf:81nginx: configuration file /etc/nginx/nginx.conf test failed 提示说没有找到uwsgi_params文件我的解决方法是：手动新建一个conf目录并将uwsgi_params文件复制过去","link":"/2019/12/17/Django+Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"title":"Django中间件执行流程和CSRF验证","text":"中间件执行流程django的中间件是一个轻量级的插件，可以改变django的输入和输出，中间件共有5种方法，分别为 process_request(self,request) process_view(self, request, callback, callback_args, callback_kwargs) process_template_response(self,request,response) process_exception(self, request, exception) process_response(self, request, response) 前两个方法 都是自上而下的执行每个中间件，后面的三个都是反着来的 CSRF验证django的CSRF是基于中间件来实现的，而且是放在中间件中的view方法中，原因是：django的中间件是作用于全局的，但是某些情况某个函数可能不需要用到CSRF验证，所以在执行路由匹配的时候找到视图函数，看看他是否需要用到CSRF认证，如果不需要则会跳过CSRF。 免除认证的方法： 12345678910111213141516171819202122# FBVfrom django.views.decorators.csrf import csrf_exempt@csrf_exemptdef test(request): pass# 在CBV的方式中，单独给某个方法通过装饰器来免除是无效的，需要加到dispatch函数上面# 方法1from django.views.decorators.csrf import csrf_exemptfrom django.utils.decorators import method_decoratorclass Test1(APIView): @method_decorator(csrf_exempt) def dispatch(self, request, *args, **kwargs): ret = super(Test1,self).dispatch(request, *args, **kwargs) return ret# 方法2@method_decorator(csrf_exempt,name='dispatch')class Test2(APIView): pass 单独想用CSRF的方法： 12345# 1.去掉setting中CSRF中间件from django.views.decorators.csrf import csrf_protect@csrf_protectdef test(request): pass","link":"/2020/09/24/Django%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CCSRF%E9%AA%8C%E8%AF%81/"},{"title":"Django使用中间件实现用户登录功能出现重复跳转的问题及解决方法","text":"先看一下出错的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243# 中间件class AuthMiddleware(MiddlewareMixin): def process_request(self, request): print(request.path) print(request.session.get('is_log')) if request.path != '/oa/login': if request.session.get('is_log'): return redirect('/oa/dashboard') else: return redirect('/oa/login') else: return# viewclass Login(View): def get(self, request): return render(request, 'website/signin.html') def post(self, request): res = {'status': 'succ'} user_name = request.POST.get(&quot;name&quot;, None) password = request.POST.get(&quot;password&quot;, None) re_log = request.POST.get(&quot;remember&quot;, None) if user_name == 'root' and password == '123': # 设置session request.session['user'] = user_name request.session['is_log'] = True # 如果选择记住状态则保持一周的session信息 if re_log == 1: request.session.set_expiry(1209600) res['status'] = 'succ' else: res['status'] = '密码错误' return HttpResponse(json.dumps(res), content_type=&quot;application/json&quot;)class Dashboard(View): def get(self, request): db = DataBase() data = db.dashboard() return render(request, 'website/dashboard.html', {'data': data}) 访问效果登录成功之后一直出现重复的跳转问题。 我们在来重新审视一下代码：首先我们登录成功之后访问/oa/dashboard这个页面，然后在中间间的处理过程中由于第一个if判断和第二个if判断都满足导致再次跳转到oa/dashboard页面一直重复。而且在访问其他页面的时候依然是一直跳转dashboard这个页面的，逻辑有误。 解决方法：在验证用户登录之后的session之后直接return掉而不是进行跳转。 12345678910class AuthMiddleware(MiddlewareMixin): def process_request(self, request): if request.path != '/oa/login': if request.session.get('is_log'): return else: return redirect('/oa/login') else: return 之前逻辑没看清，现在突然发现这个问题好傻逼","link":"/2019/09/24/Django%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E5%87%BA%E7%8E%B0%E9%87%8D%E5%A4%8D%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"Django使用邮箱进行验证操作的实现方法","text":"上一篇博客简单的说了说Django发送邮件的方法，这一篇仅仅谈一下如何通过邮件的方式进行验证，以重置密码功能为例。 其实验证方法比较简单，只需要发送指定的链接给目标邮箱，用户点击链接即可通过验证，但是合成和验证这个指定的链接需要我们来处理，我用到的方法是，当用户申请邮箱验证的时候根据其邮箱地址和一个32位随机验证码去合成一个连接，当正常访问的使用后台可通过URL获取邮箱名以及验证码，再根据这两个值去数据库中匹配，看能否成功，若是成功则完成验证失败则提示用户链接无效，接下来是具体的实现方法 首先我们需要建立一张数据库表，其中内容包括：邮箱地址、32位随机验证码、创建时间。 1234class email_reset(models.Model): email_address = models.EmailField(null=False,unique=True) #邮箱地址唯一的 vc_code = models.CharField(max_length=64,null=False) #随机验证码 send_time = models.DateTimeField(auto_now=True) #邮箱发送时间&lt;/code&gt;&lt;/pre&gt; 当用户需要用到邮箱验证的时候，则往数据库中新建一条数据之后在将邮箱地址和随机验证码合成为连接发送给目标 12345678910111213141516def send_email(email_address): vc_code = vc_code_generator() msg = '&lt;h2&gt;重置密码&lt;/h1&gt;'\\ '&lt;h6&gt;如果不是你本人操作请忽略本消息,本条消息30分钟内有效,如果被禁止跳转请复制链接在浏览器中重新打开&lt;/h6&gt;'\\ '&lt;a href=&quot;http://localhost:8000/iot/resetpwd/?email=%s&amp;code=%s&quot;&gt;点击重置密码&lt;/a&gt;' % (email_address,vc_code) u = models.email_reset.objects.filter(email_address=email_address).first() if u : models.email_reset.objects.filter(email_address=email_address).update(vc_code= vc_code) else: models.email_reset.objects.create(email_address=email_address,vc_code=vc_code) send_mail('重置密码', '请前往这个网址：localhost:8000/forgetpwd重置密码', &quot;*****管理员&lt;****************@163.com&gt;&quot;, [email_address], fail_silently=False, html_message=msg) #生成随机验证码def vc_code_generator(size=32, chars=string.ascii_uppercase + string.ascii_letters + string.digits): return ''.join(random.choice(chars) for _ in range(size)) 接下来则是处理URL了，根据之前发送的链接格式我们可以通过GET方式获取到其邮箱地址和验证码，再从数据库中查询是否有从 稍作简单的判断即可知道当前 12345678910if request.method == &quot;GET&quot;: email = request.GET.get(&quot;email&quot;) code = request.GET.get(&quot;code&quot;) if email and code: if models.email_reset.objects.filter(email_address=email).filter(vc_code=code): return render(request,'../templates/website/reset.html',{'email':email}) else: return HttpResponse(&quot;&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;&quot;) else: return HttpResponse(&quot;&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;&quot;)","link":"/2018/05/24/Django%E4%BD%BF%E7%94%A8%E9%82%AE%E7%AE%B1%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"},{"title":"Django发送邮件","text":"Django提供了发送邮件的接口，仅需做简单的设置即可实现发送邮件的功能。首先需要在setting做简单的配置，以163邮箱为例： 123456EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'EMAIL_HOST = 'smtp.163.com' EMAIL_PORT = 25EMAIL_HOST_USER = '****' # 帐号EMAIL_HOST_PASSWORD = '****' # 密码DEFAULT_FROM_EMAIL = &quot;*******&quot; #默认发送名 下面是官网的一个示例： 1234from django.core.mail import send_mailsend_mail('Subject here', 'Here is the message.', 'from@example.com', ['to@example.com'], fail_silently=False) 自定义一个测试的URL地址，传入相应的参数即可成功发送邮件 如果是放在云服务器上运行的时候需要注意25号端口有没有被禁用，有些服务商会将25号端口默认禁用，需要解禁后才能使用","link":"/2018/05/21/Django%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"title":"Django常用配置","text":"配置MySQL连接 1234567891011# setting.py中的数据库配置：DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'oa', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'PORT': '3306', }} 然后需要在项目__init__.py中添加将，pymysql作为默认的驱动库 12import pymysqlpymysql.install_as_MySQLdb() 从已有的数据库中导入结构命令行中输入python manage.py inspectdb &gt; appname/models.py 允许跨域请求 123456789101112131415161718192021222324252627282930313233343536373839INSTALLED_APPS = [ 'corsheaders', ]MIDDLEWARE = [ 'corsheaders.middleware.CorsMiddleware',]CORS_ALLOW_CREDENTIALS = TrueCORS_ORIGIN_ALLOW_ALL = TrueCORS_ORIGIN_WHITELIST = ( &quot;*&quot;)CORS_ALLOW_METHODS = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'VIEW',)CORS_ALLOW_HEADERS = ( 'XMLHttpRequest', 'X_FILENAME', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with', 'Pragma',) 设置中国时区 123456789LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False","link":"/2018/05/01/Django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"title":"Django支付宝自动转账功能（一）","text":"首先说明一下最终实现的效果：===》用户上传excel文件====》网页端显示读取文件并显示预览效果====》上传文件至服务器，服务器后台开始调用接口自动转账===》所有转账信息存储到数据库中，失败信息返回到网页上。 上一篇已经大致将支付接口实现了，这一篇将介绍如何和Django后台连接起来使用，在项目中使用的是excel文件储存转账信息的，所以我们首先需要了解如何读取Excel文件，然后才是进行转账操作，django则是提供网页服务，接收用户上传excel文件，保存交易信息等等。 1.网页端的预览：选择上传文件后需要将文件内容读取并显示出来，方便确认信息是否有误后在上传，这里主要是通过JS读取文件内容，然后再把数据以表格的形式展现出来。这里用到了一个一个xlsx插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//文件读取&lt;script src=&quot;http://oss.sheetjs.com/js-xlsx/xlsx.full.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /* FileReader共有4种读取方法： 1.readAsArrayBuffer(file)：将文件读取为ArrayBuffer。 2.readAsBinaryString(file)：将文件读取为二进制字符串 3.readAsDataURL(file)：将文件读取为Data URL 4.readAsText(file, [encoding])：将文件读取为文本，encoding缺省值为'UTF-8' */ var wb;//读取完成的数据 var rABS = false; //是否将文件读取为二进制字符串 function importf(obj) {//导入 if (!obj.files) { return; } var f = obj.files[0]; var reader = new FileReader(); reader.onload = function (e) { var data = e.target.result; if (rABS) { wb = XLSX.read(btoa(fixdata(data)), {//手动转化 type: 'base64' }); } else { wb = XLSX.read(data, { type: 'binary' }); } //wb.SheetNames[0]是获取Sheets中第一个Sheet的名字 //wb.Sheets[Sheet名]获取第一个Sheet的数据 document.getElementById(&quot;preview&quot;).innerHTML = XLSX.utils.sheet_to_html(wb.Sheets[wb.SheetNames[0]]); }; if (rABS) { reader.readAsArrayBuffer(f); } else { reader.readAsBinaryString(f); } } function fixdata(data) { //文件流转BinaryString var o = &quot;&quot;, l = 0, w = 10240; for (; l &lt; data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w))); o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w))); return o; }&lt;/script&gt; HTML部分 123456789&lt;form method=&quot;post&quot; action=&quot;&quot; id=&quot;upload_form&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div style=&quot;height: 40px;&quot;&gt; &lt;input id=&quot;uploadFile&quot; type=&quot;file&quot; onchange=&quot;importf(this)&quot; style=&quot;display: inline-block;&quot;name=&quot;payment&quot;/&gt; &lt;button id=&quot;upload&quot; style=&quot;height: 32px&quot;&gt;上传文件&lt;/button&gt; &lt;/div&gt; &lt;div style=&quot;border: 1px solid #3b8fc5;border-radius: 5px;height: 500px;position: relative;overflow: auto;text-align:center;vertical-align: middle;&quot;id=&quot;preview&quot;&gt; &lt;p style=&quot;color: #c1c1c1&quot;&gt;文件预览&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 最终效果 2.Excel文件上传和保存：通过Ajax提交form表单数据到后台，Ajax操作没什么可说的了，需要注意的是form 的enctype属性值，来看一下W3C上面的介绍 因此我们在上传文件的时候要用enctype=”multipart/form-data”前端发送文件了接下来就是后端接收文件了，文件数据会包含在request.FILES里面（注意，只有当request方法为POST并且form 的enctype属性值为multipart/form-data的时候request.FILES才会有数据request.FILES中包含下面几个属性：name(文件名)、size(文件大小)、content_type(文件类型)、read()读取整个文件、chunks()返回一个生成器对象 12345file = request.FILES.get('payment', None)f = open(file.name, 'wb')for chunck in file.chunks(): f.write(chunck)f.close() 至此文件就保存下来了，文件名就是上传的文件名，路径默认为根路径","link":"/2018/08/11/Django%E6%94%AF%E4%BB%98%E5%AE%9D%E8%87%AA%E5%8A%A8%E8%BD%AC%E8%B4%A6%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Django支付宝自动转账功能（二）","text":"接着上一篇的介绍，这部分将介绍如何读取上传的文件并调用转账接口实现转账功能。具体步骤 ===》打开文件 ===》读取每一行的数据 ===》调用支付宝单笔转账接口 1.Excel文件的读取python读取excel文件需要用到xlrd这个库，这个库的具体用法这里就不说了，主要介绍一下读取excel文件的步骤： 使用xlrd.open_workbook(path)打开文件 遍历文件中所有的sheet，并且读取所有行数据123456for sheet in ExcelFile.sheet_names(): data = ExcelFile.sheet_by_name(sheet) i = 0 while i &amp;lt; (data.nrows): yield data.row_values(i) i += 1 为了防止文件过大占有太多内存，没有一次将所有数据都读取出来，而是使用生成器返回一个迭代对象，每次调用这个迭代对象来取出数据。 123f = read_excel('../files/2018.7.30(1).xls')for i in f: print(i) 运行结果： 2.调用转账接口：接口部分我们之前已经说过了，现在只需要将excel中的数据传递进去就能够实现转账功能了，为了不单单只是在后台打印交易信息，对之前的pay方法做一些调整 12345678910111213141516171819202122data = {'payee_account': None, 'amount': None, 'payee_real_name': None, 'remark': None, 'order_id': None, 'out_biz_no': None, 'pay_date': None, 'status': None}if result['code'] == '10000': if result['msg'] == &quot;Success&quot;: print(payee_account + &quot; 转账成功&quot; + &quot; 交易单号：&quot; + result[&quot;out_biz_no&quot;]) data['payee_account'] = payee_account data['amount'] = amount data['payee_real_name'] = payee_real_name data['order_id'] = result['order_id'] data['out_biz_no'] = result['out_biz_no'] data['pay_date'] = result['pay_date'] data['status'] = '转账成功' return dataelse: print(payee_account, amount, result['sub_msg'], result[&quot;out_biz_no&quot;]) data['payee_account'] = payee_account data['amount'] = amount data['payee_real_name'] = payee_real_name data['out_biz_no'] = result['out_biz_no'] data['status'] = result['sub_msg'] # error = [payee_account, amount, payee_real_name, result['sub_msg'], result['out_biz_no']] return data 方便起见将excel文件读取和转账接口封装到一个函数里面了，现在只需要传递文件路径就能直接转账了，数据库写入就不详细说了。 12345678910111213141516def run(path): file = read_excel(path) pay = Payment(*******) data = [] error = [] for item in file: res = pay.pay(item[1], item[0], item[3], item[2]) res['remark'] = item[4] data.append(res) if res['status'] != '转账成功': error.append([res['payee_account'], res['amount'], res['payee_real_name'], res['remark'], res['status'], res['out_biz_no']]) # except Exception as e: # pass write(data) # 写入数据库 return error # 网页返回错误信息 3.网页显示失败信息：这一步没什么好说的了，我是直接使用django的render函数将错误信息渲染完成之后返回了一个新的页面。其实用Ajax接收数据然后js来渲染页面这种做法要好一些。","link":"/2018/08/12/Django%E6%94%AF%E4%BB%98%E5%AE%9D%E8%87%AA%E5%8A%A8%E8%BD%AC%E8%B4%A6%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Django文档阅读笔记","text":"模型（Model）字段 null和blank的区别 null和blank默认都是为false的，不能为空，而null是数据库层面的不为空，blank则会影响form验证（blank=True表单验证的时候可以为空，blank=False表单验证不能为空） choice choice参数值为列表或元组，可以通过get_FOO_display()方法获取其显示的值 123456789101112131415161718from django.db import modelsclass Person(models.Model): SHIRT_SIZES = ( ('S', 'Small'), ('M', 'Medium'), ('L', 'Large'), ) name = models.CharField(max_length=60) shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES) &gt;&gt;&gt; p = Person(name=&quot;Fred Flintstone&quot;, shirt_size=&quot;L&quot;)&gt;&gt;&gt; p.save()&gt;&gt;&gt; p.shirt_size'L'&gt;&gt;&gt; p.get_shirt_size_display()'Large' primary_key 在Django的一个模型中必须有一个主键字段，如果没有设置过primary_key = True，Django会自动创建一个自增的字段作为主键 1id = models.AutoField(primary_key=True) related_name ForeignKey 的 related_name 可以为反向关系定义一个有意义的名称 1234567class Company: name = models.CharField(max_length=30)class Employee: first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) company = models.ForeignKey(Company, on_delete=models.CASCADE, related_name='employees') 上面代码意味着， Company 有一个employees特殊属性, 该属性将返回一个 QuerySet，其中包含与此公司相关的所有员工实例 12google = Company.objects.get(name='Google')google.employees.all() 你也可以通过反向关系， 来更新Company的employees字段. 123vitor = Employee.objects.get(first_name='Vitor')google = Company.objects.get(name='Google')google.employees.add(vitor) related_query_name 这种关系也是用于查询过滤器， 比如我们要查询雇佣名为「Vitor」的所有公司: 1companies = Company.objects.filter(employee__first_name='Vitor') 如果你想自定义此关系的查询名称可以这样 123456789class Employee:first_name = models.CharField(max_length=30)last_name = models.CharField(max_length=30)company = models.ForeignKey( Company, on_delete=models.CASCADE, related_name='employees', related_query_name='person') 然后这样查询 1companies = Company.objects.filter(person__first_name='Vitor') Meta选项 app_label：string 定义APP名称（模型不是在APP中定义的，需要声明） db_table：string 自定义数据库表名 ordering：[string, ] 对象的默认排序，参数值为包含字段名的列表， 其中如果字段名前缀加了- 为降序，否则为升序 managed：Boolean 默认为True，Django会在迁移过程中创建或删除数据库表，如果为False时则不会执行数据库表创建或删除操作，（如果模型中包含多对多的关联字段则不会创建多对多联接中间表，但是托管模型和非托管模型之间的中间表，想要修改这个行为需要将中间表设为自定义模型） order_with_respect_to: string 可用于使相关对象相对于父对象可排序，需要注意的是不能和ordering一起使用 例如问题和回答的排序。 1234567891011121314151617181920212223242526from django.db import modelsclass Question(models.Model): text = models.TextField() # ...class Answer(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) # ... class Meta: order_with_respect_to = 'question'# 提供两个默认的方法来设置相关对象的顺序# 1.get_RELATED_order() 返回包含相关对象的主键列表&gt;&gt;&gt; question = Question.objects.get(id=1)&gt;&gt;&gt; question.get_answer_order()[1, 2, 3]# 2.set_RELATED_order() 通过传入主键列表来设置排序结果&gt;&gt;&gt; question.set_answer_order([3, 1, 2])# get_next_in_order() get_previous_in_order() 获取下一个、前一个对象&gt;&gt;&gt; answer = Answer.objects.get(id=2)&gt;&gt;&gt; answer.get_next_in_order()&lt;Answer: 3&gt;&gt;&gt;&gt; answer.get_previous_in_order()&lt;Answer: 1&gt; permission：[(permission_code, human_readable_permission_name),] Django会自动为每个模型创建添加，修改，删除和查看的权限，permission可以添加新的自定义权限 default_permission: [] 默认权限 required_db_features 仅在某些功能（数据库的）打开的情况下同步 required_db_vendor 指定数据库类型，满足条件才会同步 indexes 指定模型上的索引列表 unique_together: tuple(tuple) 联合唯一 管理器","link":"/2020/12/07/Django%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"title":"Django的template自定义函数的创建和使用","text":"首先需要在APP目录下创建一个templatetags目录然后在这个目录下新建一个任意名的.py文件 如 test.py创建一个template对象register 1234from django import templatefrom django.utils.safestring import mark_saferegister =template.Library() 下面在这个文件中我们就可以写自定义函数了有两种方式一种是simple_tag,这种会限制参数的个数，但是不能作为if的条件来使用 123@register.simple_tagdef add(a,b): return a+b 一种是filter，这个最多只能传递两个参数，可作为if条件使用 123@register.filterdef subtract(a,b): return a-b 这时候就可以在模板文件中使用这个函数了首先在开头位置导入test.py文件simple_tag直接使用%来调用函数，如果函数需要传参数，需要在函数后直接添加即可（用空格隔开） 12345{% load test %}{% add 2 3 %}{{ 1|subtract:2 }} 要注意的是app目录下的templatetags名不能更改 register也不能更改，还需要在settings里面注册这个app","link":"/2018/08/23/Django%E7%9A%84template%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"Django页面跳转但是不会显示出来？？？","text":"一脸懵逼，点击登录，如果错了会有提示，但是登录成功了后台会显示跳转到dashboard上，也能正常获取到cookie，但是就是页面不会变化，单独访问dashboard也是正常的。问题代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# login class Login(View): ''' 用户登录 ''' def get(self, request): return render(request, 'website/signin.html') def post(self, request): res = {'status': 'succ'} user_name = request.POST.get(&quot;name&quot;, None) password = request.POST.get(&quot;password&quot;, None) u = models.WebsiteUserinfo.objects.filter(username=user_name).first() if not u: res['status'] = '用户名错误' else: if password == u.password: # re = render(request,'website/dashboard.html') re = redirect('/oa/dashboard') re.set_cookie('is_log', True) # 设置cookie re.set_cookie('username', user_name) return re else: res['status'] = '密码错误' return HttpResponse(json.dumps(res), content_type=&quot;application/json&quot;)# dashboardclass Dashboard(View): ''' 主页 ''' def get(self, request): print(request.COOKIES['username']) return render(request, '../templates/website/dashboard.html', {'auth': '1234'})# 路由配置from django.conf.urls import url,includefrom django.contrib import adminfrom website import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$',views.init), url(r'^oa/', include('website.urls')),]from django.conf.urls import urlfrom website import viewsurlpatterns = [ url(r'^dashboard', views.Dashboard.as_view()), url(r'^realtime_table', views.RealTimeTable.as_view()), url(r'^everyday_table', views.EveryDayTable.as_view()), url(r'^login', views.Login.as_view()),] 后台输出： 解决问题注意力一直放在后台上了，之前是通过session保存用户状态的，现在需要改为cookie验证，如果要设置cookie返回类型必须为render，redirect，因此就将原来登录成功返回json改为了redirect，但是没有想到的是前端是通过Ajax发送消息的，无法识别返回类型，就导致了登录成功了却没有反应。总结来说是一个很、非常、超级低端的问题，只怪自己想当然的修改。 还是返回json格式，让js去设置cookie 12345678910111213141516171819function login() { $.ajax({ type: &quot;POST&quot;,//方法类型 dataType: &quot;json&quot;,//预期服务器返回的数据类型 url: &quot;/oa/login&quot;,//url data: $('#login_form').serialize(), success: function (data) { if (data['status'] != &quot;succ&quot;){ alert(data['status']); } if (data['status'] == &quot;succ&quot;){ var name = document.getElementById('u1').value; document.cookie=&quot;is_log=True;&quot;; document.cookie=&quot;username=&quot;+name; window.location.href='/oa/dashboard'; } } });}","link":"/2018/12/14/Django%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E4%BD%86%E6%98%AF%E4%B8%8D%E4%BC%9A%E6%98%BE%E7%A4%BA%E5%87%BA%E6%9D%A5%EF%BC%9F%EF%BC%9F%EF%BC%9F/"},{"title":"Docker命令","text":"安装 apt-get install docker.io 获取镜像：docker pull 运行一个容器： docker run &lt;参数&gt; 常见的参数 -d, –detach=false 指定容器运行于前台还是后台，默认为false -i, –interactive=false， 打开STDIN，用于控制台交互 -t, –tty=false， 分配tty设备，该可以支持终端登录，默认为false -u, –user=””， 指定容器的用户 -a, –attach=[]， 登录容器（必须是以docker run -d启动的容器） -w, –workdir=””， 指定容器的工作目录 -c, –cpu-shares=0， 设置容器CPU权重，在CPU共享场景使用 -e, –env=[]， 指定环境变量，容器中可以使用该环境变量 -m, –memory=””， 指定容器的内存上限 -P, –publish-all=false， 指定容器暴露的端口 -p, –publish=[]， 指定容器暴露的端口 -h, –hostname=””， 指定容器的主机名13。 -v, –volume=[]， 给容器挂载存储卷，挂载到容器的某个目录 将容器变为镜像 ： docker commit -a “creator name” -m “information” containerID imagename:tag 删除单个容器：docker rm containerID 删除所有容器：docker rm $(docker ps -a -q) 删除镜像：docker rmi imageID / docker rmi imageName:Tag","link":"/2018/12/14/Docker%E5%91%BD%E4%BB%A4/"},{"title":"ESP-IDF 在 WSL2中的安装和使用","text":"以 Ubuntu22.04 子系统为例，下面介绍 ESP-IDF 的安装、 VS Code 的配置，以及 USB 的相关设置。 安装系统依赖1sudo apt-get install git wget flex bison gperf python3 python3-pip python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 获取ESP-IDF打开终端，执行以下命令，默认安装在用户目录下 %userprofile%/esp 123mkdir ~/esp &amp;&amp; cd ~/esp# 这里可以根据自己选择安装不同的版本，github 需要梯子才能访问git clone -b v4.4.3 --recursive https://github.com/espressif/esp-idf.git 安装ESP-IDF等待下载完成之后，进入到 ~/esp/esp-idf 下面，执行脚本自动安装 12cd ~/esp/esp-idf./install.sh 可以指定需要安装的芯片，例如 esp32s3、esp32c3 等等，默认安装为所有芯片都安装 配置命令行工具一般来说我们只需要执行 export.sh 即可激活 esp-idf 的命令行工具 1. ~/esp/esp-idf/export.sh 但是每次都需要手动执行，如果使用了类似于zsh的工具，可以通过配置来简化步骤，以 zsh 为例 12345678vim ~/.zshrc# 增加下面这行可以在启动终端的时候默认激活idf. ~/esp/esp-idf/export.sh# 或者增加别名，通过别名手动激活（更为推荐）alias get_idf=&quot;. ~/esp/esp-idf/export.sh&quot; 保存后需要重启终端或者执行 source ~/.zshrc 才会生效 VS Code插件安装一般来说不会直接在 WSL2 里面编写代码，借助于 IDE 可以更方便的进行开发，乐鑫官方提供了 VS Code 插件，只需要在扩展里面搜索 ESP-IDF 即可安装，需要注意的是，ESP-IDF 安装在 WSL2 里面，所有需要提前安装 WSL 插件，进入到 WSL2 环境里面再安装 ESP-IDF 插件，插件安装成功后会自动识别 ESP-IDF 安装路径进行配置， 让 WSL2 能够连接 USB 设备此时 WSL2 是没办法识别到我们插入的开发板，可以参考微软的官方文档来解决这个问题 https://learn.microsoft.com/zh-cn/windows/wsl/connect-usb 可以在 WSL2 终端通过 uname -a 命令查看内核版本，如果低于 5.10.60.1 可以执行 wsl --update 来更新到最新的内核 在 Windows 安装 USBIPD通过 winget 命令安装 1winget install --interactive --exact dorssel.usbipd-win 或者直接下载 msi 文件安装，地址为 https://github.com/dorssel/usbipd-win/releases/download/v2.4.1/usbipd-win_2.4.1.msi 安装完成后需要重新打开终端，否则 usbipd 命令会找不到。 在 WSL2 安装 USBIP 工具按照官网上面的命令，可能会报如下错误 12345678sudo apt install linux-tools-5.4.0-77-generic hwdataReading package lists... DoneBuilding dependency tree... DoneReading state information... DoneE: Unable to locate package linux-tools-5.4.0-77-genericE: Couldn't find any package by glob 'linux-tools-5.4.0-77-generic' 参考：https://github.com/dorssel/usbipd-win/wiki/WSL-support 来解决上面的问题 12sudo apt install linux-tools-virtual hwdatasudo update-alternatives --install /usr/local/bin/usbip usbip `ls /usr/lib/linux-tools/*/usbip | tail -n1` 20 将 USB 设备添加到 WSL2 中 12345678910111213141516171819202122# Windows 系统# 需要使用管理员身份运行&gt; usbipd wsl listBUSID VID:PID DEVICE STATE1-2 1462:7d97 USB 输入设备 Not attached1-9 1a86:7523 USB-SERIAL CH340 (COM5) Not attached1-14 8087:0033 英特尔(R) 无线 Bluetooth(R) Not attached4-3 046d:c52b USB 输入设备 Not attached4-4 05ac:024f USB 输入设备 Not attached# BUSID 为 1-9 是目标设备usbipd wsl attach --busid 1-9 # WSL2 子系统&gt; lsusbBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 001 Device 002: ID 1a86:7523 QinHeng Electronics CH340 serial converterBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub# 可以看到 CH340 已经挂载成功 如果使用完成想要将 USB 设备从 WSL2 断开，只需要执行下面命令即可 1usbipd wsl detach --busid &lt;busid&gt; 编译&amp;烧录示例项目通过自带的 hello_world 项目，进行编译和烧录来测试安装是否成功 123456789# 激活idf虚拟环境get_idf # 创建一个工作目录mkdir ~/workspace $$ cd ~/workspace# 复制hello_world工程cp -r $IDF_PATH/examples/get-started/hello_world .cd hello_world# 编译idf.py build 通过 VS Code 打开对应的目录，通过底部菜单栏，根据自己的开发板依次设置 端口、芯片型号、烧录方式，最后点击🔥图标 ESP-IDF Build, Flash and Monitor，如果能在终端窗口看到串口输出内容，那么就说明整个安装过程是没有问题的。","link":"/2022/11/18/ESP-IDF%E5%9C%A8WSL2%E4%B8%AD%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"Excel文件的创建和下载","text":"简述：利用xlwt和django将table内的数据转换为excel文件下载到本地保存 生成Excel文件使用了 xlwt 库，xlwt库可以将数据和格式信息写入到Excel文件中，具体步骤如下 创建Excel文件首先需要实例化 Workbook 对象12class &lt;code&gt;xlwt.Workbook.&lt;/code&gt;&lt;code&gt;Workbook(&lt;/code&gt;encoding ='ascii'，style_compression = 0 )#有两个参数 encoding→文件编码格式 style_compression → 是否压缩 ，一般情况下使用默认参数即可。 通过Workbook的add_sheet方法创建工作表12add_sheet (sheetname, cell_overwrite_ok=False)sheetname→工作表名称 cell_overwrite_ok 重复写入同一个单元格是否覆盖原有内容，通过源码中发现当我们调用这个 方法的时候实际上得到的返回结果为一个Worksheet实例化对象 12345678910111213141516171819202122232425262728293031def add_sheet(self, sheetname, cell_overwrite_ok=False): &quot;&quot;&quot; This method is used to create Worksheets in a Workbook. :param sheetname: The name to use for this sheet, as it will appear in the tabs at the bottom of the Excel application. :param cell_overwrite_ok: If ``True``, cells in the added worksheet will not raise an exception if written to more than once. :return: The :class:`~xlwt.Worksheet.Worksheet` that was added. &quot;&quot;&quot; from . import Utils from .Worksheet import Worksheet if not isinstance(sheetname, unicode_type): sheetname = sheetname.decode(self.encoding) if not Utils.valid_sheet_name(sheetname): raise Exception(&quot;invalid worksheet name %r&quot; % sheetname) lower_name = sheetname.lower() if lower_name in self.__worksheet_idx_from_name: raise Exception(&quot;duplicate worksheet name %r&quot; % sheetname) self.__worksheet_idx_from_name[lower_name] = len(self.__worksheets) self.__worksheets.append(Worksheet(sheetname, self, cell_overwrite_ok)) return `self.__worksheets[-1] 往单元格里面写入数据通过Worksheet 的write方法写入数据write（r，c，label =’’，style = &lt;xlwt.Style.XFStyle object&gt; ） r 、c参数为单元格的行列数 label需要写入的数据 style指定单元格的内容格式 通过xlwt.Style.easyxf()方法创建格式对象，包含字体、大小、颜色等 保存使用Workbook中的save方法保存，save方法提供两种保存方式：1.写入到本地磁盘 2.具有write方法的流对象 Excel文件下载Django提供有自带的文件下载功能，直接导入引用就可以了 123456from django.http import FileResponsefile = open(name, 'rb')response = FileResponse(file)response['Content-Type'] = 'application/octet-stream'response['Content-Disposition'] = 'attachment;filename=' + datetime.now().strftime(&quot;%Y-%m-%d&quot;) + namereturn response 示例 123456789101112import xlwtdef write(data, name): wbx = xlwt.Workbook() sheet = wbx.add_sheet('Sheet1', cell_overwrite_ok=True) for row, i in enumerate(data): col = 0 for j in i: sheet.write(row, col, i[j]) col += 1 wbx.save(name)","link":"/2018/08/07/Excel%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%B8%8B%E8%BD%BD/"},{"title":"Git命令","text":"git init 初始化版本库 git config –global user.name (your name) git config –global user.email (your email) git add (file name) 将文件放置到缓存区 git commit -m (describe) 将缓存区的文件提交到分支上 6. git status 查看版本库状态 git diff 查看具体修改内容 git log 查看提交记录 git reset – hard HEAD^ 退回上一次提交、 HEAD^^ 退回前两次、 HEAD~n 退回到前n次 、 commit id 退回到指定的位置 git reflog 查看命令记录 git checkout – (file name) 撤销修改 git rm (file name) 删除文件 git remote set-url origin [URL] 修改远程仓库地址 git config –global credential.helper store 永久记录Https用户名密码","link":"/2018/05/21/Git%E5%91%BD%E4%BB%A4/"},{"title":"HTTP协议基础","text":"总结于图解HTTP协议 什么是URI和URL？URI（统一资源标识符）表示的是某一个互联网资源， URL（统一资源定位符）相交于URI我们对于URL要更为熟悉一些，我们在浏览器上输入的网站地址其实就是一个URL 例如：http://www.google.com ，URL表示的是资源的地点，所以呢URL是URI的一个子集，URI中包含URL的。 用一个形象点的例子来说明URI和URL的区别：我们每一个人都有身份证，每一个人的身份证号都是不同的，可以根据这个号码来找到这个唯一的人，这就相当于URI，而URL呢则类似于身份证上的地址信息，例如（某某省/某某市/某某区/某某街道/某某门牌号/姓名）通过这个地址我们也能找到这个人。 URI格式绝对URI格式一个绝对的URI包含了 协议名 使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号 认证信息（可选） 指定用户名和密码作为从服务器端获取资源时必要的登录信息 服务器地址 使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似google.com 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。 服务器端口号（可选） 指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。 带层次的文件路径 指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。 查询字符串（可选） 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。 片段标识位（可选） HTTP协议用于客户端和服务器端之间的通信在应用HTTP协议的时候必定一端为客户端而另一端为服务端角色，客户端通过请求，服务器端反馈响应实现两者之间的通信（请求必定是客户端发送的，服务器端在没有接收到请求的时候是不能发送响应的） 发送请求 一个简单的请求报文内容 123GET /index.html HTTP/1.1Host: baidu.comConnection: keep-alive 起始行首先声明了请求访问服务器的类型为GET ， 随后的字符串/index.html指明了请求访问的资源对象，最后是HTTP协议的版本号 下面的是请求首部字段，这里面通常会有Host、Connection、Content-Type等等，除了这些可能还会包含内容实体用于发送请求的数据 返回响应 123456HTTP/1.1 200 OKDate: Mon, 04 Mar 2019 07:34:18 GMTContent-Type: text/html&lt;html&gt;&lt;/html&gt; 同样的在第一行中HTTP/1.1 表示了服务器对应的HTTP版本， 200 OK表示请求的处理结构的状态码和原因短语，第二行显示了创建响应的日期和时间，接着空一行，之后的就是响应的资源实体了 HTTP协议是不保存状态的协议 HTTP本身是无状态的协议，自身不会对请求和响应之间的通信状态进行保存，但是往往我们在浏览网页的时候进行页面跳转需要保留我们的登陆信息以便服务器知道每次请求是谁发送的，所以就有了Cookie技术 使用Cooke实现状态管理 Cookie技术通过在请求和响应报文中写入Cookie信息来实现对客户端的状态的控制 首先Cookie会根据服务器端响应报文内的set-cookie字段信息通知客户端保存cookie，下次客户端再请求的时候将接收到的cookie值添加到请求报文中发出 客户端在接收到携带有cookie的请求后会根据cookie值和服务器上的记录进行比对以此来确定客户端的状态 没有cookie时候的请求报文 12GET /index.html HTTP/1.1Host: baidu.com 服务器接收到没有cookie的响应返回 1234567HTTP/1.1 200 OKDate: Mon, 04 Mar 2019 07:34:18 GMTContent-Type: text/html＜Set-Cookie: sid=1342077140226724; path=/; expires=Mon, 04 Mar 2019 07:34:18 GMT＞&lt;html&gt;&lt;/html&gt; 客户端携带cookie发送请求 123GET /index.html HTTP/1.1Host: baidu.comCookie: sid=1342077140226724 更进一步：session的使用 session的应用是基于cookie的，cookie无法存储复杂的数据，这时候就需要用到session来实现，session保存于服务器端类似以key-value结构，其中key值可以使用cookie存放，每次请求过来时候服务器端可以通过cookie值去session中获取对应的用户信息，以此记录控制客户端的状态（cookie存放在客户端中，session保存于服务器端） http请求方法 GET：获取资源 POST：传输实体主体 PUT：传输文件 DELETE：删除文件 HEAD：获取报文首部 OPTIONS：询问支持的方法 响应报文 12HTTP/1.1 200 OKAllow: GET, POST, HEAD, OPTIONS TRACE：追踪路径，让服务器端将之前的请求通信环回给客户端（可以用来查询请求是如何加工或者传递到服务器端的） CONNECT: 使用隧道协议连接代理 CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。 长连接 在早期的http协议中，每次通信就需要断开TCP连接，随着时代的发展一个页面可能需要请求很多次，这样一来就会不断的断开连接增加通信的开销，所以在1.1和部分1.0版本中出现了持久连接，只要一端没有明确提出断开连接，那么就会保持TCP的连接状态 HTTP报文内的HTTP信息 HTTP报文大致可分为报文首部+报文主体两块，两者通过（CR+LF）来划分 获取部分内容的范围请求 执行范围请求的时候，请求体的首部字段Range需要用来指定资源的byte范围 1234GET /index.html HTTP/1.1Range: bytes=5001-10000 请求50001-10000字节内容Range: bytes=5001- 请求5001之后的所有内容 Range: bytes=-3000, 6000-7000 请求前3000字节和6000-7000字节内容的多重范围 范围请求的响应会返回状态码为206 Partial Content的响应报文，多重范围响应会在首部字段Content-type标明multipart/byteranges，如果服务器不支持范围请求那么会返回200 OK和全部实体内容 HTTP状态码 2XX成功 （服务器返回2XX表明请求被正常处理了） 200 OK 表示客服端发送的请求被服务器端正常处理了 204 No Content 表示客服端发送的请求被服务器端正常处理了，但是在返回的响应报文中不包含实体部分 206 Partial Content 就是上面说的范围请求响应 3XX重定向 （浏览器需要执行某些其他的处理才能服务器端才能正常处理请求） 301 Moved Permanently 永久性的重定向，表明改请求资源的URI发生更改了，需要请求新的URI 302 Found 临时重定向，和上面的不同，服务器希望本次使用新的URI进行访问，只是临时性的 303 See Other 表示请求的资源存在另一个URI，应该使用GET方法请求该资源，例如使用POST方法访问某个资源，但是服务器处理的结果是希望客户端使用GET方法来请求这个资源 304 Not Modified 该状态码表示客户端使用GET方法并且请求报文中包含 If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since 中任一首部，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。 307 Temporary Redirect 临时重定向和302相同，但是禁止POST变成GET 4XX 客户端错误 （客服端发送的请求服务器无法正确处理） 400Bad Request 请求报文中存在语法错误 401 Unauthorized 需要通过HTTP认证才可访问（BASIC认证、DIGEST认证） 403 Forbidden 这次请求被服务器拒绝了 404 Not Found 服务器无法找到此次请求的资源 5XX 服务器错误 500 Internal Server Error 服务器处理请求是发生错误 503 Service Unavailable 服务器超载，无法处理请求 WEB服务器 在一台主机上部署多个web站点 在HTTP/1.1协议规范中允许一台服务器搭建多个web网站，假如一台服务器中绑定了www.baidu.com和www.google.com 两个域名的时候，我们输入这两个域名的时候都会解析到同一个IP地址上，这个时候如果想要区分用户请求的是那个域名就必须在请求首部Host指定域名。 代理服务器 代理服务器最基本的功能就是接受客户端的请求，并将请求转发给其他的服务器，代理并不会改变请求的URL，会直接将请求进行转发，每次通过代理服务器转发请求的或者响应的时候都会在首部添加Via信息，最常见的代理服务就是我们使用的翻墙服务。 代理服务还细分为正向代理和反向代理，通俗来说正向代理是针对于客户端（服务器端并不知道客户端的真实信息），反向代理是针对于服务器端（客户端不知道服务器端的实际地址） 正向代理的作用： 翻墙（访问客户端无法访问的资源） 缓存，加速访问速度 对外隐藏真实的客户端信息 反向代理的作用： 保证内网的安全 负载均衡 网关 网关和代理的作用很类似，但是网关能够实现非HTTP协议的服务，利用网关可以提高通信的安全性。 隧道 在客户端和服务器端建立一条加密的通信线路，确保客户端和服务器端的安全通信，隧道本身不会解析HTTP请求，会原样将请求转发给服务器。 HTTP首部之前提到过一个HTTP的报文主要分为首部和主体两个部分，主体部分不是客户端和服务器端根据操作生成的所以没有办法去介绍，在此只介绍部分常见的首部字段的作用和用法。 下图是分别是请求报文和响应报文的首部构成： 字段结构：字段名：字段值1, 字段值2…. 报文首部主要分为以下四个部分： 通用首都字段 实体首部字段 请求实体字段 响应实体字段 常见字段一览 通用首部字段 字段名 说明 Cache-Control 控制缓存行为 Connection 逐跳首部、连接的管理 Date 创建报文的时间和日期 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器相关信息 Warning 错误通知 实体首部字段 字段名 说明 Allow 资源可支持的HTTP方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位：字节） Content-Location 替代对应资源的URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的范围位置 Content-Type 实体主体的媒体类型 Expires 实体主题过期的日期和时间 Last-Modified 资源的最后修改日期和时间 请求首部字段 字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的自然语言 Authorization Web认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag) If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与If-Match想法） If-Range 资源为更新时发送实体Byte的范围请求 If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 User-Agent HTTP客户端程序的信息 响应首部字段 字段名 说明 Accept-Ranges 是否接收字节范围请求 Age 推算资源创建经过的时间 Etag 资源的匹配信息 Location 命令客户端重定向至指定URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发送请求的时机要求 Server HTTP服务器安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息","link":"/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"},{"title":"Leet Code OJ  简单（一）","text":"1.两数之和 3780ms 1234567891011class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; for i in range(len(nums)): for m in range(i+1, len(nums)): if nums[i]+nums[m] == target: return [i, m] 7.反转整数 80ms （python的负数取余和C语言 不同 12345678910111213141516171819202122232425class Solution: def reverse(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; y = 0 while x: if x &amp;gt; 0: y *= 10 y += x % 10 x = x // 10 else: y *= 10 if x % 10: y += x % 10 - 10 x = x // 10 + 1 else: y += x % 10 x = x // 10 if y &amp;gt; -pow(2, 31) and y &amp;lt; pow(2, 31) - 1: return y else: return 0 9.回文数 408ms 1234567891011class Solution: def isPalindrome(self, x): &quot;&quot;&quot; :type x: int :rtype: bool &quot;&quot;&quot; x = str(x) for i in range(len(x)): if x[i] != x[-i-1]: return False return True 13.罗马数字转整数 212ms 123456789101112131415class Solution: def romanToInt(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; rec = 0 num = {'I': 1, 'IV': 4, 'V': 5, 'IX': 9, 'X': 10, 'XL': 40, 'L': 50, 'XC': 90, 'C': 100, 'CD': 400, 'D': 500, 'CM': 900, 'M': 1000} while s: for i in range(2, 0, -1): if s[:i] in num: rec += num[s[:i]] s = s[i:] break return rec 14.最长公共前缀 54ms 123456789101112131415161718class Solution: def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; if strs: for i in range(len(strs[0])+1): for s in range(1, len(strs)): if strs[0][:i] != strs[s][:i]: if strs[0][:i - 1]: return strs[0][:i-1] else: return &quot;&quot; return strs[0] else: return &quot;&quot;","link":"/2018/04/17/Leet%20Code%20OJ%20%20%E7%AE%80%E5%8D%95%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Leet Code OJ  简单（三）","text":"58.最后一个单词的长度 52ms 123456789101112class Solution: def lengthOfLastWord(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; s = s.split(' ') while &quot;&quot; in s: s.remove(&quot;&quot;) if not s: return 0 return len(s[-1]) 66.加一 56ms 12345678910111213141516171819class Solution: def plusOne(self, digits): &quot;&quot;&quot; :type digits: List[int] :rtype: List[int] &quot;&quot;&quot; sum = 0 r = [] for index, i in enumerate(digits): sum += i*pow(10,len(digits)-index-1) sum += 1 while sum: i = 1 r.append(sum % pow(10,i)) sum = sum // pow(10,i) i += 1 r.reverse() return r 67.二进制求和 60ms 12345678class Solution: def addBinary(self, a, b): &quot;&quot;&quot; :type a: str :type b: str :rtype: str &quot;&quot;&quot; return (bin(int(a, 2) + int(b, 2))[2:]) 69.x的平方根 76ms 击败了81.06% 的用户 1234567class Solution: def mySqrt(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; return int(pow(x, 0.5)) 83.删除排序链表重复元素 76ms 击败了48.84% 的用户 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteDuplicates(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if not head: return None cur = head while cur.next: if cur.val == cur.next.val: if cur.next.next: t = cur.next.next cur.next = t else: cur.next = None else: cur = cur.next return head","link":"/2018/04/19/Leet%20Code%20OJ%20%E7%AE%80%E5%8D%95%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"Leet Code OJ  简单（二）","text":"20. 有效括号 48ms 12345678910111213141516171819class Solution: def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; if len(s) % 2 : return False brackets = {'(': ')', '{': '}', '[': ']'} stack = [] for i in s: if i in brackets: stack.append(i) else: if not stack or brackets[stack.pop()] != i: return False if stack: return False return True 26.删除排序数组中的重复项 96ms 1234567891011121314class Solution: def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) &amp;lt;= 1: return len(nums) s = 0 for f in range(1, len(nums)): if nums[s] != nums[f]: s += 1 nums[s] = nums[f] return s + 1 27.移除元素 56ms 123456789101112class Solution: def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; if val not in nums: return len(nums) while val in nums: nums.remove(val) return len(nums) 28.实现strStr() 48ms 12345678910111213class Solution: def strStr(self, haystack, needle): &quot;&quot;&quot; :type haystack: str :type needle: str :rtype: int &quot;&quot;&quot; if not needle: return 0 if needle not in haystack: return -1 else: return haystack.index(needle) 35.搜索插入位置 48ms 12345678910111213141516class Solution: def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if target in nums: return nums.index(target) if target &amp;lt; nums[0]: return 0 if target &amp;gt; nums[-1]: return len(nums) for i in range(len(nums)-1): if nums[i]&amp;lt;target and nums[i+1]&amp;gt;target: return i+1","link":"/2018/04/18/Leet%20Code%20OJ%20%E7%AE%80%E5%8D%95%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Leet Code OJ  简单（四）","text":"88.合并两个有序数组 56ms 提交中击败了47.05% 的用户 1234567891011121314151617class Solution: def merge(self, nums1, m, nums2, n): &quot;&quot;&quot; :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; for i in range(n): temp = nums2[i] j = m-1 while j &amp;gt;=0 and nums1[j] &amp;gt; temp: nums1[j+1] = nums1[j] j -= 1 nums1[j+1] = temp m += 1 100. 相同的树 48 ms 击败了58.92% 的用户 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSameTree(self, p, q): &quot;&quot;&quot; :type p: TreeNode :type q: TreeNode :rtype: bool &quot;&quot;&quot; if not p and not q: return True if p and q and p.val == q.val: left = self.isSameTree(p.left,q.left) right = self.isSameTree(p.right,q.right) return left and right else: return False 101. 对称二叉树 56 ms 击败了81.40% 的用户 12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; def isSame(left,right): if not left: return right == None if not right: return left == None if left.val == right.val: return isSame(left.left,right.right) and isSame(left.right,right.left) else: return False if not root: return True return isSame(root.left, root.right) 104. 二叉树的最大深度 : 64 ms 击败了79.70% 的用户 123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def maxDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if not root: return 0 left = self.maxDepth(root.left) right = self.maxDepth(root.right) return 1 + max(left,right)","link":"/2018/04/20/Leet%20Code%20OJ%20%E7%AE%80%E5%8D%95%EF%BC%88%E5%9B%9B%EF%BC%89/"},{"title":"MySQL常用命令总结","text":"显示所有数据库：show databases; 新建数据库：create database dbname; 删除数据库：drop database dbname; 切换数据库：use dbname; 新建表：create table tbname(clo1 type ,col2 type,……); 显示所有表：show tables; 根据已有表结构创建新表： create table new_table_name like old_table_name; create table new_table as select col1,col2,…. from old_table only; 显示表结构：describe table_name; 删除表：drop table table_name; 增加一列：alter table tbname add column col type; 删除一列：alter table tbname drop column name; 修改列属性:alter table tbname modify col typr; 增加主键：alter table tbname add primary key (col); 删除主键：alter table tbname drop primary key(col); 修改表名：alter table tbname rename new; 创建索引：create index idxname on tbname (col,….); 删除索引：drop index idxname on tbname; 查看索引：show index from tbname; 创建视图：create view name as select (col,….) from tbname; 删除视图：drop view name; 增删改查： 增：insert into tbname (col,col,…) values(value1,value2,…); 删：delete from tbname where 条件; 改：update tbname set field=value where条件; 查：select filed from tbname where 条件; 求和：select sum(col) as name from tbname; 平均：select avg(col) as name from tbname; 最大：select max(col) as name from tbname; 最小：select min(col) as name from tbname; 外键定义：外键是指引用另一个表中的一列或者多列，被引用的列应该具有主键约束或者唯一约束，外键用于建立和加强两个表数据之间的连接，被引用的表是主表，引用外键的表是从表。 多表操作： 建立外键：alter table tbname add constraint 外键名 froeign key(外键字段名) references 外表表名(主键字段名); 示例：alter table student add constraint fk_id foreign key(gid) references grade(id); 删除外键：alter table tbname drop foreign key 外键名; 示例：alter table student drop foreign key fk_id; 添加数据：当有外键的表添加数据的时候其字段值只能是被关联表中已有的数据，例如grade中id字段只有1和2，那么student中的gid值只能设为1和2. 删除数据：因为grade表和student表具有关联关系，参照列中的被参照值是不能被删除的，所以想删除grade表中的数据必须先将student中关联数据都删除掉后再删除grade中的数据。 连接查询： 首先建立两个表： 表1：create table department (did int not null primary key, dname varchar(32)); 表2：create table employee(id int not null primary key, name varchar(32), age int, did int not null); 插入数据 insert into department(did,dname)VALUES (1,'网络部'),(2,'媒体部'),(3,'研发部'),(5,'人事部'); Insert into employee(id,name,age,did) VALUES (1,'王红',20,1),(2,'李强',22,1),(3,'赵四',20,2),(4,'郝娟',20,4); 交叉连接：交叉连接返回的结果是两个连接表中所有数据的笛卡尔集，即返回第一个表中符合条件的数据乘以第二个表中符合条件的数据。 语句：select 字段 from tbname1 cross join tbname2; 例如：select * from department cross join employee; 返回结果为：有16行（4*4） 内连接：使用比较运算符对两个表中的数据进行比较，并列出与连接条件匹配的数据 语句：select 字段 from tbname1 [inner] join tbname2 on tbname1.关系字段=tbname2.关系字段; 例如 select name from employee join department on employee.did=department.did; 返回结果为：3行（did为1，2，3的数据） 自连接：如果在一个连接查询中涉及的两个表其实是同一个表，这种查询称为自连接查询 语句：select p1.* from tbname as p1 join tbname as p2 on p1.字段 = p2.字段; 示例：查询 name为王红的人所属部门员工 select p1.* from employee as p1 join employee as p2 on p1.did = p2.did where p2.name = ‘王红’; 返回结果为：2行（网络部的两个：王红和李强） 外连接：外连接分为左连接和右连接，当返回的查询结果不仅需要包括符合条件的数据，还需要包含其中的一个表或者两个表的所有数据的时候，需要用到外连接查询 语句：select 字段 from tbname1 left|right [outer] join tbname2; 左连接：left join：返回包括左表中的所有记录和右表中符合条件的记录。 例如：select department.dname,employee.name from department left join employee on department.did = employee.did; 右连接：right join：返回包括右表的所有记录和左表符合条件的记录。 例如：select department.dname,employee.name from department right join employee on department.did = employee.did; 子查询：指一个查询语句嵌套在另一个查询语句内部的查询，在执行的时候会先执行子查询中的语句，然后将返回的结果作为外层查询的过滤条件。需要注意的是第一个条件的判断字段要包含在第二个查询语句的字段中，否则报错。 IN/NOT IN语句：select 字段from tbname where 条件 in /not in (select 字段 where 条件) EXISTS语句：EXISTS关键字后面的参数可以是任何一个子查询，但是不会产生任何数据，只返回TRUE或者FALSE，当返回TRUE的时候外层查询才会执行。 语句：select 字段 from tbname where exists (select 字段 from tbname where 条件) ANY语句：ANY关键字表示只要满足内层子查询中的任意一个条件，就会返回一个结果作为外层查询条件。 语句：select 字段from tbname where 字段 比较符 any(select字段 from tbnamewhere条件) ALL语句：类似于ANY只是他需要满足所有条件 语句：select字段 from tbname where 字段 比较符 all(select 字段 from tbname where条件)","link":"/2018/11/20/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"title":"MySQL必知必会总结（一）","text":"去重MySQL中不能部分使用DISTINCT，DISTINCT关键字会应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT score,age，除非指定的两个列都不同，否则所有行都将被检索出来。 例如如下的表 name score age test1 11 11 test2 11 11 test3 123 123 test4 123 11 1SELECT DISTINCT score ,age FROM `student` 结果： score age 11 11 123 123 123 11 排序 按单个列排序 1SELECT score FROM 'student' ORDER BY score score 11 11 123 123 按多个列排序 会先按照第一列排序，如果第一列存在相同的会根据后面的列继续排列，换句话说就是当第一列所有数据全部不同，那么是不会根据后面的列再次排序的 1SELECT score, age FROM 'student' ORDER BY score, age score age 11 11 11 11 123 11 123 123 指定排序方向 MySQL中默认为升序排序，如果想用降序排序需要指定DESC关键字，和DISTINCT不同的是DESC只会作用于它前面的列，想要每列都已降序排序就必须对每列都指定DESC关键字。 1SELECT score, age FROM 'student' ORDER BY score DESC，age score age 123 11 123 123 11 11 11 11 排序规则 在对文本性的数据排序时，MySQL默认是不区分大小写的，即A和a相同，如果想要区分的话可能需要对数据库的设置做更改 过滤数据 WHERE语句的操作符 操作符 作用 = 等于 &lt;&gt; 不等于 != 不等于 &lt; &lt;= &gt; &gt;= BETWEEN… AND… 在两个指定值之间 匹配操作 MySQL在执行WHERE语句匹配时默认不区分大小写，Abc和abc是一样的 12select name from tbnaem where name='Abc';select name from tbnaem where name='abc'; 空值检查 NULL和0、空字符串是不同的，如果要匹配NULL需要用IS NULL子句实现 1select * from tbname where name IS NULL 组合过滤 AND操作符 会对每个判断条件取与，满足所有条件才会返回 OR操作符 满足任意一个条件即符合要求 同时使用AND和OR操作符 MySQL会优先处理AND操作符，例如 ： 1select name, price from tbname where id = 2 or id = 3 and price&lt;10 上面这个SQL语句会过滤出ID等于2或者ID等于3并且价格小于10的行，这显然和我们的意图不一样（ID等于2或者3，并且价格小于10）。为了解决这个问题，需使用圆括号将操作符分组区分开来，改为下面这种： 1select name, price from tbname where (id = 2 or id = 3) and price&lt;10 因此在使用具有AND和OR操作符的where子句时，应当使用圆括号将操作符分组处理，不要依赖于默认的计算顺序以免出现错误。 IN操作符 IN操作符可以指定条件范围，范围中的每个条件都可以进行匹配，类似于之前的OR操作符 1select name, price from tbname where id in (2,3) 相交于OR操作符，在更多的过滤条件下显得更为简洁直观，会有比OR操作符更好的性能，另外IN操作符可以包含其他的SELECT语句： NOT操作符 NOT操作符只有一个功能，否定它之后所跟的任何条件，例如IN、BETWEEN、EXISTS 1select name from tbname where id not in (2,3) 选取ID不是2,3的行。 通配符过滤（LIKE操作符） 百分号（%）通配符 %可以表示任何字符串出现任何次数，例如找到name是以fml开头的行 1select name from tbname where name LIKE 'fml%' 或者包含abc的行 1select name from tbname where name LIKE '%abc%' 或者以a开头c结尾的行 1select name from tbname where name LIKE 'a%c' %看似可以匹配任何东西，但是NULL是例外的， LIKE ‘’%‘’无法匹配值为NULL的行，另外值得注意的是尾空格可能也会干扰通配符的匹配 下划线（_）通配符 _只能匹配单个字符其他的和%一样 技巧 不要过度使用通配符，如果其他操作符能够实现同样的目的那么就使用其他操作符。 除非是必要的，否则不要将通配符放在开始处，那样是最慢的 使用正则表达式 使用正则表达式匹配的时候需要使用REGEXP关键字来代替LIKE，REGEXP后所跟的字符串就是正则表达式了。正则表达式怎么写就不在这说了","link":"/2019/12/20/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"MySQL必知必会总结（二）","text":"计算字段一般数据库中存储的数据可能不会是我们所需要的格式，例如存储一个地址，在数据库中可能会将城市、区和街道分别存入不同的列中，但是我们可能需要直接获取一个完整的地址，这时候就需要做一些转换操作了，可以直接取出每个字段的值，然后在我们自己的程序中组合，同样也可以使用SQL直接在数据库中完成，而且一般来说在数据库中完成这些操作要率相对于我们自己去实现要快，下面就是一些常用的计算方法。 表： name category number price 硬盘 电子类 10 399 乐事薯片 食品类 24 7.5 PS4 电子类 1 2799 流畅的Python 书籍类 5 105 拼接字段 在select语句中可以使用Concat()函数实现两列的拼接操作： 1select concat(name,'(',category,')') as goods from goods goods 硬盘(电子类) 乐事薯片(食品类) PS4(电子类) 流畅的Python(书籍类) 其他：RTrim()函数去除右边所有空格，LTrim()去除左边所有空格， as：使用别名 执行算术计算 依然使用上面那个表，如果我们需要取出所有商品的总金额，我们可以取出每行的价格和数量自己计算，同样也可是使用MySQL计算完成之后直接返回总金额。 1select name, number*price as total_price from goods name total_price 硬盘 3990 乐事薯片 180 PS4 2799 流畅的Python 525 MySQL支持的运算符有 +、 -、 *、 / ，可以使用()来区分计算顺序。 函数 文本处理函数 函 数 说 明 Left(str,length) 返回串左边的字符 Length(str) 返回串的长度(字节长度 )， UTF-8编码中文三个字节，英文一个字节 Locate(substr,str,pos) 返回子串 substr 在字符串 str 第 pos 位置后中第一次出现的位置。如果子串 substr 在 str 中不存在，返回值为 0 （pos可选） Lower(str) 将串转换为小写 LTrim(str) 去掉串左边的空格 Righ(str,length) 返回串右边的字符 RTrim(str) 去掉串右边的空格 Soundex() 返回串的SOUNDEX值（不常用）SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法 SubString(str, pos, len) 返回字符串第pos位置后的len长度的子串 第一个字符pos为1，len可选，默认到最后一位 Upper() 将串转换为大写 日期和时间处理函数 AddDate() 作用 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 数值处理函数 函数 说明 Abs() 返回一个数的绝对值 Cos() 返回一个角度的余弦 Exp() 返回一个数的指数值 Mod() 返回除操作的余数 Pi() 返回圆周率 Rand() 返回一个随机数 Sin() 返回一个角度的正弦 Sqrt() 返回一个数的平方根 Tan() 返回一个角度的正切 聚集函数 默认参数为ALL，可使用DISTINCT关键字 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数（指定列名会忽略NULL行） MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 数据的分组 name category number price 硬盘 电子类 10 399 乐事薯片 食品类 24 7.5 PS4 电子类 1 2799 流畅的Python 书籍类 5 105 GROUP BY 按照category分组，并计算每组的数量 1select category , count(*)as num from goods group by category category num 书籍类 1 电子类 2 食品类 1 GROUP BY子句可以包含任意数目的列 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前 HAVING（过滤分组） HAVING类似于WHERE，所有的WHERE子句都可以使用HAVING来代替，两者唯一的差别是WHERE过滤行而HAVING过滤分组，换一句话说，WHERE在数据分组之前过滤，HAVING在分组之后过滤，WHERE排除的行不包含在分组之中。 选取种类大于等于两个的分组 1select category, count(*) as num from goods group by category HAVING count(*) &gt;= 2 category num 电子类 2 分组排序 使用GROUP BY分组得到的数据顺序可能不是统一的，如果想实现分组排序还需要用到ORDER BY对分组结果进行排序 例如按照category分组，并按照数目从小到大排序 1select category ,count(*) num from goods group by category order by count(*) category num 食品类 1 书籍类 1 电子类 2 总结一下 在SELECT语句中，所有子句的顺序如下 SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY","link":"/2019/12/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Postgresql的全文检索功能","text":"之前做过一个jieba+whoosh的商品搜索功能，后来发现Postgresql数据库自带有全文检索的功能，那么就尝试使用Postgresql的全文检索功能来实现一次 postgresql配置 环境：Ubuntu16.04 版本：v9.5 外部远程访问：数据库配置文件路径为 /etc/postgresql/9.5/main需要修改的配置文件为postgresql.conf和pg_hba.conf postgresql.conf（这个文件是数据库的配置文件）#listen_addresses='localhost' 修改为 listen_addresses='*' pg_hba.conf（这个文件是数据库的连接配置文件）在最后添加一行：host all all 0.0.0.0/0 md5（意思就是允许任何用户从任何IP访问任何数据库，加密方式为MD5） 重启服务：sudo service postgresql restart 插件路径：/usr/share/postgresql/9.5/extension zhparser插件的安装 postgresql的本身分词并不支持中文，所以需要使用其他的插件实现中文分词的功能，在这里采用的是zhparser+scws，具体的介绍可以看github主页。 下载zhparser源码：1git clone https://github.com/amutu/zhparser.git 安装SCWS：12345wget http://www.xunsearch.com/scws/down/scws-1.2.3.tar.bz2tar xvjf scws-1.2.3.tar.bz2cd scws-1.2.3./configuremake install 安装zhparser：12345cd zhparsermake &amp;&amp; make install# 如果安装报错请先安装相关的库和头文件# sudo apt-get install postgresql-server-dev-9.5# sudo apt-get install postgresql-common 配置zhparser扩展：1234567# 连接至目标数据库后CREATE EXTENSION zhparser;# 这里如果报错：ERROR: could not open file &quot;/usr/share/postgresql/9.5/tsearch_data/qc_dict_demo_1.txt&quot; for writing: Permission denied# 在那个目录下没有找到这个文件,最后手动创建了那个文件# 将zhparser解析器作为全文检索配置项CREATE TEXT SEARCH CONFIGURATION chinese (PARSER = zhparser);ALTER TEXT SEARCH CONFIGURATION chinese ADD MAPPING FOR n,v,a,i,e,l,j WITH simple; 安装完成后使用\\dFp查看是否安装成功。 简单的使用 1SELECT * FROM table WHERE to_tsvector('chinese', name) @@ to_tsquery('chinese', '小米Pro'); 插件装好后好像并不需要我们编写代码了，一个简单的SQL语句就实现了之前的功能。那么如果你使用的是Postgresql数据库推荐使用自带的全文检索功能去实现。","link":"/2021/04/20/Postgresql%E7%9A%84%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%8A%9F%E8%83%BD/"},{"title":"PyQt5之SQLite数据库操作（1）","text":"连接数据库 导入库文件 from PyQt5 import QtSql from PyQt5.QtSql import QSqlQuery QtSql类即QT中的QSqlDatabase类，用于处理与数据库的连接 QSqlQuery类提供了执行和操作SQL语句打方法 第一步连接sqlite数据库 database = QtSql.QSqlDatabase.addDatabase('QSQLITE') database.setDatabaseName('test.db') 没有test.db这个文件的时候则会在当前目录新建一个test.db文件 打开数据库，打开成功返回True database.open() 新建表 建立一个名为student的表，包含id,name,age三个属性，其中ID为主键 query.prepare('create table student (id int primary key, name varchar(30),age int)') if not query.exec_(): query.lastError() else: print('create a table') 插入数据 addBindValue()将值添加到列表中，调用顺序决定添加的顺序 insert_sql = 'insert into student values (?,?,?)' query.prepare(insert_sql) query.addBindValue(4) query.addBindValue('test3') query.addBindValue(1) if not query.exec_(): print(query.lastError()) else: print('inserted') 查询 查询返回数据使用value(int)函数，例如select id,name,age from student&nbsp; &nbsp;value(0)等于返回id属性的值，value(2)等于age属性 exec_()查询成功返回true查询 否则返回false query.prepare('select id,name,age from student') if not query.exec_(): query.lastError() else: while query.next(): id = query.value(0) name = query.value(1) age = query.value(2) print(id,name,age) 可以通过record().indexOf(str)来获取索引值， if query.exec('select id ,name,age from student'): id_index = query.record().indexOf('id') name_index = query.record().indexOf('name') age_index = query.record().indexOf('age') while query.next(): id = query.value(id_index) name = query.value(name_index) age = query.value(age_index) print(id, name, age) 一：使用exec()操作 指令执行成功则&nbsp;exec_()会返回True并把查询状态设为活跃状态，否则返回false 另外对于SQLite，查询字符串一次只能包含一条语句。如果给出多个语句，则函数返回false if query.exec('select id ,name,age from student'): while query.next(): id = query.value(0) name = query.value(1) age = query.value(2) print(id, name, age) 二：execBatch()操作 这个函数是批处理之前准备好的指令，如果数据库不支持批处理他会自己调用exec()来模拟 query.prepare('insert into student values (?,?,?)') query.addBindValue([6,7,8]) query.addBindValue(['test5','test6','test7']) query.addBindValue([1,1,1]) if query.execBatch(): print(&quot;inserted &quot;) 三：executedQuery()返回最后一个执行成功的指令 if query.exec('select id ,name,age from student'): while query.next(): id = query.value(0) name = query.value(1) age = query.value(2) print(id, name, age) print(query.executedQuery())执行结果为：select id ,name,age from student 四：&nbsp;其他 finish()终止当前的操作 isActive()返回当前是否处于活跃状态 isNull(int&nbsp;field)返回当前是否不活跃 isSelect()返回是不是一个查询语句 next()检索结果中的下一条记录（如果可用），并将查询放在检索到的记录上。请注意，结果必须处于活动状态，并且在调用此函数之前，isSelect（）必须返回true，否则它将不执行任何操作并返回false。 指令执行成功则&nbsp;exec_()会返回True并把查询状态设为活跃状态，否则返回false","link":"/2017/11/20/PyQt5%E4%B9%8BSQLite%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%881%EF%BC%89/"},{"title":"PyQt5无边框后窗口的移动方法","text":"由于隐藏了标题栏无法通过点击标题栏来实现窗口的移动，这时候我们可以通过鼠标事件来移动窗口 第一步：判断鼠标左键是否被按下，如果按下则将flag设为True并获取当前的位置 第二步：判断鼠标是否移动并且左键被按下，若移动了计算移动的距离在移动窗口 第三步：若鼠标释放了则将flag设为False 具体做法：重写窗口类自带的三个函数 def mousePressEvent(self, event): if event.button()==Qt.LeftButton: self.m_flag=True self.m_Position=event.globalPos()-self.pos() #获取鼠标相对窗口的位置 event.accept() self.setCursor(QCursor(Qt.OpenHandCursor)) #更改鼠标图标 def mouseMoveEvent(self, QMouseEvent): if Qt.LeftButton and self.m_flag: self.move(QMouseEvent.globalPos()-self.m_Position)#更改窗口位置 QMouseEvent.accept() def mouseReleaseEvent(self, QMouseEvent): self.m_flag=False self.setCursor(QCursor(Qt.ArrowCursor))&lt;/pre&gt;&lt;br&gt; 最后最小化和关闭可以设置两个按钮，通过点击按钮来触发 @pyqtSlot() def on_pushButton_clicked(self): &quot;&quot;&quot; 关闭窗口 &quot;&quot;&quot; self.close() @pyqtSlot() def on_pushButton_2_clicked(self): &amp;quot;&amp;quot;&amp;quot; 最小化窗口 &amp;quot;&amp;quot;&amp;quot; self.showMinimized()&lt;/pre&gt;&lt;/p&gt; ps :设置无边框和背景透明 # 设置窗体无边框 # self.setWindowFlags(Qt.FramelessWindowHint) # 设置背景透明 # self.setAttribute(Qt.WA_TranslucentBackground) 效果图 win10自带的录屏只能录当前软件那个区域。。。。。。。 就这样吧","link":"/2017/11/20/PyQt5%E6%97%A0%E8%BE%B9%E6%A1%86%E5%90%8E%E7%AA%97%E5%8F%A3%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%96%B9%E6%B3%95/"},{"title":"PyQt5显示GIF图片","text":"使用QMoive方法实现 导入库文件 from PyQt5 import QtCore, QtGui, QtWidgets from PyQt5.QtGui import QMovie 创建一个带label控件的窗口，label作为GIF的显示窗体 class Ui_Form(object): def setupUi(self, Form): Form.setObjectName(\"Form\") Form.resize(517, 361) self.label = QtWidgets.QLabel(Form) self.label.setGeometry(QtCore.QRect(0, 0, 500, 300)) self.label.setObjectName(\"label\") self.retranslateUi(Form) QtCore.QMetaObject.connectSlotsByName(Form) def retranslateUi(self, Form): _translate = QtCore.QCoreApplication.translate Form.setWindowTitle(_translate(\"Form\", \"Form\")) 在setupUi()函数里面加入 self.gif = QMovie('qq.gif') self.label.setMovie(self.gif) self.gif.start() 第一行 实例化一个QMovie对象，传入GIF图片地址 第二行 使用label的setMovie方法导入QMovie对象 第三行 开始播放GIF动画 效果图： PyQt的一些其他功能 #设置窗体无边框 self.setWindowFlags(Qt.FramelessWindowHint) # 设置背景透明 # self.setAttribute(Qt.WA_TranslucentBackground) # 显示输入对话框 # 字符串类型，标题、提示信息、默认输入 # text,ok=QInputDialog.getText(self, \"title\", \"User name:\", QLineEdit.Normal, '&gt;&gt;&gt;:') # 整型类型 标题、提示信息、默认值，（最小值，最大值）可选 # num,ok = QInputDialog.getInt(self,\"输入整数\",'输入0-100范围内的数字',30,0,100) # 下拉框 # my_list = ['1','2','3'] # my_str,ok = QInputDialog.getItem(self,\"下拉框\",'提示',my_list)","link":"/2017/11/20/PyQt5%E6%98%BE%E7%A4%BAGIF%E5%9B%BE%E7%89%87/"},{"title":"Python---RabbitMQ的使用","text":"安装 RabbitMQ是使用Erlang开发的，因此我们需要首先安装Erlang。http://www.erlang.org/downloads下载对应的版本，安装完成后即可进入下一步。 下载RabbitMQ&nbsp;http://www.rabbitmq.com/download.html&nbsp;选择默认安装即可，安装完成后可在开始菜单中找到 点击 RabbitMQ Service - start就开始运行了 使用Python进行操作 这里我们需要用到pika这个模块来实现，安装好之后我们就可以实现最简单的例子了 第一个程序Hello world 下面两个例子都来自于官方示例 消息传递模型 send.py import pika connection = pika.BlockingConnection(pika.ConnectionParameters(host=’localhost’))channel = connection.channel() channel.queue_declare(queue=’hello’) channel.basic_publish(exchange=’’, routing_key=’hello’, body=’Hello World!’)print(&quot; [x] Sent ‘Hello World!’&quot;)connection.close()receive.py import pika connection = pika.BlockingConnection(pika.ConnectionParameters(host=’localhost’))channel = connection.channel() channel.queue_declare(queue=’hello’) def callback(ch, method, properties, body): print(&quot; [x] Received %r&quot; % body) channel.basic_consume(callback, queue=’hello’, no_ack=True) print(‘ [*] Waiting for messages. To exit press CTRL&amp;#43;C’)channel.start_consuming()依次运行这两个函数结果如下 下面我们再来具体看一看每条语句的具体作用 connection = pika.BlockingConnection（pika.ConnectionParameters（'localhost'）） channel = connection.channel（） 第一句是建立连接的，rabbitmq支持本地连接也支持连接到其他机器上，在这里我们选择本地连接。 第二句是创建一个新的管道，之后的所有操作都是在这个管道上进行的。 channel.queue_declare(queue='hello') 声明一个队列名为hello，如果你确认这个队列存在那么不声明也是可以的，但是最好声明一下以免造成其他的麻烦。 channel.basic_publish(exchange='', routing_key='hello', body='Hello World!') 向队列中发送一条消息，其中routing_key指定队列名，body为消息内容 connection.close() 关闭连接 receive.py中前面几句和send中的作用是一样的，这里不再赘述。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def callback(ch, method, properties, body): print(&quot; [x] Received %r&quot; % body) callback是回调函数，当程序从队列中获取消息后都会执行回调函数来处理消息&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; channel.basic_consume(callback, queue='hello', #no_ack=True ) 从队列中获取消息，callback指定回调函数，queue指定获取的队列名，no_ack在以后再说明&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; channel.start_consuming() 让程序进入到一个死循环中，不断从队列中取出消息 消息队列的循环调度 消息传递模型 当我们启动多个程序从同一个队列中接收消息的时候，默认是依次接收，即第一个启动的程序首先接收到然后是第二个启动的程序,直到最后一个程序收到之后又从第一个开始，但是这样会造成一个后果就是，可能每个程序或者机器的处理速度不同，造成有的在等待有的消息过多。如下图启动两个接收程序，并发送从0-4数字，两个程序接收的消息依次为： 消息确认 在实际应用中一般程序接收消息后处理需要时间，如果在处理的过程中程序崩溃了那么那个消息就会从消息队列中消失了，这当然不是我们想要的结果，我们需要在程序崩溃之后将那条消息转发到另一个程序中执行，这时候我们需要设置只有在消息被确认后才将消息从队列中删除，RabbitMQ默认消息确认是打开的，但是我们可以添加参数no_ack = True来取消，这样即使消息为处理完成也不会再次发送了，会直接从队列中去除。我们还可以使用手动消息确认即在callback中添加一句： ch.basic_ack（delivery_tag = method.delivery_tag） 消息持久化 上面我们已经说了如何保证消费者崩溃时还保留消息，现在我们将介绍如何在RabbitMQ服务终止后还会保留消息队列。这里需要我们在声明这个队列的时候添加一个参数来实现 channel.queue_declare（queue = 'hello'，durable = True） 但是这只是保证了hello队列的持久化（下次重启服务的时候队列依然存在），但是队列中消息内容依然是不会被保留下来的，我们想要同时将消息保留下来还需要在channel.basic_publish()函数中添加下面这个参数 properties=pika.BasicProperties(delivery_mode = 2) 需要注意的是消息内用只会暂存于缓存中，并未正真写入磁盘中永久保留，还有就是要实现消息持久化的前提是当前队列也是持久化的（不会报错，但是消息并没有被保留下来） 公平派遣 实际应用场景中，有些程序或者是机器处理消息的能力强一些，有些会弱一些，那么按照上面的操作所有的消息都是循环分发的这样就会导致有些机器空闲而有些会出现消息过多处理不过来的情况，为了解决这个问题我们可以在消费者中设置最多可容纳多少条消息，当消息数目满了之后就不会再接收新的消息，直到消息被处理完了留有空余才会再次接收消息。 channel.basic_qos（prefetch_count = 1） 需要注意的是prefetch_count参数值并未实际意义，只要为True即可，也就是设置后消费者每次只能接收一个消息与参数值无关。 广播模式 消息传递模型 上面所有的都是一对一的消息传递，下面将说一说一对多的传递模型，即广播模式，就好比收音机收听广播一样，需要一个发布者，其他的都是订阅者，发布者发布消息只要订阅者订阅了这个频道那么所有的订阅者都能收到消息。这里的消息传递模型就与之前的略有不同。消息并不是直接发送到队列中，而是经过一个交易所来分发到不同的队列中如上图所示。那么有人会问了，交易所是如何知道要分发到哪一个队列呢，其实只需要将队列和交易所绑定在一起就可以了，每一次消息过来的时候交易所会将消息转发到所有和他绑定的队列中。 channel.exchange_declare(exchange='logs', exchange_type='fanout') message = &quot;info: Hello World!&quot;channel.basic_publish(exchange=’logs’, routing_key=’’, body=message) 其中exchange_type类型有direct、topic、headers、fanout这四种，下面主要说明fanout类型。上面这段程序指定了一个名为logs的交易所，类型为fanout，下面向这个exchange里面publish一条message消息，routing_key为空表示使用默认操作或称为无名交换。完成了发送程序，下面再来说说接收程序。 channel.exchange_declare(exchange='logs', exchange_type='fanout') result = channel.queue_declare(exclusive=True)queue_name = result.method.queue channel.queue_bind(exchange=’logs’, queue=queue_name) 在第四行代码中声明了一个随机名称的队列，exclusive=True将会让程序在消费者断开连接的时候删除这个队列&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在第七行代码中我们将生成的随机队列和我们之前的交换所绑定在一起，这样当一个消息过来的时候交易所会将消息分发到我们绑定过的队列中 路由 如上图所示","link":"/2018/04/28/Python---RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Python3面向对象编程总结","text":"自学笔记：逻辑可能比较混乱，想到哪说到哪，可能存在不少的问题欢迎指出。 创建一个类： 最简单的一个类 在python中类的命名必须以字母或者下画线开头，并且只能包含字母、下画线和数字。另外推荐使用驼峰命名方式（大写字母开头，随后的任意一个单词都以大写字母开头） python最简单的一个类的创建 class MyFirstClass: pass 类的属性和方法 在类中我们还可以为其添加属性和方法 class MyFirstClass: def __init__(self): self.x = 1 self.y = 1 def show(self): print(self.x,self.y) c = MyFirstClass()c.show() 其中self.x和self.y为该类的属性，show()为该类的方法 类中的方法的定义方式和普通函数相同，都是以关键字def开头，但是有一点不同的是类中的方法有一个必需的参数，通常这个参数被命名为self,但是我们实例化类后调用show方法的时候并没有传入参数，这是因为python自动帮我们做了，当我们调用c对象的show方法的时候，python会自动将c对象传给show方法了。因此下面这个调用方式运行结果是一样的。 c = MyFirstClass() MyFirstClass.show(c)其实类中的方法本质上就是一个函数，我们可以在外部调用也可以在类中调用，例如： class Point: def __init__(self, x ,y ): self.x = x self.y = y def reset(self): self.x = 0 self.y = 0 self.show() def show(self): print(self.x, self.y) p = Point(1,1)p.reset() 运行结果为：0&nbsp; 0 类的初始化 一般的编程语言中都有一个叫构造函数的特殊方法，当它被创建的时候会创建和初始化对象，这一点Python会有些许不同，python有一个构造函数和一个初始化函数，一般情况下构造函数很少被用到，除非是想实现一些特别的操作，所以在此主要说一下类的初始化。我们在之前的示例中有一个方法名为__init__(),其实这个方法就是给类进行初始化操作的。当我们实例化的时候会首先执行__init__()方法，因此当__init__()方法需要传递参数的时候我们在实例化的时候同样需要传递参数，不然会报错。 由于方法本质上就是函数，当我们不想传递参数的时候也可以同函数的操作一样使用默认参数。 def __init__(self, x=0, y=0): self.x = x self.y = y 面向对象三个基本特征 面向对象编程的三个基本特征分别为：封装、继承、多态，下面一一说明。 继承 继承就是让一个类获得另一个类的属性和方法，在Python中所有的类都是object类的子类，只是在实际的使用中我们并不需要表明，python在后台自己帮我们做了","link":"/2018/04/28/Python3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"title":"Python基础---协程","text":"协程是一种用户态的轻量级线程，本质上是单线程 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。 因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。&nbsp;&nbsp; 使用greenlet实现协程操作，greenlet需要手动进行切换 首先需要使用greenlet创建类似与堆栈空间，然后使用switch进行切换 from greenlet import greenlet def test1(): print(12) gr2.switch() print(34) gr2.switch() def test2(): print(56) gr1.switch() print(78) gr1 = greenlet(test1)gr2 = greenlet(test2) gr1.switch() 使用Gevent实现协程，无需手动切换，遇到IO操作就会进行切换 import gevent def func1(num):&amp;nbsp; &amp;nbsp; print(‘in func1’,num)&amp;nbsp; &amp;nbsp; gevent.sleep(1) #模仿IO操作&amp;nbsp; &amp;nbsp; print(‘back func1’) def func2():&amp;nbsp; &amp;nbsp; print(‘in func2’)&amp;nbsp; &amp;nbsp; gevent.sleep(2) #模仿IO操作&amp;nbsp; &amp;nbsp; print(‘back func2’) def func3():&amp;nbsp; &amp;nbsp; print(‘in func3’)&amp;nbsp; &amp;nbsp; gevent.sleep(3)&amp;nbsp; &amp;nbsp; print(‘back func3’) gevent.joinall([&amp;nbsp; &amp;nbsp; gevent.spawn(func1,1),&amp;nbsp; #传参的方式&amp;nbsp; &amp;nbsp; gevent.spawn(func3),&amp;nbsp; &amp;nbsp; gevent.spawn(func2),]) 先执行func1，打印第一句后遇到IO操作切换到func3又遇到IO，再次切换到func2，遇到IO操作后由于没有可执行的函数，开始等待，func1最先可执行自动跳转到func1打印第二句，然后func2IO操作结束输出func2的第二句，最后func3才结束IO操作，所有func3的第二句最后打印 事件驱动模式：每次有一个事件发生的时候会首先存入到一个消息队列中，然后会有专门的函数循环不断的从队列中取出事件进行处理，执行完一个事件后一般会执行一个回调函数来告知当前事件处理完毕。 异步操作也算是一种事件驱动的模式，遇到IO操作的时候交个操作系统来执行，IO操作结束后会执行一个回调函数告知程序IO结束可继续执行","link":"/2018/03/07/Python%E5%9F%BA%E7%A1%80---%E5%8D%8F%E7%A8%8B/"},{"title":"Python基础---线程","text":"调用方式 python的线程调用有两种方式。一种是直接调用，一种是继承式调用 直接调用 import threading,time #方法一def run(n): print(n) time.sleep(2) t1 = threading.Thread(target=run,args=(&quot;t1&quot;,))t2 = threading.Thread(target=run,args=(&quot;t2&quot;,))t1.start()t2.start()使用类的方法调用 #方法二（使用类的方法） import threading,time class MyThread(threading.Thread): def __init__(self,n): super(MyThread,self).__init__() self.n = n def run(self): #函数名必须为run print(self.n) time.sleep(2) t1 = MyThread(1) t2 = MyThread(2) t1.start() t2.start() join和Daemon join()等待线程结束后再往后继续运行 Daemon()守护线程 使用setDaemon(True)那么主线程不会等待子线程结束才结束，主线程结束后子线程也会直接结束，必须要在start之前设置否则会报错 python中默认为setDaemon(False),主线程结束了子线程依然会执行直到完毕。 join例子： import threading,time class MyThread(threading.Thread): def __init__(self,n): super(MyThread,self).__init__() self.n = n def run(self): #函数名必须为run print(self.n) time.sleep(2) print('end') t1 = MyThread(‘t1’)t2 = MyThread(‘t2’)t1.start()t1.join()t2.start()t2.join()结果 setDaemon()例子 import threading,time class MyThread(threading.Thread): def __init__(self,n): super(MyThread,self).__init__() self.n = n def run(self): #函数名必须为run print(self.n) time.sleep(2) print('end') t1 = MyThread(‘t1’)t2 = MyThread(‘t2’)t1.setDaemon(True)t2.setDaemon(True)t1.start()t2.start() 结果 线程锁 子线程可以共享父线程的内存空间，当存在多个子线程需要同时修改一个数据的时候就可能出现问题 假设两个子线程执行的操作都是num+1，由于线程是同时执行的，第一个子线程先取num = 1 ，第二个线程有取出num依然为1，线程一结束后num更改为2，随之线程二结束num依然被改为2，就与我们的目标出现冲突，这个时候就需要用到线程锁了，当线程一访问num的时候线程二是无法访问num的，线程一结束后释放num线程二才能访问num，这就使得num的结果不会产生冲突了。 #线程锁示例 import threading num = 0t_objs = []lock = threading.Lock() def run(): lock.acquire() #加锁 global num #声明全局变量 num &amp;#43;= 1 #执行加一操作 lock.release() #释放锁 for i in range(500): t = threading.Thread(target=run) t.start() t_objs.append(t) for t in t_objs: #等待所有线程结束 t.join() print(num)递归锁则是在一个锁里面又嵌套另外一个线程锁 #递归锁 import threading def run1(): lock.acquire() global num num &amp;#43;= 1 lock.release() return num def run2(): lock.acquire() global num2 num2 &amp;#43;= 1 lock.release() return num2 def run3(): lock.acquire() res = run1() res2 = run2() lock.release() print(res, res2) if name == ‘main‘: num, num2 = 0, 0 lock = threading.RLock() for i in range(10): t = threading.Thread(target=run3) t.start()&lt;/pre&gt; 结果 信号量（Semaphore） 线程锁每次只允许一个线程操作数据，Semaphore则可同时允许多个线程操作，当达到允许的最大值的时候后面的则需要等待，前面的线程执行完毕后才可执行，因此操作同一个数据的时候依然有可能出错 #信号量 import threading,time def run(num): semaphore.acquire() time.sleep(1) print(num) semaphore.release() semaphore = threading.BoundedSemaphore(3) #最多运行三个线程for i in range(10): t = threading.Thread(target=run,args=(i,)) t.start() 事件（Event） Event默认内置了一个标志，初始值为False event总共就四中方法：set()、clear()、wait()、is_set() set()设置标志位为True clear()设置标志位为False wait()等待标志位设为True is_set()判断标志位是否被设为True 已红绿灯为例说明，首先写出交通灯，event.clear()相当于红灯，event.set()相当于绿灯,红灯为5秒绿灯也为5秒，用count来计数，当count超过10的时候重置count，这样红绿灯就能以5秒为间隔循环运行 import time,threading event = threading.Event() def light(): count = 0 while True: if count &gt;= 5 and count &lt; 10: event.clear() #相当于红灯了 print(&quot;red light please wait…&quot;) elif count &gt; 10 : event.set() #相当于绿灯 count = 0 else: print(&quot;go go go …&quot;) time.sleep(1) count &amp;#43;= 1再来写car def car(): while True: if event.is_set(): #判断event是否被set，相当于检测是否为绿灯 print('run...') time.sleep(1) else: print('waiting for green light..') event.wait() print('green light is on go...') 运行 l = threading.Thread(target=light) c = threading.Thread(target=car) l.start() c.start() 最终的结果","link":"/2018/03/07/Python%E5%9F%BA%E7%A1%80---%E7%BA%BF%E7%A8%8B/"},{"title":"Python基础---进程","text":"python的多线程和多进程都是调用系统的原生线程和进程，多进程和多线程在使用上类似，同样有直接调用和继承调用两种，在进程中还可以创建其他的线程 可通过os模块中的getpid()获取自己的进程ID，getppid()获取父进程的ID import multiprocessing,time,os class MyProcessing(multiprocessing.Process): def __init__(self): super(MyProcessing,self).__init__() def run(self): print(os.getpid(),os.getppid()) p1 = MyProcessing()p2 = MyProcessing()p1.start()p2.start() print(os.getpid()) 进程间通信 1：Queue（） 不同进程中的内存空间是独立的，不同与线程无法直接访问，要想进程间互相通信需要用到进程Queue（multiprocessing.Queue()）不同与线程Queue（queue.Queue()），在使用进程Queue的时候父进程创建子进程的时候会复制一个队列到子进程内存空间里面，当子进程修改队列的时候，进程Queue会序列化到一个中间地方，然后再反序列化到父进程中，但是并不是直接访问的，这样就实现了父进程与子进程的数据访问 import multiprocessing,time,os class MyProcessing(multiprocessing.Process): def __init__(self): super(MyProcessing,self).__init__() def run(self): q.put(1) q = multiprocessing.Queue() p1 = MyProcessing() p1.start() print(q.get()) 2：Pipe() 一个管道生成的时候会返回两个端口，一个可作为父进程访问端口，一个为子进程访问端口，若无数据可接收的时候会阻塞 import multiprocessing class MyProcessing(multiprocessing.Process): def __init__(self): super(MyProcessing,self).__init__() def run(self): child_conn.send('f') parent_conn, child_conn= multiprocessing.Pipe() p1 = MyProcessing()p2 = MyProcessing()p1.start()p2.start() print(parent_conn.recv())print(parent_conn.recv()) 3：Manage() Manage()支持list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value , Array. 在使用Manage的时候必须要使用join等待子进程完成后继续运行，但是不知道是什么原因，猜测可能是防止多个进程修改数据导致混乱 from multiprocessing import Manager,Process def run (l,num): l.append(num) l = Manager().list() #创建一个可以在进程中传递的空列表p_list = []for i in range(10): p = Process(target=run, args=(l, i)) p.start() p_list.append(p) for res in p_list: res.join() print(l) 进程锁和线程锁类似不在赘述 进程池Pool() 线程池中有两个方法： 1：apple()&nbsp; #串行方式 2：apple_async() #并行方式，使用并行方式的时候必须先close再join import os,time from multiprocessing import Pool def run(num): time.sleep(2) print(num,os.getpid()) pool = Pool(5)for i in range(5): #pool.apply(func=run,args=(i,)) pool.apply_async(func=run,args=(i,))print(‘end’)pool.close()pool.join() #进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。","link":"/2018/03/07/Python%E5%9F%BA%E7%A1%80---%E8%BF%9B%E7%A8%8B/"},{"title":"Python基础---队列","text":"队列Queue包含三个类&nbsp; 1：Queue(maxsize=0)&nbsp; 普通模式先进先出 2：LifoQueue(maxsize=0)&nbsp; 后进先出 3：PriorityQueue(maxsize=0)&nbsp; 优先级模式 Queue.qsize()&nbsp;返回当前队列里存在的个数 Queue.empty()&nbsp;返回队列是否为空 Queue.full()&nbsp;返回队列是否存满 Queue.put(item, block=True, timeout=None) 将item放入队列中。 如果可选的参数block为True且timeout为空对象（默认的情况，阻塞调用，无超时）。 如果timeout是个正整数，阻塞调用进程最多timeout秒，如果一直无空空间可用，抛出Full异常（带超时的阻塞调用）。 如果block为False，如果有空闲空间可用将数据放入队列，否则立即抛出Full异常 Queue.put_nowait()无阻塞版本,等同于block=False，timeout=None Queue.get(block=True, timeout=None)&nbsp;取出数据，其他与put类似 Queue()示例 import queue q = queue.Queue() #普通的（先进先出 q.put(1)q.put(2)q.put(3) print(q.qsize()) #获取当前存在的个数 print(q.get()) #取出 当超过的时候会报错print(q.get())print(q.get())结果： 1 2 3&nbsp; LifoQueue()示例 import queue q = queue.LifoQueue() #普通的（先进先出 q.put(1)q.put(2)q.put(3) print(q.qsize()) #获取当前存在的个数 print(q.get()) #取出 当超过的时候会报错print(q.get())print(q.get()) 结果： 3&nbsp; 2 1&nbsp; PriorityQueue()示例&nbsp;&nbsp; 按照一定的规律确定优先级，例如数字越小优先级越高，或者按字符排序，值得注意的是只能采用一种模式来确定，全为数字或是全为字符，两者不能混在一起，不然会报错。 import queue q = queue.PriorityQueue() #普通的（先进先出 q.put((2,’b’))q.put((1,’a’))q.put((3,’c’)) print(q.qsize()) #获取当前存在的个数 print(q.get()) #取出 当超过的时候会报错print(q.get())print(q.get())结果： (1, 'a') (2, 'b') (3, 'c') 简单的生产者和消费者模型 import queue,threading,time q = queue.Queue() def Producer(): count = 0 while True: q.put(‘Switch %s’ %count) print(‘Switch %s’ %count) count &amp;#43;= 1 time.sleep(1) def Consumer(): while True: if q.qsize() &gt; 0 : print(‘buy %s’%q.get()) time.sleep(2) p = threading.Thread(target=Producer)c = threading.Thread(target=Consumer) p.start()c.start()结果： 生成了Switch 0 购买了 Switch 0 生成了Switch 1 购买了 Switch 1 生成了Switch 2 生成了Switch 3 购买了 Switch 2 生成了Switch 4 生成了Switch 5 生成了Switch 6 购买了 Switch 3 生成了Switch 7 购买了 Switch 4 生成了Switch 8","link":"/2018/03/07/Python%E5%9F%BA%E7%A1%80---%E9%98%9F%E5%88%97/"},{"title":"__repr__和__str__的区别","text":"__repr__和__str__都是python中的特殊方法，都是用来输出实例对象的，如果没有定义这两个方法在打印的时候只会输出实例所在的内存地址,如图： 这种方式的输出没有可读性，并不能直观的体现实例。python提供了__repr__和__str__这两种方法来改进，如下： 在第二个例子中第一次直接输出实例并没有返回str,只改变了print的输出，由此可见__repr__改变的是所有的输出，而__str__改变的是print输出，所以当我们没有重构__str__只重构了__repr__同样是可以使用print来输出的 这个例子里面同时包含了repr和str,print还是默认调用str，实例是调用repr借用他人的一句话 __repr__: 适用于开发人员，__str__:适用于客户。另外__repr__是明确无误的 __str__ 是可读的但是不一定准确。","link":"/2018/08/16/Python%E5%9F%BA%E7%A1%80%EF%BC%9A__repr__%E5%92%8C__str__%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"Python多线程使用浅析","text":"由于GIL(全局解释器锁)的存在，导致Python无法利用到多核CPU的优势，并行处理能力也是稍显不足，下面将从GIL开始说说什么是资源竞争，以及Python多线程的创建、锁、线程间通信等问题。 在python中谈到多线程问题就绕不开一个点GIL，一个是资源竞争 GIL全称python全局解释器锁，由于GIL的存在，在任意时刻只有一个线程在执行，这也导致python的多线程无法利用到多核CPU的优势，如果是多IO操作的线程影响较小。 在操作系统中进程是资源分配的最小单位，线程是系统调度和分派的最小单位，多个线程是共享同一套资源的，多个线程同时操作同一个资源时就会引发竞争。 乍一看由于GIL的存在能够避免多线程出现资源竞争的问题，其实不然，先看下面这个例子。 12345678910111213141516171819202122import threadinga = 0def add(): global a for i in range(1000000): a += 1def desc(): global a for i in range(1000000): a -= 1if __name__ == '__main__': t1 = threading.Thread(target=add) t2 = threading.Thread(target=desc) t1.start() t2.start() t1.join() t2.join() print(a) 多次运行结束后a的值是不固定的，很多初学者会认为python是一行一行来运行的，如果是这样的话上面的结果必然是0了，事实上python解释器会将我们的代码转换成字节码然后才执行的。通过dis函数可以打印出转换过后的字节码 123456789101112131415161718192021222324252627import disdef add(a): a += 1def desc(a): a -= 1print(dis.dis(add))print(dis.dis(desc))&quot;&quot;&quot; 25 0 LOAD_FAST 0 (a) 2 LOAD_CONST 1 (1) 4 INPLACE_ADD 6 STORE_FAST 0 (a) 8 LOAD_CONST 0 (None) 10 RETURN_VALUENone 28 0 LOAD_FAST 0 (a) 2 LOAD_CONST 1 (1) 4 INPLACE_SUBTRACT 6 STORE_FAST 0 (a) 8 LOAD_CONST 0 (None) 10 RETURN_VALUENone&quot;&quot;&quot; 可以看到a+=1, a-=1, 都被转换成四个字节码了，python在运行过程中执行一定数量的字节码或者运行了一段时间之后可能就会发生切换，从线程1切换到线程2，这个时候如果a+=1的操作没有执行完，a的结果就会是错误的。 所以GIL并不能保证线程安全。如何保证请往下看。 多线程的创建通过Thread类实例化12345678import threading,timedef run(n): print(n) time.sleep(2)t1 = threading.Thread(target=run,args=(&quot;t1&quot;,))t2 = threading.Thread(target=run,args=(&quot;t2&quot;,))t1.start()t2.start() 继承Thread123456789101112131415from threading import Threadimport timeclass MyThread(Thread): def __init__(self, name): super().__init__(name=name) def run(self): print(self.name) time.sleep(10)t1 = MyThread('t1')t2 = MyThread('t2')t1.start()t2.start() join &amp; setDaemon在默认情况下，主线程会在子线程结束后才会退出，这在某些时候不是我们想要的，这时候将子线程设置为守护线程，守护线程的子线程不会阻止主线程的退出。 123456789101112131415161718192021222324from threading import Threadimport timeclass MyThread(Thread): def __init__(self, name, sleep): self.sleep = sleep super().__init__(name=name) def run(self): print(self.name) time.sleep(self.sleep) print(self.name + 'end')if __name__ == '__main__': t1 = MyThread('t1', 1) t2 = MyThread('t2', 2) t2.setDaemon(True) t1.start() t2.start()# 将t2设置为守护线程的结果， 可以看出t1结束后主线程退出，没有打印出t2的结果# t1# t2# t1end join方法则会将线程阻塞，知道该线程执行完成后才继续往下运行 12345678910111213if __name__ == '__main__': t1 = MyThread('t1', 1) t2 = MyThread('t2', 2) t1.start() t1.join() t2.start()# t1阻塞后的结果，t1线程运行结束后才开始运行t2线程# t1# t1end# t2# t2end 线程间通信使用全局变量在最上面的GIL部分已经使用到了全局变量来实现两个线程的通信，由于多线程资源竞争的关系，单纯的全局变量不是线程安全的，为了让全局变量变成线程安全需要使用线程锁来实现，这点会单独放到线程同步里面详细说明。 Queuequeue模块中总共包含三种队列模式，Queue（先进先出）LifoQueue（后进先出）PriorityQueue（自定义优先级），这三种队列都是线程安全的通过名称很容易知道每种模式的区别，这里不做详细说明。 Queue提供了 get() put() 方法实现获取以及添加，在实例化的时候通过maxsize参数指定队列的最大容量，默认为0不限制大小。 get() put() 方法默认都是阻塞的，可以通过block=False 以及 timeout参数实现非阻塞，超时后会抛出异常。同时也有get_nowait() put_nowait() 两个非阻塞的方法，没有get或者put成功会立即抛出异常 下面通过模拟一个简单的爬虫来了解如何通过queue实现两个线程间的通信 123456789101112131415161718192021222324252627282930from queue import Queueimport threadingimport timedetail_list_queue = Queue(maxsize=4)def get_detail_html(queue, name): while True: url = queue.get() print('{} start -- {}'.format(name, url)) time.sleep(2) queue.task_done() print('{} end -- {}'.format(name, url))def get_detail_url(queue): print('start get list') for i in range(4): queue.put('www.demo.com/detail/{}'.format(i)) time.sleep(1) print('end get list')if __name__ == '__main__': t1 = threading.Thread(target=get_detail_url, args=(detail_list_queue,)) t2 = threading.Thread(target=get_detail_html, args=(detail_list_queue, 't2')) t3 = threading.Thread(target=get_detail_html, args=(detail_list_queue, 't3')) t1.start() t2.start() t3.start() detail_list_queue.join() print('---end---') 这段代码里面有一个线程模拟获取URL，另外两个线程模拟从队列里面获取URL并请求对应的HTML，从结果中能够看出，t2、t3线程依次从队列中获取URL并请求。 1234567891011start get list---end---t2 start -- www.demo.com/detail/0t3 start -- www.demo.com/detail/1t2 end -- www.demo.com/detail/0t2 start -- www.demo.com/detail/2t3 end -- www.demo.com/detail/1t3 start -- www.demo.com/detail/3t2 end -- www.demo.com/detail/2end get listt3 end -- www.demo.com/detail/3 join() task_done() 和线程的 join 一样 queue 的 join 方法也会阻塞，queue 会记录未完成的个数，put() 成功后次数加一 , task_done() 次数减一。当未完成个数为0时会解除阻塞。需要注意使用了 join 后 必须调用 task_done 来解除阻塞 线程同步线程同步主要解决的就是最上面介绍的资源竞争问题，防止在不同的线程中同时对同一个变量操作引发资源竞争，导致最终的结果不是预期情况。 LockPython多线程中一般通过 “锁” 来实现线程间的同步，Lock 可以让被加锁的代码段同一时刻只有一个能够运行，只有当这把锁释放了才会去运行其他代码，这就避免了当一个代码段没有执行完就切换到另外的线程中去。 这里我们对GIL部分的事例代码做一下优化，让最终的结果符合预期表现。 12345678910111213141516171819202122232425262728import threadingfrom threading import Locka = 0lock = Lock()def add(): global a for i in range(1000000): lock.acquire() a += 1 lock.release()def desc(): global a for i in range(1000000): lock.acquire() a -= 1 lock.release()if __name__ == '__main__': t1 = threading.Thread(target=add) t2 = threading.Thread(target=desc) t1.start() t2.start() t1.join() t2.join() print(a) 上面的事例使用到了 Lock 的 acquire() release() 两个方法，分别对应 获取锁， 释放锁。当获取不到锁的时候会被阻塞，所以在使用锁的时候必须释放，否则我们的代码就会出现死锁。 常见的死锁导致的原因： 获取锁之后没有释放 互相等待 我们模拟一个银行相互转账的例子来说明（不考虑真实场景） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import threadingimport timelock_a = threading.Lock()lock_b = threading.Lock()class Account(object): def __init__(self, name, money): self.name = name self.money = money def recv(self, amount): self.money += amount print(self.name, 'add', amount) def send(self, amount): self.money -= amount print(self.name, 'desc', amount)# 相互转账我们分为两个步骤，即A -&gt; B , B -&gt; Adef a_to_b(account_a, account_b, amount): lock_a.acquire() # 先获取锁将A账户金额锁住 time.sleep(1) # 模拟A账户扣减耗时 account_a.send(amount) lock_b.acquire() account_b.recv(amount) # 锁住B账户金额 lock_a.release() lock_b.release()def b_to_a(account_b, account_a, amount): lock_b.acquire() # 先获取锁将B账户金额锁住 time.sleep(1) account_b.send(amount) lock_a.acquire() account_a.recv(amount) # 锁住A账户金额 lock_b.release() lock_a.release()if __name__ == '__main__': account_a = Account('a', 1000) account_b = Account('b', 2000) t1 = threading.Thread(target=a_to_b, args=(account_a, account_b, 100)) t2 = threading.Thread(target=b_to_a, args=(account_b, account_a, 50)) t1.start() t2.start() t1.join() t2.join() print('a', account_a.money) print('b', account_b.money) print('end')# -- result -- # a desc 100# b desc 50 先获取账户A的锁等待获取B的锁，此时在另外的一个线程中已经获取了B账户的锁但是又在等待A账户的锁，这就导致两个线程中锁互相等待的情况出现，程序无法向下运行了 调用其他外部方法，外部方法中也调用了锁 1234567891011lock = threading.Lock()def func1(): lock.acquire() # do something lock.release()def func2(): lock.acquire() func1() lock.release() RLockRlock 和 Lock 功能上是类似的，Rlock在同一个线程内可以 acquire 多次，release 的次数一定要与 acquire 次数一致。 Condition这个类可以让一个或多个线程等待，直到其他线程通知，通过这样我们可以让多个线程之间互相切换运行。 Condition 在实例化的时候可以传递一个Lock 或者 RLock 对象，否则会默认创建一个 RLock 作为底层锁。 Condition 提供了四种常用的方法，wait(timeout=None) notify(n=1) wait_for(predicate, timeout=None) notify_all() ，调用这些方法之前必须获取锁，否则会抛出 RuntimeError 异常 wait 方法的时候 Condition 会先释放底层锁，然后阻塞，直到被另外线程的同一 Condition 通过 notify 或者 notify_all 唤醒。 notify 方法可指定唤醒多少个等待这个 Condition 的线程，默认为一个。 wait_for 方法作用同 wait 一样，只是多个 predicate 参数，此参数接收一个 callable 对象，他的返回值必须是可以判断真假的，调用次方法是将会一直等待只有当 predicate 返回为真时才将 predicate 返回值返回。 notify_all 顾名思义唤醒所有等待这个 Condition 的线程。 例如下面的这个两个线程循环输出连续的数字 123456789101112131415161718192021222324252627import threadingcond = threading.Condition()list_1 = [1, 3, 5, 7, 9]list_2 = [2, 4, 6, 8, 10]def func1(): global list_1 global cond with cond: for i in list_1: print(i) cond.notify() cond.wait()def func2(): global list_2 global cond with cond: for i in list_2: cond.wait() print(i) cond.notify()threading.Thread(target=func2).start()threading.Thread(target=func1).start() Semaphore &amp; BoundedSemaphore信号量，Python 多线程的一个内置计数器，通过 acquire 和 release 实现计数加减 acquire(blocking=True, timeout=None) 当 blocking 设置为False 时将不会阻塞并立即返回 False，否则将阻塞直到计数大于 0 并返回 True ，timeout 将在超时后返回 False。 release() 释放信号量，计数加一。 BoundedSemaphore 继承 Semaphore 类，重载了 release() 方法，使得不能无限制的 release ，当计数值大于等于初始值时会抛出异常。 下面是通过信号量实现同时只有三个线程运行的示例。 123456789101112import threading, timesem = threading.Semaphore(value=3)def func(): sem.acquire() print('func start') time.sleep(1) sem.release()for i in range(10): threading.Thread(target=func).start() Event多线程中的事件对象，管理一个标志位，通过 set () 、clear() 、 wait() 、is_set() 来获取或者管理标志位。 Event 初始化的时候标志位是False。 set() 设置标志位为True。 clear() 设置标志位为False。 wait() 等待标志位设为True。 is_set() 判断标志位是否为True。 过于简单不写对应的例子了。 回顾上面的 Condition 、Semaphore、Event 从源码上来看底层都是基于 Lock 和 Rlock 来实现的，只是封装了常用的一些用法方便开发者调用，万变不离其宗线程间的同步我们只需要抓住 “ 锁 ” 这个概念，理解和使用起来就没什么大问题。 线程池在上面我们通过信号量实现了一个简单的线程池，只是功能比较简单。其实 Python 给我们提供了线程池功能，位于 concurrent.futures 模块下面 ThreadPoolExecutor，下面将简单的介绍 Python 线程池所提供的功能。 创建线程池实例化 ThreadPoolExecutor 时有四个可选参数，分别是 max_workers 设置最大线程数量，默认为当前计算机CPU数量的5倍。 thread_name_prefix 设置线程名称前缀。 initializer 设置每个线程初始化之前的都会调用的方法，参数值必须为可调用的。 initargs 传给 initializer 的参数。 通过 submit 方法将需要执行的方法提交到线程池中，非阻塞，会立即返回一个 futures 对象 12345678910111213from concurrent.futures import ThreadPoolExecutorimport timedef start(*args): print(args)def run(times): print('run for {} seconds'.format(times)) time.sleep(times) return timesexecutor = ThreadPoolExecutor(max_workers=2, initializer=start, initargs=('start',))executor.submit(run, 2) 也可以使用 map 方法批量提交，返回一个 线程执行结果的生成器，此方法是阻塞的，只有等到所有的线程都执行完毕才会继续。 12for result in executor.map(run, (1,2,3,4)): print(result) 关闭线程池 shutdown(wait=True) ，关闭后 submit 、map 将会抛出 RuntimeError ，wait 为 True 时将会阻塞直到所有线程执行结束，为 False 立即返回 获取子线程返回结果 使用 map 提交线程 使用 future.result() 12task = executor.submit(run, 10)print(task.result()) 使用 as_completed 需要传递一个可迭代的 future 对象，将返回一个已完成的 future 生成器 123tasks = [executor.submit(run, i) for i in [1, 2]]for future in as_completed(tasks): print(future.result()) 其他 wait() 阻塞主线程直到 传递进去的 future 满足某些条件，可以通过 return_when 参数决定什么时候阻塞完成，返回值是一个有两个值 namedtuple 第一个是已完成或者已取消的 future 集合，第二个是没有完成的 future 集合 ALL_COMPLETED（默认） 等待所有 future 完成后返回 FIRST_COMPLETED 某一个 future 完成或者取消是返回 FIRST_EXCEPTION 抛出异常是返回，如果没有异常抛出则和 ALL_COMPLETED 等效 1234567891011121314151617181920from concurrent.futures import ThreadPoolExecutor, wait, FIRST_COMPLETEDimport timedef run(times): print('run for {} seconds'.format(times)) time.sleep(times) return timesexecutor = ThreadPoolExecutor(max_workers=2)tasks = [executor.submit(run, i) for i in [1, 2]]future_tuple = wait(tasks, return_when=FIRST_COMPLETED)print(future_tuple.done)print(future_tuple.not_done)# -- result --# run for 1 seconds# run for 2 seconds# {&lt;Future at 0x10a96eb38 state=finished returned int&gt;}# {&lt;Future at 0x10ab38240 state=running&gt;} cancle() 由 future 提供的方法，可以将还没有运行的线程取消掉，取消成功返回True。 done() 由future 提供的方法，判断是否运行结束。","link":"/2021/08/16/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%85%E6%9E%90/"},{"title":"Python字典的实现原理","text":"以下是自己的学习记录，算是一个总结。 接下来会依次对下面问题做一个解答： 1. Python的dict和set为什么是无序的？ 2. 为什么不是所有的python对象都可以用作dict的键和set中的元素 要弄懂上面的问题，我们首先要了解Python内部是如何实现dict和set类型的。我们先来看看dict的内部结构，dict其实本质上是一个散列表（散列表即总有空白元素的数组，Python会保证至少有三分之一的数组元素是空的），dict的每个键都占用一个表元，而一个表元中又分为两个部分，分别是对键的引用和对值的引用。当我们存放一个对象的时候，首先会要计算这个元素的散列值，python中使用hash()方法来实现的，这也就回答了第二个问题，因为不是所有的python对象都可以使用hash来获取散列值，获取不到散列值也就不可能存放到dict中，所以只有可hash的对象才能够作为dict的键。值得注意的是内置的hash方法可以用于所有的内置类型对象的，所有用户自定义的对象默认都是可以作为键的，因为自定义对象的散列值是通过id()来获取的。例如： class T(object): pass t = T() print(id(t)) d = {t: 1} print(d) ### 2133693018240 ### {&lt;__main__.T object at 0x000001F0CA03B080&gt;: 1} 现在假设我们已经获取到了元素的散列值，接下来就该计算应当存放位置了，将散列值对数组长度进行取余，得到的结果就是存放位置的索引了。但是不同的key可能会得到相同的散列值，也就是哈希冲突的问题，python内部是使用开放寻址的方法来解决的，开放寻址法就不在此详细说了。关于为什么dict是无序的，这个是因为python内部会保证散列表至少有三分之一的位置为空，当我们增加元素的时候，python有可能会对散列表进行扩容，具体操作就是重新开辟一块更大的空间，将原有的元素添加到新表里面，这个过程中可能又会发生新的散列冲突，导致新的散列表中的键的次序发生变化。当然呢如果想要保存顺序也可以使用OrderedDict来处理 dict操作的时间复杂度： 操作 操作说明 时间复杂度 copy 复制 O(n) get(value) 获取 O(1) set(value) 修改 O(1) delete(value) 删除 O(1) search(in) 字典搜索 O(1) iterration 字典迭代 O(n) set集合和dict一样也是基于散列表的，只是他的表元只包含值的引用而没有对键的引用，其他的和dict基本上是一致的，所以在此就不再多说了。","link":"/2018/02/10/Python%E5%AD%97%E5%85%B8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"title":"Python实现支付宝转账接口","text":"由于工作需要使用python开发一个自动转账接口，记录一下开发过程。 首先需要在蚂蚁金服上申请开通开发者账户，有了开发者账户就可以使用沙箱进行开发了。 在开发之前我们需要在沙箱应用中填写密钥，密钥的获取可以使用阿里提供的工具包自动生成。 前期准备工作完成了，接下来是编写代码部分。主要用到了python-alipay-sdk库，使用pip安装即可，如果安装的过程中遇到问题推荐使用Anaconda（crypto这个库安装了我好久没成功，最后换成Anaconda环境了） from datetime import datetime from alipay import AliPay class Payment(): def __init__(self, appid, url): ''' 支付接口初始化 :param appid: 商户appid :param url: 支付宝接口url ''' self.app_private_key_string = open(\"app_private_key.txt\").read() # 应用私钥（默认从两个TXT文件中读取） self.alipay_public_key_string = open(\"alipay_public_key.txt\").read() # 支付宝公钥 self.alipay = AliPay( appid=appid, app_notify_url=url, app_private_key_string=self.app_private_key_string, alipay_public_key_string=self.alipay_public_key_string, sign_type=\"RSA2\", debug=True ) 初始化的时候需要用到appid、应用私钥以及支付宝公钥，appid和支付宝公钥可在沙箱应用中看到，应用私钥则需要在刚刚生成密钥工具包的目录下查看 获取两个密钥之后可以单独写入到两个TXT文件中然后读取文件内容来获取，以便以后的更改，在写入TXT文件的过程中不能只是单纯的将密钥复制过去，需要再第一行和最后一行加入 -----BEGIN PUBLIC KEY----- 你的密钥 -----END PUBLIC KEY----- 要不然会出现这个错误 第一次接触这玩意，不知道具体的格式，找了好久的问题，最后在源码的这个地方发现了问题，必须以这个开头 公共请求参数部分至此就完成了，接下来就是请求参数了，按照开发文档上有四个是必须的：out_biz_no、payee_type、payee_account、amount 对应的意思分别是：商户转账唯一订单号、收款方账户类型、收款方账户、转账金额。还有部分参数是可选的，在下面的代码中交代了。 def pay(self, payee_account, amount, payee_real_name=None, remark=None, payer_show_name=None, payee_type=\"ALIPAY_LOGONID\"): ''' 发起转账 :param payee_account: 收款方账户 :param amount: 转账金额 :param payee_real_name: :param remark: 收款方姓名 :param payer_show_name: 转账备注 :param payee_type: 付款方姓名 :return: ''' result = self.alipay.api_alipay_fund_trans_toaccount_transfer( datetime.now().strftime(\"%Y%m%d%H%M%S\"), payee_type=payee_type, # 收款方账户类型 payee_account=payee_account, # 收款方账户 amount=amount, # 转账金额 payee_real_name=payee_real_name, # 收款方姓名（可选，若不匹配则转账失败） remark=remark, # 转账备注 payer_show_name=payer_show_name # 付款方姓名 ) # result={'code':'10000','msg':'Success','order_id': '','out_biz_no': '', 'pay_date': '2017-06-26 14:36:25'} # 接口文档：https://docs.open.alipay.com/api_28/alipay.fund.trans.toaccount.transfer if result['code'] == '10000': if result['msg'] == \"Success\": print(\"转账成功\" + \" 交易单号：\" + result[\"order_id\"]) else: print(result) print(result['sub_msg']) 到这这个代码的基础部分就此完成：","link":"/2018/07/31/Python%E5%AE%9E%E7%8E%B0%E6%94%AF%E4%BB%98%E5%AE%9D%E8%BD%AC%E8%B4%A6%E6%8E%A5%E5%8F%A3/"},{"title":"Python显示进度条的方法","text":"使用&nbsp;progressive&nbsp;库实现 第一步&nbsp;导入模块 from progressive.bar import Bar 第二步&nbsp;实例化 &nbsp; &nbsp; bar = Bar(title=&quot;Progress&quot;, max_value=MAX_VALUE, fallback=True) 在源文件中可以 可以自定义标题、宽度、颜色等等、、、 第三步&nbsp;初始化的一些操作 bar.cursor.clear_lines(1) bar.cursor.save() bar.cursor.restore() 第四步&nbsp;显示进度条 bar.draw(value=NOW_VALUE, newline=False) 在draw这个方法里面value是指当前进度条位置，newline可设置是否在新的一行里面重新显示 显示效果","link":"/2018/02/10/Python%E6%98%BE%E7%A4%BA%E8%BF%9B%E5%BA%A6%E6%9D%A1%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"Redis基础","text":"Redis基础Redis[toc] Redis的数据结构Redis 总共有五种不同的数据结构，分别是STRING、LIST、SET、HASH、ZSET，各种具体含义见下图 结构类型| 存储的值—|—|— STRING | 字符串、整数、浮点数 List | 一个链表，链表里面每个节点都是一个字符串 SET | 集合，集合里面的每个字符串都是唯一的 HASH | 包含键值对的无序散列表 ZSET | 有序集合，元素顺序由分值的大小决定 Redis 基础命令STRING（字符串）基础命令 命令 行为 GET 获取给定键中的值 SET 设置给定键中的值（返回OK，python客户端会转换为True） DEL 删除给定键中的值（返回成功删除数量 可一次删除多个） 1234567# redis-cli127.0.0.1:6379&gt; set hello worldOK127.0.0.1:6379&gt; get hello&quot;world&quot;127.0.0.1:6379&gt; del hello(integer) 1 自增自减命令 命令 用例和行为 INCR INCR key-name 将对应值加一 DECR DECR key-name 将对应值减一 INCRBY INCRBY key-name num 将对应值加上整数num (num非整数会报错) DECRBY DECRBY key-name num 将对应值减去整数num INCRBYFLOAT INCRBYFLOAT key-name num 将对应值加上浮点数num 12345678910111213# redis-cli127.0.0.1:6379&gt; set amount 1OK127.0.0.1:6379&gt; incr amount(integer) 2127.0.0.1:6379&gt; decr amount(integer) 1127.0.0.1:6379&gt; incrby amount 10(integer) 11127.0.0.1:6379&gt; decrby amount 5(integer) 6127.0.0.1:6379&gt; incrbyfloat amount 2.333&quot;8.333&quot; 上面的都是正常的数值加减，那么如果值为字符串类型redis会如何处理呢？ 在redis中，如果存储的字符串可以十进制转换为整数或者浮点数那么也是可以使用自增自减操作的，否则会出异常。另外如果对一个不存在的键操作的时候，默认会当作0来处理。 12345678910111213141516# redis-cli# 可以转换的字符串自增127.0.0.1:6379&gt; set string-test &quot;12&quot;OK127.0.0.1:6379&gt; incr string-test(integer) 13# 不可以转换的字符串自增127.0.0.1:6379&gt; set string-test &quot;ab&quot;OK127.0.0.1:6379&gt; incr string-test(error) ERR value is not an integer or out of range# 空值自增127.0.0.1:6379&gt; get nil-test(nil)127.0.0.1:6379&gt; incr nil-test(integer) 1 字符串命令 命令 用例和行为 APPEND APPEND key-name value 将value追加到对应值的末尾，返回总长度。 GETRANGE GETRANGE key-name start end 获取对应值从start到end范围类的所有内容(包含start和end) SETRANGE SETRANGE key-name offset value 将offset之后所有的内容替换为value，返回总长度。（如果offset超过最大长度，redis会使用空值补位） 12345678910111213141516171819# redis-cli127.0.0.1:6379&gt; set string 'abc'OK# 追加127.0.0.1:6379&gt; append string 'def'(integer) 6# 获取全部127.0.0.1:6379&gt; getrange string 0 -1&quot;abcdef&quot;# 设置offset之后的值127.0.0.1:6379&gt; setrange string 3 'abc'(integer) 6127.0.0.1:6379&gt; get string&quot;abcabc&quot;# offset超过最大长度时127.0.0.1:6379&gt; setrange string 8 'def'(integer) 11127.0.0.1:6379&gt; get string&quot;abcabc\\x00\\x00def&quot; 二进制命令会将字节串看作是二进制位串来操作 命令 用例和行为 GETBIT GETBIT key-name offset 获取偏移量为offset的二进制值值，超过最大长度返回0 SETBIT SETBIT key-name offset value 将偏移量为offset的二进制值设为value，返回之前的二进制 BITCOUNT BITCOUNT key-name [start end] 统计值为1的数量，可指定范围 BITOP BITOP operation dest-key key-name [key-name ...]对一个或多个二进制位串执行AND、OR、XOR、NOT的按位运算操作，并将结果报错至dest-key键里面。 LIST（列表）基础命令 命令 用例和行为 RPUSH RPUSH key-name value [value ...] 将一个或多个推入列表右端，返回列表长度 LPUSH LPUSH key-name value [value ...] 将一个或多个推入列表左端，返回列表长度 RPOP RPOP key-name 移除并返回列表最右端元素 LPOP LPOP key-name 移除并返回列表最左端元素 LINDEX LINDEX key-name offset 返回列表中偏移量为offset的元素值 LRANGE LRANGE key-name start end 返回偏移量在start和end之间的所有元素值(包括start和end) LTRIM LTRIM key-name start end 只保留偏移量在start和end之间的元素(包括start和end) 12345678910111213141516171819202122232425262728293031323334353637383940# redis-cli# 右端推入一个或多个元素127.0.0.1:6379&gt; rpush list-test 1(integer) 1127.0.0.1:6379&gt; rpush list-test 2 3(integer) 3# 左端推入一个或多个元素127.0.0.1:6379&gt; lpush list-test 4(integer) 4127.0.0.1:6379&gt; lrange list-test 0 -11) &quot;4&quot;2) &quot;1&quot;3) &quot;2&quot;4) &quot;3&quot;# 弹出右端元素127.0.0.1:6379&gt; rpop list-test&quot;3&quot;# 弹出左端元素127.0.0.1:6379&gt; lpop list-test&quot;4&quot;# 获取偏移量对应元素的值127.0.0.1:6379&gt; lindex list-test 1&quot;2&quot;# 当偏移量不符合时127.0.0.1:6379&gt; lindex list-test 10(nil)127.0.0.1:6379&gt; rpush list-test 5 6 7(integer) 5127.0.0.1:6379&gt; lrange list-test 0 -11) &quot;1&quot;2) &quot;2&quot;3) &quot;5&quot;4) &quot;6&quot;5) &quot;7&quot;# 保留0-1间的元素127.0.0.1:6379&gt; ltrim list-test 0 1OK127.0.0.1:6379&gt; lrange list-test 0 -11) &quot;1&quot;2) &quot;2&quot; 阻塞弹出、列表间移动 命令 用例和行为 BRPOP BRPOP key-name [key-name ...] timeout 从第一个非空列表中弹出最右端元素，返回被弹出的key-name和弹出的元素值，如果全部为空则阻塞timeout秒，超过timeout秒任然没有则返回None BLPOP BLPOP key-name [key-name ...] timeout 变为最左端元素，其他同上 RPOPLPUSH RPOPLPUSH source-key dest-key 从source-key中弹出最右端元素并将该元素推入到dest-key的最左端，然后返回该值 BRPOPLPUSH RPOPLPUSH source-key dest-key timeout 同上，如果source-key为空则阻塞timeout秒等待可弹出元素，超时返回None 123456789101112131415161718192021222324252627282930313233343536# redis-cli# list1为空，按顺序弹出list2的值127.0.0.1:6379&gt; rpush list2 1 2(integer) 2127.0.0.1:6379&gt; rpush list3 1(integer) 1127.0.0.1:6379&gt; brpop list1 list2 list3 11) &quot;list2&quot;2) &quot;2&quot;# list1阻塞1秒后127.0.0.1:6379&gt; brpop list1 1(nil)(1.08s)# 在另一个终端向空的list1推入值# shell-1127.0.0.1:6379&gt; rpush list-test 1(integer) 1# shell-2127.0.0.1:6379&gt; brpop list1 1 101) &quot;list1&quot;2) &quot;1&quot;(10.00s)# list2和list3间的移动127.0.0.1:6379&gt; lrange list2 0 -11) &quot;1&quot;127.0.0.1:6379&gt; lrange list3 0 -11) &quot;1&quot;127.0.0.1:6379&gt; rpoplpush list2 list3&quot;1&quot;127.0.0.1:6379&gt; lrange list3 0 -11) &quot;1&quot;2) &quot;1&quot; SET（集合）基础命令 命令 用例和行为 SADD SADD key-name item [item ...] 将一个或多个元素添加到集合里面，返回添加进去的数量 SREM SREM key-name item [item ...] 从集合里面移除一个或者多个元素，返回成功删除的数量 SISMEMBER SISMEMBER key-name item 检查item是否存在与集合里面，存在返回1否则返回0 SCARD SCARD key-name 返回集合包含元素的总数 SMEMBERS SMEMBERS key-name 返回集合包含的所有元素 SRANDMEMBER SRANDMEMBER key-name [count] 从集合里面随机返回一个或多个元素，count为正返回结果不会重复，count为负可能会重复 SPOP SPOP key-name [count] 随机移除一个或多个元素，并返回被移除的元素 SMOVE SMOVE source-key dest-key item 如果source-key包含item则将item添加到dest-key集合，如果item存在则返回1否则返回0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 添加时返回被添加的数量127.0.0.1:6379&gt; sadd set-test 1 2 3 1(integer) 3127.0.0.1:6379&gt; smembers set-test1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;# 移除时返回被移除的数量127.0.0.1:6379&gt; srem set-test 4 1(integer) 1# 获取当前元素数量127.0.0.1:6379&gt; scard set-test(integer) 2# 不存在时返回0127.0.0.1:6379&gt; sismember set-test 1(integer) 0# 存在时返回1127.0.0.1:6379&gt; sismember set-test 2(integer) 1127.0.0.1:6379&gt; sadd set-test 5 6 7(integer) 3# 默认返回一个127.0.0.1:6379&gt; srandmember set-test&quot;7&quot;# count为负数时返回结果重复127.0.0.1:6379&gt; srandmember set-test -61) &quot;6&quot;2) &quot;2&quot;3) &quot;5&quot;4) &quot;7&quot;5) &quot;6&quot;6) &quot;2&quot;# count为正数结果不会重复127.0.0.1:6379&gt; srandmember set-test 61) &quot;2&quot;2) &quot;3&quot;3) &quot;5&quot;4) &quot;6&quot;5) &quot;7&quot;# 移除一个127.0.0.1:6379&gt; spop set-test&quot;2&quot;# 移除多个，count不能小于0127.0.0.1:6379&gt; spop set-test 21) &quot;7&quot;2) &quot;3&quot;# 移动失败127.0.0.1:6379&gt; smove set-test set2 8(integer) 0# 移动成功127.0.0.1:6379&gt; smove set-test set2 5(integer) 1127.0.0.1:6379&gt; smembers set21) &quot;5&quot; 集合的运算 命令 用例和行为 SDIFF SDIFF key-name [key-name ...] 返回存在于第一个集合但是不存在与其他集合的元素（差集） SDIFFSTORE SDIFFSTORE dest-key key-name [key-name ...] 将存在于第一个不存在于其他集合的元素存到dest-key里面 SINTER SINTER key-name [key-name ...] 返回同时存在与所有集合的元素（交集） SINTERSTORE SINTERSTORE dest-key key-name [key-name ...] 将同时存在于所有集合的元素存放到dest-key里面 SUNION SUNION key-name [key-name ...] 返回至少存在于一个集合的元素（并集） SUNIONSTORE SUNIONSTORE dest-key key-name [key-name ...] 将至少存在于一个集合的元素存放到dest-key里面 1234567891011121314151617181920212223242526272829303132333435# redis-cli# 创建set1、set2、set3127.0.0.1:6379&gt; sadd set1 1 2 3 4(integer) 4127.0.0.1:6379&gt; sadd set2 2 3 4 5(integer) 3127.0.0.1:6379&gt; sadd set3 0(integer) 1# set1和set2的差集127.0.0.1:6379&gt; sdiff set1 set21) &quot;1&quot;# set1和set2的差集存储到set4里面 127.0.0.1:6379&gt; sdiffstore set4 set2 set3(integer) 4127.0.0.1:6379&gt; smembers set41) &quot;2&quot;2) &quot;3&quot;3) &quot;4&quot;4) &quot;5&quot;# set1和set2和set3的交集127.0.0.1:6379&gt; sinter set1 set2 set3(empty array)# set1和set2的交集127.0.0.1:6379&gt; sinter set1 set21) &quot;2&quot;2) &quot;3&quot;3) &quot;4&quot;# set1和set2和set3的并集127.0.0.1:6379&gt; sunion set1 set2 set31) &quot;0&quot;2) &quot;1&quot;3) &quot;2&quot;4) &quot;3&quot;5) &quot;4&quot;6) &quot;5&quot; HASH（散列）基础命令在以前的版本中，有hset，hmset命令，分别是设置一个键值，设置多个键值，不过在4.0.0版本以后中hset也可以设置获取多个键值对，推荐使用hset 命令 用例和行为 HSET HSET key-name key value [key value ...] 设置一个或多个键值对，返回设置成功的数量 HGET HGET key-name key 获取指定键值对，如果不存在则返回空值 HMGET HMGET key-name key [key ...] 获取一个或多个键值对，如果不存在则用空值代替 HGETALL HGETALL key-name 获取所有键值对 HDEL HDEL key-name key [key ...] 删除一个或多个键值对，返回删除成功数量 HLEN HLEN key-name 获取所有键值对的数量 12345678910111213141516171819202122232425262728293031323334353637383940414243# redis-cli# 设置一个键值对127.0.0.1:6379&gt; hset hash-test 'a' 1(integer) 1# 设置多个键值对127.0.0.1:6379&gt; hset hash-test 'b' 2 'c' 3(integer) 2# 获取指定键值对127.0.0.1:6379&gt; hget hash-test a&quot;1&quot;# 获取多个键值对127.0.0.1:6379&gt; hmget hash-test b c1) &quot;2&quot;2) &quot;3&quot;# 存在空值的情况127.0.0.1:6379&gt; hmget hash-test b c d1) &quot;2&quot;2) &quot;3&quot;3) (nil)# 获取所有键值对127.0.0.1:6379&gt; hgetall hash-test1) &quot;a&quot;2) &quot;1&quot;3) &quot;b&quot;4) &quot;2&quot;5) &quot;c&quot;6) &quot;3&quot;# 删除键值对127.0.0.1:6379&gt; hdel hash-test a(integer) 1# 删除不存在的键值对127.0.0.1:6379&gt; hdel hash-test d(integer) 0# 删除多个键值对27.0.0.1:6379&gt; hdel hash-test b c(integer) 2# 获取所有键值对数量127.0.0.1:6379&gt; hlen hash-test(integer) 0127.0.0.1:6379&gt; hset hash-test d 4(integer) 1127.0.0.1:6379&gt; hlen hash-test(integer) 1 高级命令 命令 用例和行为 HEXISTS HEXISTS key-name key 检查给定的键是否存在 HKEYS HKEYS key-name 获取所有的键 HVALS HVALS key-name 获取所有的值 HINCRBY HINCRBY key-name key num 将key对应的值加上整数num，如果key对应的值不能增加则会报错 HINCRBYFLOAT HINCRBYFLOAT key-name key increment将key对应的值加上浮点数数num，如果key对应的值不能增加则会报错 123456789101112131415161718192021222324252627282930# redis-cli127.0.0.1:6379&gt; hset hash2 a 1 b 2 c 3 d d(integer) 4127.0.0.1:6379&gt; hexists hash2 a(integer) 1127.0.0.1:6379&gt; hexists hash2 g(integer) 0127.0.0.1:6379&gt; hkeys hash21) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;d&quot;127.0.0.1:6379&gt; hvals hash21) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;d&quot;127.0.0.1:6379&gt; hincrby hash2 a 1(integer) 2# 不可增加的情况127.0.0.1:6379&gt; hincrby hash2 d 1(error) ERR hash value is not an integer127.0.0.1:6379&gt; hincrbyfloat hash2 a 1&quot;3&quot;127.0.0.1:6379&gt; hincrbyfloat hash2 a 1.33&quot;4.33&quot;# 不可增加的情况127.0.0.1:6379&gt; hincrbyfloat hash2 d 1.33(error) ERR hash value is not a float127.0.0.1:6379&gt; ZSET（有序集合）基础命令 命令 用例和行为 ZADD ZADD key-name score item [score item ...] 将带有给定分值的元素添加到集合里面 ZREM ZREM key-name item [item ...] 删除给定的元素，返回删除成功的个数 ZCARD ZCARD key-name 返回集合里面元素总数 ZINCRBY ZINCRBY key-name num item 将指定元素的分值加上num ZCOUNT ZCOUNT key-name min max 返回分值在min和max之间的元素数量 ZRANK ZRANK key-name item 返回指定元素在集合里面的排名 ZSCORE ZSCORE key-name item 返回指定元素的分值 ZRANGE ZRANGE key-name start stop [WITHSCORES] 返回排名在start和stop之间的成员，WITHSCORES可同时返回对应的分值 发布与订阅其他命令","link":"/2019/03/07/Redis%E5%9F%BA%E7%A1%80/"},{"title":"WinSCP默认使用root用户登录的方法","text":"使用WinSCP远程登录ubuntu系统后，再进行文件的拖拽操作的时候会提示错误&nbsp;&nbsp; 原因是没有这个权限，需要我们使用root用户进行操作，但是WinSCP并不能默认使用root用户进行登录，解决方法是： 1：使用 sudo passwd root 设置好密码（已设置可忽略这步）。 2：然后在/etc/ssh/sshd_config中找到PermitRootLogin 这一行将后面的参数改为yes 保存退出。 3：重启service ssh restart 。 4：重新打开winscp 重新编辑登录信息，使用root用户登录就可以直接拖拽文件。","link":"/2017/12/29/WinSCP%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8root%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"configparser模块的简单使用","text":"configparser是python中自带的一个配置文件读写的库，python2中为ConfigParser在python3中更名为configparser，首先我们建立一个test.ini的配置文件，内容如下： 123456789[device]port=COM9baud_rate=9600&lt;/pre&gt;&lt;h5&gt;读操作：&lt;/h5&gt;&lt;p&gt;实例：&lt;/p&gt;&lt;pre class=&quot;python&quot;&gt;import configparsercf=configparser.ConfigParser()cf.read(&quot;test.ini&quot;)print(cf.sections())print(cf.options(&quot;device&quot;))print(cf.items(&quot;device&quot;))print(cf.get(&quot;device&quot;,&quot;port&quot;)) 首先导入configparser模块，再使用read方法读取配置文件内容。 sections()方法返回文件中所有section options(section_name)方法返回该section_name下所有的option items(section_name)方法以元祖的格式返回该section_name下的所有option的key和value get(section_name, option_name)方法只返回key 运行结果 写操作：123456cf.add_section(&quot;section1&quot;)cf.set('section1','key1','value1')cf.write(open(&quot;test.ini&quot;,'w'))print(cf.sections())print(cf.items(&quot;section1&quot;)) add_section(new_section_name)：新建一个section，如果已存在会报错。 set(section_name, option_name, value): 如果option_name存在则更新value，如果不存在则新建一个option和value，但是如果section不存在会报错。 write(）方法将内容重新写入到文件中，需要注意的是如果在写之前没有读去过这个文件那么这次写入将会导致之前的文件内容被覆盖掉。 运行结果 删除操作：12345print(cf.sections())print(cf.items(&quot;section1&quot;))cf.remove_section(&quot;section1&quot;)print(cf.sections()) remove_option(section_name,option_name)：删除指定的option，section不存在会报错。 remove_section(section_name)：删除指定的section。 需要注意这里的删除仅仅只是在内存中进行的，还要进行write()操作写入到文件中，否则配置文件实际上是没有被更改的。 运行结果：","link":"/2018/05/01/configparser%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"title":"cookie和session","text":"cookiecookie:客户端浏览器上的一个文件（键值对方式存储，类似于python中的字典），一般用于记录用户状态、和用户信息的，绝大多数的网站自动登录功能都是基于cookie实现的，下面使用Django实现一个用户登陆作为例子展示。 首先是最简单的登录页面 login： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login请求处理函数 12345678910111213141516171819user_infp ={ &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}} def login(request): if request.method == &quot;GET&quot;: return render(request,&quot;login.html&quot;) if request.method == &quot;POST&quot;: u = request.POST.get(&quot;username&quot;) p = request.POST.get(&quot;password&quot;) dic = user_infp.get(u) if not dic: return render(request,&quot;login.html&quot;) if dic[&quot;password&quot;] == p: res = redirect('/index') res.set_cookie(&quot;username&quot;,u) return res else: return render(request,&quot;login.html&quot;) 当请求为get方式的时候返回登录页面，为post方式的时候验证表单，这里只使用字典来简化从数据库验证的操作。当验证通过的时候跳转到index页面，并且设置一个cookie，内容为｛”username”:username},否则任然返回当前页面。 index页面：仅仅用来显示登录的用户名 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;欢迎{{ user }}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; index处理函数： 123456def index(request): user = request.COOKIES.get(&quot;username&quot;) if not user: return redirect('/login') else: return render(request,'index.html',{&quot;user&quot;:user}) 如果上面我们如果登录成功浏览器会存储一个cookie，当我们再次请求index页面的时候，同时发送过去的还有本地的cookie，所以可以从request中的cookie中获取我们已经存储的用户名，如果不存在则跳转到login页面，如果有登录信息则显示登录页面 以上是最简单的cookie使用，其实cookie还有很多其他的用法 12345678910111213rep = HttpResponse(...) 或 rep ＝ render(request, ...) rep.set_cookie(key,value,...)rep.set_signed_cookie(key,value,salt='加密盐',...)参数： key, 键 value='', 值 max_age=None, 超时时间 expires=None, 超时时间(IE requires expires, so set it if hasn't been already.) path='/', Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 下面再来详细说一说各个参数的作用。首先是获取cookie，salt：这个参数的具体作用目前我还是不太清除，猜测是cookie加密操作，等我弄懂了再回来修改。 接下来是设置cookie，key和value不用再说了，max_age: 设置超时时间以秒为单位，很多网站上登录页面都有多长时间免登录的功能一般都是通过这个来设置的，当超过了一段时间这个cookie就会失效expires: 同样是设置超时时间的，但是和上面的不太一样，这里的单位不是秒，而是datetime,所以就有两种超时时间的设置方法 1234567#max_age方法res.set_cookie(&quot;username&quot;,u,max_age=10)#expires方法import datetimecurrent_time = datetime.datetime.utcnow()end_time = current_time + datetime.timedelta(seconds=10)res.set_cookie(&quot;username&quot;,u,expires=end_time) path :是指定cookie生效的路径，参数默认为 ‘ / ‘ 可被当前网站任意URL页面访问，下面我们重新写一个页面index1，内容和index相同 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这里是index1欢迎{{ user }}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; index1的处理函数 123456def index1(request): user = request.COOKIES.get(&quot;username&quot;) if not user: return HttpResponse(&quot;没有获取到cookie&quot;) else: return render(request,&quot;index1.html&quot;,{&quot;user&quot;:user}) 这里我们将login函数里面的cookie设置为 1res.set_cookie(&quot;username&quot;,u,path='/index') 然后重新运行登录，这里就能看出在index可以正常获取到cookie，而index1获取不到，path设置成功。 domain: 设置生效域名，这里只能设置当前域名的子域名，无法给其他域名设置 session和cookie不同的是session是保存在服务器端的键值对，session基于cookie来使用的，一般情况下本地的cookie会存储session中的key名，然后通过cookie中的key去获取服务器上存储的信息。下面依然以用户登录作为最简单的示例：模板还是上面的那两个，这里只重写对应的处理函数 123456789101112131415161718192021222324252627user_infp ={ &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}} def login(request): if request.method == &quot;GET&quot;: return render(request,&quot;login.html&quot;) if request.method == &quot;POST&quot;: u = request.POST.get(&quot;username&quot;) p = request.POST.get(&quot;password&quot;) dic = user_infp.get(u) if not dic: return render(request,&quot;login.html&quot;) if dic[&quot;password&quot;] == p: res = redirect('/index') request.session['username'] = u request.session[&quot;is_login&quot;] = True return res else: return render(request,&quot;login.html&quot;) def index(request): print(request.session[&quot;is_login&quot;]) if request.session[&quot;is_login&quot;]: return render(request, 'index.html', {&quot;user&quot;: request.session[&quot;username&quot;]}) else: return redirect('/login') 乍一看和cookie的操作类似，其实这是因为django为我们在后台做了很多工作，例如 12request.session['username'] = urequest.session[&quot;is_login&quot;] = True 这两句就很简单的完成了session的创建，实际上django首先生成了一串随机字符串用来作为key并将这个随机字符串保存到本地的cookie中，然后在将后面的两个内容以字典的形式存到服务器端，django中默认session存储在数据库中。 1request.session[&quot;is_login&quot;]: 这一步首先从cookie中回去对应的key，然后再从数据库中获取对应的value进行判断同样的session和cookie一样也有一些高级功能，例如设置超时时间 12345request.session.set_expiry(value)* 如果value是个整数，session会在些秒数后失效。* 如果value是个datatime或timedelta，session就会在这个时间后失效。* 如果value是0,用户关闭浏览器session就会失效。* 如果value是None,session会依赖全局session失效策略。 除了超时时间设置还有一下功能： 123456789101112131415161718192021222324252627# 获取、设置、删除Session中数据request.session['k1']request.session.get('k1',None)request.session['k1'] = 123request.session.setdefault('k1',123) # 存在则不设置del request.session['k1']# 所有 键、值、键值对request.session.keys()request.session.values()request.session.items()request.session.iterkeys()request.session.itervalues()request.session.iteritems()# 用户session的随机字符串request.session.session_key# 将所有Session失效日期小于当前日期的数据删除request.session.clear_expired()# 检查 用户session的随机字符串 在数据库中是否request.session.exists(&quot;session_key&quot;)# 删除当前用户的所有Session数据request.session.delete(&quot;session_key&quot;) 在django中session共有5种方式来存储：数据库、缓存、文件、缓存加数据库、加密cookie，但是都需要我们在settings里面设置，下面就是每种的配置方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344#数据库配置 SESSION_ENGINE = 'django.contrib.sessions.backends.db' # 引擎（默认） SESSION_COOKIE_NAME ＝ &quot;sessionid&quot; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）SESSION_COOKIE_PATH ＝ &quot;/&quot; # Session的cookie保存的路径（默认）SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认）SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认）SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认）SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）（默认）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认）SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认） #缓存配置SESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 引擎SESSION_CACHE_ALIAS = 'default' # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置 SESSION_COOKIE_NAME ＝ &quot;sessionid&quot; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串SESSION_COOKIE_PATH ＝ &quot;/&quot; # Session的cookie保存的路径SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名SESSION_COOKIE_SECURE = False # 是否Https传输cookieSESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存 #文件配置SESSION_ENGINE = 'django.contrib.sessions.backends.file' # 引擎SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() # 如：/var/folders/d3/j9tj0gz93dg06bmwxmhh6_xm0000gn/T SESSION_COOKIE_NAME ＝ &quot;sessionid&quot; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串SESSION_COOKIE_PATH ＝ &quot;/&quot; # Session的cookie保存的路径SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名SESSION_COOKIE_SECURE = False # 是否Https传输cookieSESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存 #缓存加数据库（数据库实现持久化，缓存提高效率）SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db' # 引擎 #加密CookieSESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' # 引擎","link":"/2018/05/03/cookie%E5%92%8Csession/"},{"title":"jieba+whoosh实现简单的商品搜索功能","text":"通过jieba和whoosh对商品数据分词、创建索引，实现一个简单的类似淘宝的商品搜索功能 功能描述实现一个类似淘宝的搜索功能，例如下面这个例子简单点来说我们需要先根据商品名称创建索引，然后再用索引文件匹配去查询字符串来实现商品的搜索，这种搜索是有别于正则匹配的，他会对字符串进行分词处理，准确度也会更高。 准备工作这个项目种主要用到了jieba、whoosh两个库，其中jieba实现对中文的分词处理，whoosh则是创建索引文件。安装依赖： 系统：Ubuntu 16.04 Python版本： 3.5 12pip install jiebapip install whoosh 测试数据：从github上找到的空气净化器的csv数据，需要的可点击下载测试数据 正式开始 创建索引文件首先需要利用whoosh提供的接口对csv中的数据进行处理，生成索引文件。whoosh对中文分词处理不是很好，所以选择jieba实现对中文的分词处理，jieba这个库也有对whoosh的支持，所以处理起来很方便，直接将索引模式中的analyzer更换为jieba的ChineseAnalyzer即可。schema定义了索引的模式，规定了索引的字段信息，其中索引字段包含ID、STROED、KEYWORD、TEXT、NUMERIC、BOOLEAN、DATETIME等几种，具体的含义和使用对象还是去看whoosh的官方文档来的直接，另外schema只需要我们创建一次，然后就会和索引一起被保存。（只需在第一次创建的时候声明schema） 123456789101112131415161718192021222324252627from whoosh.index import create_infrom whoosh.fields import *from jieba.analyse.analyzer import ChineseAnalyzerimport os.pathimport csvdef create_index(): &quot;&quot;&quot; 创建索引文件 :return: None &quot;&quot;&quot; analyzer = ChineseAnalyzer() schema = Schema(id=ID(stored=True, unique=True), content=TEXT(stored=True, analyzer=analyzer)) # 声明索引模式 if not os.path.exists(&quot;index&quot;): # 创建目录 os.mkdir(&quot;index&quot;) ix = create_in(&quot;index&quot;, schema) writer = ix.writer() # csv数据 csv_file = open('goods.csv', 'r') # 读取csv文件 data = csv.reader(csv_file) for i in data: writer.add_document( id=i[3], content=i[0] ) writer.commit() 使用create_in来创建索引文件，以后对索引文件的更删改查都是使用open_dir代开文件。 在读取csv数据的时候，使用add_document来新增索引，其中并不是所有在schema中申明的字段都需要存储的可以为空。最后使用commit实现索引文件的正式写入，这一点和数据库很像。 简单的查询123456789101112131415161718192021222324 from whoosh.index import open_dirfrom whoosh.qparser import QueryParserfrom create_index import create_indeximport os.pathdef search(keyword, limit=10): &quot;&quot;&quot; 按照关键字搜索商品 :param keyword: 商品名称 type: str :param limit: 检索数量 type: int :return: [{'id':'','content':''},{}] type：list &quot;&quot;&quot; if not os.path.exists(&quot;index&quot;): # 查询时没有缩索引文件，需先创建索引文件 create_index() ix = open_dir(&quot;index&quot;) # 读取索引文件 with ix.searcher() as searcher: parser = QueryParser(&quot;content&quot;, schema=ix.schema) keyword = parser.parse(keyword) # 构造查询语句 results = searcher.search(keyword, limit=limit) res = [] for i in results: res.append({'id': i['id'], 'content': i['content']}) print(i['id'], i['content']) print(res) 在查询的时候需要先调用whoosh的QueryParser来构建查询字符串，通过调试我发现在构造查询字符串的时候whoosh默认会分词处理，并且使用AND连接符通过search(keyword,limit)去索引文件中匹配相关信息，其中limit为匹配到的最大数目，默认为10个。 索引的增删改查在一个系统中商品的信息必然不会是一成不变的，所以我们的索引文件就不可避免的需要按照商品信息去做调整，whoosh同样给我们提供了这样的接口。 增：123456789101112131415 from whoosh.index import open_dirdef add_index(name, id): &quot;&quot;&quot; 新增索引 :param name: 商品名称 type: str :param id: 商品id type: str :return: None &quot;&quot;&quot; ix = open_dir(&quot;index&quot;) writer = ix.writer() writer.add_document( id=id, content=name ) writer.commit(optimize=True) 索引的增加和创建索引只有稍许不同，在commit中增加了optimize参数，翻看whoosh的文档在Merging Segments中提到了两个参数分别是merge和optimize，在默认情况下merge为True，意味着whoosh会将多个segments文件合并到一个文件中，如果merge为False的时候我们提交commit的时候会重新生成一个单独的索引文件，多个索引文件不会对搜索的结果产生很大的差异，如果过多的存在索引会降低整体的查询速度。通常情况下使用whoosh的合并算法将多个文件合并到一个文件中会更好，这只会让在更新索引的速度变慢，用户查询的速度影响较小，这样的用户体验会更好。 删: 12345678910111213141516 from whoosh.index import open_dir def add_index(name, id): &quot;&quot;&quot; 新增索引 :param name: 商品名称 type: str :param id: 商品id type: str :return: None &quot;&quot;&quot; ix = open_dir(&quot;index&quot;) writer = ix.writer() writer.add_document( id=id, content=name ) writer.commit(optimize=True) whoosh总共有两种删除方式 delete_by_query(query)：删除与给定查询匹配的所有文档。 delete_by_term(fieldname, termtext)根据字段删除指定的文档，这里的字段需要在创建schema时指定为unique 改12345678910111213141516from whoosh.index import open_dirdef update_index(name, id): &quot;&quot;&quot; 更新索引文件 :param name: 商品名称 type: str :param id: 商品id type: str :return: None &quot;&quot;&quot; ix = open_dir(&quot;index&quot;) writer = ix.writer() writer.update_document( id=id, content=name ) writer.commit() 和删除操作一样索引字段中需要有一个unique 总结 整个功能算是比较简单的了，各种库都给了对应的接口，很够很方便的实现功能。在实现的过程中也遇到了一个问题，最开始在实现增删改查功能的时候使用的事create_in来打开索引文件，这样导致操作完成之后之前的数据被覆盖了，还是自己当初粗心没有仔细看文档导致的。以后要注意这个问题。","link":"/2021/04/17/jieba+whoosh%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"},{"title":"list.sort方法和内置函数sorted","text":"list.sort方法和内置函数sorted的异同 list.sort方法和sorted函数都是对列表进行排序的，但是这两种方法也是有少许不同的，list.sort排序是在原有基础上进行的，不会生成返回一个新的list， 但是sorted函数则不同，他会产生一个新对象并返回。如下 t = [1, 3, 4, 2, 5, 0] t1 = [1, 3, 4, 2, 5, 0] print(t.sort()) print(t) print(sorted(t1)) print(t1) 在同时对t和t1 排序并打印结果，t.sort()返回None sorted(t1) 返回排序好的list，两者都正确，但是只有t的内容发生改变，t1的内容没有改变。 sorted()函数要比list.sort()强大很多，sorted()不仅仅只能将list作为参数传递进去，还可以接收任何形式的可迭代对象作为参数，甚至是不可变序列或者生成器，不管是接收的什么参数sorted()都是返回一个列表。 list.sort()和sorted()都有两个可选的参数： 1. reverse：决定是升序还是降序排列，True为降序，默认值为False 2. key: 一个只有一个参数的函数，这个函数会被用在序列的每一个元素上，通俗来讲就是排序规则，例如对字符串排序的时候可以使用key=str.lower来实现忽略大小的排序，或者是key=len来按照字符串长度排序等等。默认用元素自己的值来排序。 想要在不打乱次序的情况下如何向有序列表中插入数据呢？ 可借助bisect模块来实现，bisect模块主要包含两个函数 ，bisect和insort ，这两个函数都是利用二分查找算法来实现在有序序列中查找或者插入元素的 例如使用bisect来搜索可插入的位置： import bisect t = [123, 3, 234, 1, 423, 5, 25, 235, 325] t.sort() print(bisect.bisect(t, 235)) ### 7 返回值为可插入的位置。前提是传入的参数是有序序列，bisect还有两个可选的参数 lo和 hi即搜索范围，lo默认为0，hi默认为序列长度。 如果有序序列中已存在要插入的元素的时候，又是如何处理的呢！这个就有两种情况，插入到原有元素之前或者之后，分别对应两个方法bisect_left和 bisect_right，而我们之前使用的bisect其实就是bisect_right方法。既然获取的插入位置，那么使用list.insert方法插入即可完成向有序序列插入元素。有没有更简单的方法呢，答案是肯定的，那就是我们之前提到的insort方法。 使用insort插入元素： import bisect t = [123, 3, 234, 1, 423, 5, 25, 235, 325] t.sort() bisect.insort(t, 222) print(t) ### [1, 3, 5, 25, 123, 222, 234, 235, 325, 423] 看了bisect源码之后发现其实insort方法和bisect方法是一样的，只是获取到了插入位置之后紧接着调用insert()方法 insort方法和bisect方法是一样的也是有两个可选参数lo和hi来缩小范围，也分insort_left和insort_right，默认使用的是insort_right方法","link":"/2019/03/07/list.sort%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0sorted/"},{"title":"Odoo","text":"Odoo的配置项 odoo生成配置文件：./odoo-bin -s -c &lt;保存路径&gt; odoo使用指定的配置文件进行加载 ./odoo-bin -c &lt;配置文件的路径&gt; odoo脚手架工具-创建简单的模块 ： ./odoo-bin scaffold module-name save-path odoo的addons路径在命令行中是相对路径，配置文件中为绝对路径 odoo模块的基本文件结构： controllers：网页控制器 demo：测试数据 models：模型结构 security：权限安全相关的文件 ir.model.access.csv：控制访问权限 id：外部标识符 name：描述性标题 model_id：model的名称（对应model的_name值，具体的值为model_+（_name的值，将.更换成_） group_id：指明授权的安全组 perm_read：是否可读 perm_write：是否可写 perm_create：是否可新建 perm_read：是否可删除 views ：视图文件 __init__.py：模块初始化 __manufest__.py: 模块的配置和介绍： name：模块名称 summary：模块副标题 description：模块描述 author：模块作者 category：功能性分类字符串 version：版本号 depends：模块依赖 data：安装或更新时需要加载的模块列表 application：是否在应用列表种以APP形式展现 demo：测试数据的文件路径 一个简单的APP Odoo模块继承 Odoo-模型 模型的属性： _name：我们创建模型的内部标识，必填属性。（一般来说命名规则是以点连接小写单词，模型名必须全局唯一） _description：模型的别称，让用户可以更好的记录，选填属性。 _inherit _inherits _order：设置浏览模型记录或者列表视图时的默认排序，对应SQL语句中的order by的值 _rec_name：指定关联字段引用描述，默认使用name字段。 _table：模型对应数据库中的表名。 _log_access=False：用于设置不自动创建审计追踪的字段：create_uid, create_date, write_uid, write_date. _auto=False： 设置不自动创建模型对应的数据表，这样设置之后可通过init()方法创建数据库对象。 模型的常用字段： Char(string,size,translate,trim)：单行文本，size设置最大长度，translate使字段内容可翻译，trim默认为True去除空格 Text(string)：多行文本 Selection(selection, string)：下拉选项，选项参数为元组列表第一个元素是数据库存储的值，第二个值为界面的显示内容。 Html(string)：针对HTML内容的特殊处理。 Integer(string)：整数类型 Float(string,digits)：浮点型，digits指定字段的精度，是一个元组(x,y)，x为总长度，y为小数位。 Monetary(string,currency_field)：货币类型，与浮点型类似，currency_field用于存储使用的货币种类，默认使用currency_id字段。 Date(string)：日期字段（没有时分秒） Datetime(string)：日期字段（包含时分秒信息） Boolean(string)：bool类型，只能为True和False Binary(string)：存储二进制数据。 字段的常见属性： string：字段的标签名，会在页面中显示，如果不设置默认使用字段名 default：设置字段的默认值，可以是具体值，也可以是调用、引用、函数、匿名函数等 help：界面中鼠标悬停时的提示文本 readonly=True：在界面中不可编辑 required=True：使字段为必填的不可为空值 index=True：建立索引 copy=False：使用ORM的copy方法时忽略该字段 groups：限制字段仅对一些组可见，值为逗号分隔的安全组XML ID列表 states: deprecated=True：字段在被使用的时候会记录一条warning日志 oldname 特殊的字段： Odoo的ORM保留字段，除id字段外，下面的字段只要在模型中没有设置_log_access=False都会自动创建。 create_uid：创建记录的用户 create_date：创建记录的时间 write_uid：最后写入记录的用户 write_date：最后写入记录的日期 name(Char类型)：默认作为记录的显示名称 active(Boolean类型)：允许是否关闭记录 state(Selection类型)：记录生命周期的基本状态，允许使用states字段属性来根据记录状态以具备不同的UI行为 parent_id(Integer类型)：父子层级关系 parent_path(Char类型)：父子层级关系 模型间的关系 以图书、出版社、作者为例。 many-to-one: many-to-one关联是对其他模型记录的引用，基本的使用： 1publisher_id = fields.Many2one('res.partner', string='Publisher') 第一个位置参数是关联模型（comodel关键字参数），第二个位置参数为字段标签（string关键字参数） ondelete关键字参数：定义关联记录被删除时的操作： set nulll(默认值)：关联字段被删除时置为空 restricted：抛出错误阻止删除 cascade：关联记录被删除的时候同时删除当前记录 context： domain： auto_join=True：允许ORM在使用关联进行搜索的时候使用SQL连接，使用时会跳过访问安全规则，用户可以访问安全规则不允许访问的关联记录，可以加快SQL的查询效率。 delegate=True：创建一个关联记录的代理继承，使用时必须设置required=True和ondelete=cascade one-to-many:one-to-many关联是many-to-one的反向关联1234published_book_ids = fields.One2many( 'library.book', 'publisher_id', string='Published Books') 三个参数分别是关联模型、被引用的字段名、字段标签，其他的参数和many-to-one相同，（context、domain、ondelete只用于关联中的many一方） many-to-many：在两端都存在to-many关联的时候就可以使用many-to-many关联：1234# Book modelauthor_ids = fields.Many2many('res.partner',string=&quot;Authors&quot;)# Partner modelbook_ids = fields.Many2many('library.book', string='Authored Books') Many2many最少要包含一个关联模型位置参数（comodel_name关键字参数），在数据库层面上many-to-many关联不会在已有的表中添加任何列，而是自动创建一个关联表来存储记录间的关联，和django的多对多一样的关联表中仅有两个ID字段，为两张关联表的外键，默认的关联表名由两个表名中间加下划线并在最后加上\\_rel组成在默认情况下有可能会出现表名长度过长，超出Postgresql数据库63个字符的上限，这时候我们可以选择手动模式，指定关联表使用手动方式设置关联表1234567891011121314# 使用位置参数的方式：author_ids = fields.Many2many( 'res.partner', # 关联模型（必填） 'library_book_res_partner_rel', # 要使用的关联表名 'a_id', # 本记录关联表字段 'p_id', # 关联记录关联表字段 'Authors') # string标签文本# 使用关键字参数的方式：author_ids = fields.Many2many( comodel_name='res.partner', # 关联模型(必填) relation='library_book_res_partner_rel', # 关联表名 column1='a_id', # 本记录关联表字段 column2='p_id', # 关联记录关联表字段 string='Authors') # string标签文本 使用引用字段的弹性关联： 普通关联字段指定固定的引用模型，但是Reference字段可不受限，支持弹性关联，例如： 1234highlighted_id = fields.Reference( [('library.book',Book),('res.partner','Author')] , # [(model, id),()] 'Category Highlight') 用户可以在操作界面中选择模型，然后选择模型中的记录 计算字段： 字段值除了普通的读取数据库存储外，还可以实现函数计算，计算字段和普通的字段相似，只是增加了一个额外的compute参数来定义用于计算的函数 12345678publisher_country_id = fields.Many2many( 'res.country', string=&quot;publisher Country&quot;, compute='_compute_publisher_country')@api.depends('publisher_id.country_id')def _compute_publisher_country(self): for book in self: book.publisher_country_id = book.publisher_id.country_id compute的值为定义的计算函数名，如果计算函数需要使用其他字段就需要使用@api.depends装饰器，参数为一个或多个字段名。 搜索和写入计算字段上面简单的例子只能读取，还不能搜索和写入，默认情况下计算字段是实时计算，不会存储到数据库中，如果需要写入数据库可以通过现实特殊的方法来开启搜索和写入的操作，计算字段可预compute方法一起设置实现搜索逻辑的search方法，以及实现写入逻辑的inverse方法，例如：12345678910111213publisher_country_id = fields.Many2many( 'res.country', string='Publisher Country', compute = '_compute_publish_country', inverser = '_inverser_publish_country', search = '_serach_publish_country')def _inverse_publisher_country(self): for book in self: book.publisher_id.country_id = book.publisher_country_id def _search_publisher_country(self, opearator, value): return [('publisher_id.country_id', operator, value)] 计算字段的写入是计算的反向逻辑 存储计算字段： 通过在定义时设置store=True还可以将计算字段值保存到数据库中。在任意依赖变更时值就会重新计算。因为值已被存储，所以可以像普通字段一样被搜索，也就不需要使用search方法了。 关联字段： 创建关联字段的时候，我们像普通计算字段一样声明一个所需字段类型，使用related属性设置用点号标记链来使用所需的字段，可以使用引用字段来获取与上例publisher_country_id计算字段相同的效果： 1234publisher_country_id = fields.Many2one( 'res.country', string='Publisher Country', related='publisher_id.country_id', ) 本质上关联字段仅仅是快捷实现search和inverse方法的计算字段。也就是说可以直接对其进行搜索和写入，而无需书写额外的代码。默认关联字段是只读的，因inverse写操作不可用，可通过readonly=False字段属性来开启写操作。 模型约束： SQL模型约束：SQL约束加在数据表定义中，并由Postgresql直接执行，使用_sql_constraints类属性来定义，值一般是一个由元组组成的列表，每个元组格式为(name,code,error): name:约束标识名 code:SQL语句 error:是在约束验证为通过时向用户显示的错误信息12345678_sql_constraints = [ ('library_book_name_date_uq', # 约束唯一标识符 'UNIQUE (name, date_published)', # 约束 SQL 语法 'Book title and publication date must be unique'), # 消息 ('library_book_check_date', 'CHECK (date_published &lt;= current_date)', 'Publication date must not be in the future.'), ] Python模型约束：Python约束可以自定义代码来检查条件。检查方法应添加@api.constrains装饰器，并且包含要检查的字段列表，其中任意字段被修改就会触发验证，并且在未满足条件时抛出异常。12345@api.constrains('isbn')def _constrain_isbn_valid(self): for book in self: if book.isbn and not book._check_isbn(): raise ValidationError('%s is an invalid ISBN' % book.isbn) base模型 Odoo自带有base插件，提供了Odoo应用所需的基本功能，base模块中包含两类模型： ir模型：信息仓库，存储Odoo所需的数据 ir.actions.act_window：用于窗口操作 ir.ui.menu：用于菜单选项 ir.ui.view：用于视图 ir.model：用于模型 ir.model.fields：用于模型字段 ir.model.data：用于XML ID res模型：资源，包含基本数据 res.partner：用于业务伙伴，如客户、供应商和地址等等 res.company：用于公司数据 res.currency：用于货币 res.country：用于国家 res.users：用于应用用户 res.groups：用于应用安全组 使用模型数据 shell命令行工具：./odoo-bin shell -d dbname 环境属性： env.cr：正在使用的数据库游标 env.user： 当前用户的记录 env.uid：会话用户ID，与env.user.id相同 env.context：会话上下文的不可变字典 环境提供了对所有已安装模型注册表的访问，如self.env[‘res.partent’]返回一条对partner模型的引用，然后可以使用search()或browse()方法来获取记录集。 环境上下文：环境上下文是一个带有会话数据的字典，用于客户端用户界面以及ORM和业务逻辑中，在客户端中可以把信息从一个视图带到另一个视图，在服务器端中一些记录集的值会依赖与上下文提供多的本地化设置，也可为服务端代码提供信号。 修改记录集执行环境：记录集执行环境是不可变的，如果想要修改可以创建一个变更环境并使用它来执行操作。 业务逻辑的处理 其他问题 增加字段出现问题修改类似与res.partner这种基础表的结构需要先使用命令更新数据库方可运行 1./odoo-bin -d database_name -u module_name 第一次运行使用命令 1./odoo-bin --addons-path=addons,./odoo/addons --ddatabase=scm_erp -i base 创建模块 1./odoo-bin scaffold purchase_separate my_addons odoo的api修饰符 @api.returns @api.one：自动遍历记录集，self会变成当前的记录集（类似于一个for循环的遍历） @api.multi：不遍历，self保持为当前的记录集 @api.model：将旧的API函数转换为带有新API函数，使得代码可以平滑迁移 @api.constrains：被修饰函数会在create、write、unlink时被调用 @api.depends：添加依赖字段 @api.onchange @api.noguess","link":"/2021/04/07/odoo/"},{"title":"virtualenv和virtualenvwrapper的安装和使用","text":"virtualenv可以让用户创建独立的python环境，每个环境互不干扰。virtualenvwrapper则可以让我们更方便的管理每个环境。 1：安装virtualenv 和 virtualenvwrapper pip install virtualenv pip installvirtualenvwrapper 2：配置virtualenvwrapper环境 打开/etc目录，找到bash.bashrc 使用vim 打开 ，在最后加入 保存退出，使用source bash.bashrc命令就完成了 安装完成后我们可以使用 常用的几个命令","link":"/2018/03/09/virtualenv%E5%92%8Cvirtualenvwrapper%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"从零开始搭建物联网平台（10）：微信登录和用户绑定","text":"微信小程序不支持Cookie的，所以为了保存用户登录状态就必须换一个方式实现，这里采用jwt的方式，关于jwt简单来说就是第一次登录验证成功后对想要保存的信息进行加密，然后将加密过后的内容返回给前端，前端每次请求的时候都携带上这个token，后端拿到token后对其解密就能获取之前保存的信息了。 整体流程： 这里先看一下小程序官方给的登录流程，这只是最基础的流程，根据设计需要我们还需要添加自己的逻辑进去 下面是具体的流程图，接下来会根据这个流程图具体看看小程序端和后端应该怎么实现。 小程序的具体实现 以index页面为起始页面，当页面进行加载的时候会调用onload函数，所以可以在onload函数中检测storage中是否有jwt onLoad: function() { // 获取本地的jwt，如果有则跳转到home页面，否则重新获取jwt wx.getStorage({ key: 'jwt', success: function(res) { wx.switchTab({ url: '../home/home' }) }, }) }, 如果没有找到jwt，这是会调用登录函数从后端获取jwt //用户登录 let login = function(code) { wx.request({ url: login_url, method: 'post', data: { 'code': code }, success(res) { // 登录成功 if (res.data.code === 0) { // 将后台返回的jwt写入storage中保存 // 这里要使用同步的方法，避免异步请求的时候没有token wx.setStorageSync('jwt', res.data.data) // 跳回主页 wx.switchTab({ url: '../home/home' }) } // 登录失败没有找到绑定的信息，跳转到绑定页面 else { wx.navigateTo({ url: '../bind/bind', }) } }, fail(res) { wx.showToast({ title: '服务器错误，登录失败！', duration: 1000, icon: 'none', }) } }) } 在bind页面中，需要填写我们的账户信息，这里使用了小程序的form、input组件，需要对password进行MD5加密处理后再提交输入的内容，后端会验证用户名和密码，如果成功后会将获取到的openID和这个用户绑定，并生成jwt。 //用户绑定 let bind = function(username, password) { var password = md5(password) //重新获取code避免长时间code失效 wx.login({ success: res =&gt; { wx.request({ url: bind_url, method: 'POST', data: { 'username': username, 'password': password, 'code': res.code }, success(res) { // 绑定成功 if (res.data.code === 0) { // 将后台返回的jwt写入storage中保存 // 这里要使用同步的方法，避免异步请求的时候没有token wx.setStorageSync('jwt', res.data.data) // 跳回主页 wx.switchTab({ url: '../home/home' }) } else { wx.showToast({ title: res.data.msg, duration: 1000, icon: 'none', }) } }, fail(res) { wx.showToast({ title: '服务器错误，绑定失败！', duration: 1000, icon: 'none', }) } }) } }) } 注册页面和绑定页面逻辑基本类似就不在此多说了 后端的具体实现 这里使用了PyJWT去生成jwt和解码jwtopenid的获取，下面官方对请求参数的要求 def get_openid(code): \"\"\" 获取微信的openID :param code: :return: openid \"\"\" # 构建请求参数 payload = {'appid': settings.WX_APPID, 'secret': settings.WX_SECRET, 'js_code': code, 'grant_type': 'authorization_code'} # 请求微信接口，获取用户的openID recv = requests.get(\"https://api.weixin.qq.com/sns/jscode2session\", params=payload) if recv.status_code == 200: recv = json.loads(recv.text) return recv['openid'] else: return '' 用户登录接口： def post(request): \"\"\" 微信端登录 :param request: data{ code } :return: {'code': 0, 'msg': '', 'data': jwt} \"\"\" res = {'code': 0, 'msg': '', 'data': ''} try: code = request.data.get('code') if code: openid = get_openid(code) # 通过openID查找用户信息 user_obj = UserInfo.objects.filter(wx=openid).first() # 找到用户后生成 if user_obj: # 生成jwt并返回 res['data'] = create_jwt.create_jwt(user_id=user_obj.uid) # 没有查找到对应用户提示先进行绑定 else: res['code'] = 1001 res['msg'] = '请先绑定微信' else: res['code'] = 1002 res['msg'] = '登录失败' except Exception : res['code'] = 1003 res['msg'] = '登录失败' return JsonResponse(res) 用户绑定接口： def post(request): \"\"\" 绑定微信 :param request: data{username, password, code} :return: {'code': 0, 'msg': '', 'data': jwt} \"\"\" res = {'code': 0, 'msg': '', 'data': ''} try: print(request.data) code = request.data.get('code') openid = get_openid(code) # 获取openID data = request.data.copy() data['openid'] = openid # 表单验证 login_form = LoginForm(data) # 验证失败 if not login_form.is_valid(): res['code'] = 1 for i, error in login_form.errors.items(): res['msg'] = error[0] # 验证成功，生成jwt并返回给客户端 else: res['data'] = create_jwt.create_jwt(user_id = login_form.cleaned_data.get('uid')) except Exception: res['code'] = 1 res['msg'] = '绑定失败' return JsonResponse(res) 至此这个微信小程序的登录和绑定基本完成了，下面是绑定、注册页面效果图","link":"/2019/03/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%91%E5%AE%9A/"},{"title":"从零开始搭建物联网平台（1）：开篇","text":"前言： 读大学的时候学的是物联网工程，大概是在大二的时候开始接触单片机，那时候特喜欢捣鼓那些东西，就觉得特别酷有极客范。还记得第一次做物联网相关的是一个远程控制的开关，第一次调通的时候真的很兴奋，啥也没干就挂在那用手机控制继电器听咔嗒咔哒的声音，现在想想真的好小儿科，明明只是按照人家的教程改改代码却也能兴奋那么就。但是有一句话不是说所有的编程语言第一个代码都是Hello World，一切都要从最基础的开始，当我们有能力的时候才能做更大的事。 言归正传，之前也用过一些很成熟的物联网平台例如移动的OneNET、 Yeelink，做的都很好功能也很强大，我也做过一些扩展功能，例如那时候OneNET是没有手机端的，于是就根据OneNET提供的API实现了微信公众号的访问和控制（最开始的几篇博客有介绍），可是觉得这些一点也不极客，无非是在调用API。搭建一个个人的物联网平台这个想法很久之前就有了，只是一直迟迟未开始，现在我觉得是时候开始着手实现这个想法了。关于这个物联网平台我的想法是够用就好，也许它很简单，功能有点low，设计不合理等等，毕竟是我自己做出来的，开心就好【手动滑稽】，当然呢我也会尽力去完善。立一个Flag半年之内完成。 最后也是最重要的一点，这不是一个教程，只是我个人的一些开发记录，里面可能会有很多漏洞，不合理的地方，而且之前的操作可能会在后面给推翻重做，所以啊，参考就行了不要当真。 整体构思： 图画的有点low不要介意，简单说一下 硬件：这里选择Arduino平台开发，之所以不先考虑stm32或者51之类的，是因为那两个我都没完整的了解过，等以后会提供更多的连接例程，目前手上现有一个NodeMCU、和一个ArduinoMEGA2560，考虑到Arduino和ESP8266连线太麻烦了，就以NodeMCU为例。 平台：协议就使用MQTT好了，后台用Django，数据库MySQL。 手机：还是借助微信公众号之前也有一些经验，最主要的是APP开发不会。 电脑：应该会和OneNET类似，前端大概率会用vue开发，这个应该会放到最后实现，vue还在学习阶段。 大致功能包括： 用户注册、添加设备、上传数据、查看历史数据、发送控制指令、微信提醒，目前想到的就只有这么多了，以后还有新的再来添加。 更新一下： 项目差不多完成了75%左右，在制作过程中对原有的一些设计做了优化和调整目前项目的整个架构图如下","link":"/2018/11/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%BC%80%E7%AF%87/"},{"title":"从零开始搭建物联网平台（2）：MQTT服务的搭建","text":"EMQ： 现有的MQTT服务器有很多，例如Mosquitto、Apache-Apollo、EMQ等等，最后呢选择了EMQ毕，国内公司的开源产品，中文资料相对要多一些。EMQ的官网宣称是百万级分布式开源物联网MQTT消息服务器，百不百万倒无所谓，反正是给自用的没有那么多的数据产生。 安装： 服务器系统版本为Ubuntu14.04，首先在EMQ官网下载对应的安装包http://emqtt.com/downloads/latest/ubuntu14_04-deb，进入目录 输入命令：sudo dpkg -i emqttd-ubuntu16.04_v2.0_amd64.deb进行安装。按照官方的说明完成上述操作之后还需要安装依赖lksctp-tools库apt-get install lksctp-tools。至此MQTT服务已经搭建好了，但是还需要一些配置方可使用。 配置： EMQ提供了Web 管理控制台，默认是开启的，URL 地址: http://localhost:18083 ，缺省用户名/密码: admin/public。登陆成功之后就能可查询 EMQ 消息服务器基本信息、统计数据、度量数据，查询系统客户端(Client)、会话(Session)、主题(Topic)、订阅(Subscription)，以及对插件的管理。 插件里面我觉得最重要的应该是认证插件，当然了是可以不需要认证功能的，但是呢安全性和规范性还是需要认证功能的，EMQ提供了很种方式的认证功能，我选择MySQL认证访问插件。 进入到插件管理页面，打开MySQL配置，第一步填写 MySQL数据库的相关信息，还需要注意一下要把加密方式给去掉，这样连接的时候要方便一些。完成这些配置之后要到MySQL对应的数据库创建用户和访问控制表： CREATE TABLE `mqtt_user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(100) DEFAULT NULL, `password` varchar(100) DEFAULT NULL, `salt` varchar(35) DEFAULT NULL, `is_superuser` tinyint(1) DEFAULT 0, `created` datetime DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `mqtt_username` (`username`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; CREATE TABLE `mqtt_acl` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `allow` int(1) DEFAULT NULL COMMENT '0: deny, 1: allow', `ipaddr` varchar(60) DEFAULT NULL COMMENT 'IpAddress', `username` varchar(100) DEFAULT NULL COMMENT 'Username', `clientid` varchar(100) DEFAULT NULL COMMENT 'ClientId', `access` int(2) NOT NULL COMMENT '1: subscribe, 2: publish, 3: pubsub', `topic` varchar(100) NOT NULL DEFAULT '' COMMENT 'Topic Filter', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO `mqtt_acl` (`id`, `allow`, `ipaddr`, `username`, `clientid`, `access`, `topic`) VALUES (1,1,NULL,'$all',NULL,2,'#'), (2,0,NULL,'$all',NULL,1,'$SYS/#'), (3,0,NULL,'$all',NULL,1,'eq #'), (5,1,'127.0.0.1',NULL,NULL,2,'$SYS/#'), (6,1,'127.0.0.1',NULL,NULL,2,'#'), (7,1,NULL,'dashboard',NULL,1,'$SYS/#'); 为了测试方便先在用户表里面插入一个测试账户信息，例如username：admin 、password：123456，至此认证功能基本上配置好了。 测试： 现在还没有完成硬件部分的设计，只能通过EMQ提供的Websocket工具来测试连通性，打开websocket页面，填写好之前在用户表里面的账户和密码，点击连接测试能否连接成功，如果成功了那么整个MQTT服务的搭建也就顺利完成了。","link":"/2018/11/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%EF%BC%882%EF%BC%89%EF%BC%9AMQTT%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"title":"从零开始搭建物联网平台（3）：硬件部分的连接测试","text":"搭建开发环境： 在开篇的时候就说过硬件部分会使用Arduino平台和NodeMCU，只是Arduino平台不能直接对NodeMCU进开发，正好换电脑了也需要重新安装一遍，就顺便说一下。 首先下载ArduinoIDE安装包官网太慢可以用这个链接：Arduino 1.8.7我使用的版本是1.8.7，安装完成之后进入到首选项在附加开发板管理器网址处填写：http://arduino.esp8266.com/stable/package_esp8266com_index.json 填写完成之后关闭重启，在工具→开发板→开发板管理器中搜索ESP8266，下载安装，这一步可能会比较慢要等待一段时间。 开发板添加完成之后，再次打开开发板会多出很多型号的开发板，其中就包括我们使用的NodeMCU，关于0.9和1.0两个暂时不知道有什么区别，应该是使用的ESP芯片型号的不同，目前来说选这两个中的任意一个都没有问题。至此NodeMCU开发环境搭建完成了。 连接测试： 物联网协议采用的是MQTT，本着不造轮子的原则，先看一下有没有对应的库可以使用，在项目→加载库→管理库搜索MQTT，会出现一大堆各种各样的库，根据使用的广泛程度最后选择PubSubClient，点击安装。 安装成功后，在文件→示例中可以找到PubSubClient的一些使用例程，选择mqtt_esp8266打开，这个就是需要用到的测试代码。 当然呢，代码需要简单的修改一下才可以使用，不出意外按照下面的修改应该是能连接成功的。点击上传等到代码烧录到NodeMCU中。 //分别填写WIFI名、密码、mqtt服务器IP const char* ssid = \"........\"; const char* password = \"........\"; const char* mqtt_server = \"broker.mqtt-dashboard.com\"; //由于我们之前mqtt服务器开启了认证功能，这里连接的时候还需要携带用户名和密码 //大概在95行附近 if (client.connect(\"NodeMCU\",\"admin\",\"123456\")) { //如果返回值为4需要检查一下用户名和密码是否正确 打开串口监视器，如果连接成功会得到下图信息。如果有错根据返回码去查看MQTT连接返回码对应什么问题在一步一步排查。至此硬件于MQTT服务器的连接测试完成，接下来应该会是后台的搭建，也是最困难的一步了。","link":"/2018/11/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E9%83%A8%E5%88%86%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95/"},{"title":"从零开始搭建物联网平台（4）：订阅系统主题获取设备上下线消息","text":"$SYS-系统主题 先来看一段EMQ对于系统主题的介绍：EMQ 消息服务器周期性发布自身运行状态、MQTT 协议统计、客户端上下线状态到 $SYS/ 开头系统主题。$SYS 主题路径以 “$SYS/brokers/{node}/” 开头，’${node}’ 是 Erlang 节点名称 系统主题主要包括一下几大部分： 1 ：服务器版本、启动时间与描述消息 2 ：MQTT 客户端上下线状态消息 3 ：系统统计消息 详细的介绍请看EMQ官方文档：http://www.emqtt.com/docs/v2/guide.html#sys，就目前来说呢好像只有上下线状态有点用，另外两个以后要是用到了在详细说明。 客户端上下线状态消息的$SYS 主题前缀为: $SYS/brokers/${node}/clients/，可选择具体客户端${clientid}/connected的上下线消息，也可以选择所有设备的上下线消息：#，这里选择接收说有设备的上下线消息，那么需要订阅的主题为$SYS/brokers/emq@127.0.0.1/clients/# 修改访问控制规则 EMQ默认情况下只有本地的dashboard才能订阅系统消息，因此还需要对EMQ配置做一些修改。方法很简单，以linux系统为例，首先进入到/etc/emqttd/目录下，找到acl.conf文件， 使用vim打开编辑 在文本末尾增加{allow, all, subscribe, [\"$SYS/brokers/+/clients/#\"]}. 这一行的意思就是允许所有设备订阅$SYS/brokers/+/clients/#主题，也就是所有设备都能获取到其他设备的上下线消息，这里只是为了测试方便，以后为了安全考虑这部分可能会做出修改，保存退出，使用emqttd restart命令重启mqtt服务，至此控制访问规则的编辑完成。 测试代码 这里我使用python进行编写，用的了paho-mqtt库实现mqtt通信，因为代码不是很复杂，暂时先不展看说明paho-mqtt的使用。通过订阅$SYS/brokers/emq@127.0.0.1/clients/#主题即可接收到其他设备上下线的消息 import paho.mqtt.client as mqtt def on_connect(client, userdata, flags, rc): print(\"Connected with result code \" + str(rc)) client.subscribe(\"$SYS/brokers/emq@127.0.0.1/clients/#\") def on_message(client, userdata, msg): print(msg.topic + \" \" + str(msg.payload)) client = mqtt.Client(client_id='python_test') client.username_pw_set('*****', '*****') # 设置连接用户名 client.on_connect = on_connect client.on_message = on_message client.connect(\"your ip address\", 1883, 60) client.loop_forever() 运行这段代码，然后呢使用EMQ提供的websocket方式新建一个连接然后断开，看一下在控制台是否能够接收到上下线消息。如果成功将收到分别是上线和下线两条消息，不成功的话那就先在Dashboard的订阅页面查看是否成功订阅了系统消息。","link":"/2018/11/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E8%AE%A2%E9%98%85%E7%B3%BB%E7%BB%9F%E4%B8%BB%E9%A2%98%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%B8%8B%E7%BA%BF%E6%B6%88%E6%81%AF/"},{"title":"从零开始搭建物联网平台（5）：搭建后台服务(一）","text":"数据库的设计： 后台使用Django web框架实现，Django和python怎么用就不介绍了，东西太多了，看完下面的这些博客就可以了，差不多就够了https://www.cnblogs.com/wupeiqi/articles/4938499.html 数据库设计： 我是这样想的，首先会有一个主账户，也是登陆网站的账户，其下可创建设备，每个设备又都可以创建不同的数据流，数据流由设备publish的主题来区分，数据流又由设备发送过来的一个一个的数据点组成，这样一来共需要4张表存放信息，每张表又和下一级一对多的关系。 使用Django models创建表结构，代码先不放上来因为后期可能会不断的调整，等项目整个完成之后再开源出来。对应的ER图如下 EMQ的MySQL插件配置： 之前我们使用MySQL认证的时候使用的是官方给的示例数据库结构，现在为了和后台服务整合到一起还需要再次修改，首先打开dashboard的MySQL插件配置，只需要对两处进行修改，第一处修改认证使用的数据库，第二处修改认证的查询语句。示例：select password from website_userinfo where user_id = '%u' limit 1，修改完成后保存退出，重启插件。 连接验证： 在连接之前需要先在数据库里面创建一些伪造数据，在website_userinfo里面插入user_id=678518606，password=123然后使用EMQ的websocket连接测试，连接成功则上述的修改完成。","link":"/2018/11/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1(%E4%B8%80%EF%BC%89/"},{"title":"从零开始搭建物联网平台（6）：消息的持久化","text":"遇到的问题： 查看了EMQ文档发现并不提供消息的持久化功能，MQTT协议是按照设备一直在线设计的，数据都是保存在内存里的，但是考虑到用户上传传感器数据不可能接收了就扔掉，那样就没法查看历史数据了，所以用户上传的消息必须要能够保存下来，以便查看历史数据，这样一来持久化功能就需要我们自己来实现。 另外还会出现一个问题，当两个设备注册的主题名一样的时候，不能分出是哪一个设备发出的消息，在接收订阅消息的时候发现没办法获取到发送消息的clientID，而且其他设备也可以订阅到任意设备的消息，对于敏感信息来说存在安全性。 解决方法： 初步打算是，用户需要在后台注册自己的设备和数据流信息，后台会对所有注册的信息进行订阅接收到消息后，后台会把消息写入到对应的表中，另外设备发布主题只能使用（clientID/主题名）命名方式，以便后台能够区分是哪一个设备发送过来的消息。对于MQTT了解还是不够深，只能使用这样的笨办法来解决了，以后若是找到其他的方法在进行改进。 解决问题： 首先需要通过python建立mqtt连接监听所有注册的主题信息，这里使用了paho-mqtt库来实现，为了方便以后的调用将其封装成一个类，最开始的时候想把一些常用的操作也封装进去，单独测试完全可以，但是一旦放到Django请求中处理的时候，mqtt能够正常返回成功信息，但是实际上并没有正确执行，这一点始终没有找到原因，最终只能简化，只包含最基础的功能。 class MqClient(object): def __init__(self, client_id, username, password): self.client = client.Client(client_id=client_id, clean_session=True) # 初始化,clean_session为false的时候EMQ会保存订阅状态，可以不再次订阅 self.client.username_pw_set(username, password) # 设置连接用户名 self.client.on_connect = self.on_connect self.client.on_message = self.on_message self._client_status = False # 连接状态 self._cloop = None self._connect() # 实例化会自动连接 def _connect(self, host=\"your IP \", port=1883, keepalive=60): \"\"\"连接服务器\"\"\" self.client.connect_async(host, port, keepalive) # 开启线程执行 self._cloop = threading.Thread(target=self.client.loop_start()) self._cloop.start() def on_connect(self, client, userdata, flags, rc): \"\"\"连接成功的回调函数\"\"\" # 修改客户端状态 if rc == 0: self._client_status = True def init_sub(self): # 读取数据库中所有的已经注册过的topic并且订阅 for i in models.Device.objects.all(): for j in i.dev_stream.all(): self.client.subscribe(str(i.device_id) + '/' + j.name, j.qos) @staticmethod def on_message(client, userdata, msg): client_id = msg.topic.split('/')[0] stream = msg.topic.split('/')[1] data = msg.payload.decode() # 接收订阅信息写入到数据库中 models.DataStream.objects.filter(device__device_id=client_id).filter(name=stream).first().data.add( models.Data.objects.create(data=data)) 有了封装好的类，现在我们需要做的是：在Django项目启动完成之后自动执行监听任务的，最开始的时候打算放到setting或者__init__里面，但是因为类里面封装了model操作，那时候项目还没有加载完model会报错，所以最终新建了一个app，然后放到其下的urls，这样当项目启动完成的时候就会自动加载了。 from utils.mqtt_client import MqClient MQClient = MqClient(your client ID, username, password) MQClient.init_sub() 接下来测试一下实时新增订阅的功能，先从urls文件导入示例化之后的对象，调用client的subscribe方法 from mqtt.urls import MQClient class Test(APIView): def post(self, request): topic = request.POST.get('topic') qos = int(request.POST.get('qos')) if topic: MQClient.client.subscribe(topic,qos) return HttpResponse(\"ok\") 最后就剩下把数据存入数据库中了，这个操作已经写在那个类中了。简单说明一下 ，当paho接收了mqtt请求的时候会产生一个回调，执行下面这个函数，接收到的类容包含在msg中，msg主要有topic和payload两个属性，topic是订阅的主题名，payload则是具体的消息内容，按照之前的规定，主题名为client/stream，对topic内容拆分获取到client_id和stream，最后就是数据库的插入操作了，涉及到多表操作，简单点说就是，先插入一个data数据，然后根据client_id和stream来确定stream，最后再通过add方法将两者关联起来，这样就完成了消息的保存了。 def on_message(client, userdata, msg): client_id = msg.topic.split('/')[0] stream = msg.topic.split('/')[1] data = msg.payload.decode() # 接收订阅信息写入到数据库中 models.DataStream.objects.filter(device__device_id=client_id).filter(name=stream).first().data.add( models.Data.objects.create(data=data)) 测试一下，数据库里面已经准备一些client和stream数据，还是使用EMQ的websocket来测试，发送主题为123456/hum，消息内容为654321，在来看一下数据库中数据是否插入成功。 data表 stream表 stream和data关联表 更新： 最终对这一部分做了修改，没有将MQTT相关的东西放到Django里面，独立出来了，这样也方便日后的扩展和管理，数据库操作改用了sqlachemy实现，其他内容基本不变","link":"/2018/11/07/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E6%B6%88%E6%81%AF%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"},{"title":"从零开始搭建物联网平台（7）：使用Vue编写前端页面","text":"摘要： Vue我也是刚开始学的，看了两天的文档就开始着手做这件事了，所以对vue了解不太深入，没有能力说的的太详细万一是错误的不就误导别人了，所以只对几个相对来说比较主要的点说明一下。 搭建开发环境： 老生常谈的话题！首先自然是要安装nodejs，这个直接去官网下载安装即可，再使用命令npm install vue、npm install -g vue-cli去安装vue和脚手架工具，完成之后再使用命令vue init webpack myproject来初始化项目，初始化完成之后会在目录下生成这些文件，到这一步的话环境差不多搭建好了。 接下来是安装依赖，在这个项目里面我用了以下几个库， 通过命令npm install xxx --S 安装，环境差不多搭建完成。 \"axios\": \"^0.18.0\", 发送请求的类似ajax \"echarts\": \"^4.2.0-rc.2\", 可视化工具，用于绘制数据曲线图 \"element-ui\": \"^2.4.9\", 网页UI \"vue-router\": \"^3.0.1\", 路由，这个一般在初始化项目的时候就安装了，如果没有自己手动安装 开始我们的开发之旅： 首先确定一下页面布局，分为三大块，其中顶栏和侧栏显示内容不变，只变主题部分，布局样式使用elementUI中的&lt;el-header&gt;：顶栏容器， &lt;el-aside&gt;：侧边栏容器，&lt;el-main&gt;：主要区域容器实现。 顶栏基本没啥内容就一个图标不说了，说一下侧边导航栏，导航栏使用el-menu组件实现，将el-menu的 route属性设置为true，或者使用router-link去做跳转，不过那样显得要麻烦一些，所以还是推荐第一种 &lt;el-menu class=\"el-menu-vertical-demo\" background-color=\"#304156\" text-color=\"#bfcbd9\" active-text-color=\"#409eff\" :default-active=\"$route.path\" router &gt; &lt;el-menu-item index=\"/developer/dashboard\"&gt; &lt;i class=\"el-icon-ump-18\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;主页&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"/developer/charts\"&gt; &lt;i class=\"el-icon-ump-shuju2\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;历史数据&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"/developer/devices\"&gt; &lt;i class=\"el-icon-ump-shebei2\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;设备管理&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"/developer/streams\"&gt; &lt;i class=\"el-icon-ump-shuju1\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;数据流管理&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"/developer/triggers\"&gt; &lt;i class=\"el-icon-ump-chufaqi\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;触发器管理&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"/developer/console\"&gt; &lt;i class=\"el-icon-ump-kongzhitai1\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;控制台&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; 最后的效果： 下面开始内容主体，放个样图。 样式部分就不说了看个人喜好，主要说一下如何获取后台的数据，数据的获取需要用到之前安装的axios插件，通过axios的get、post等方法访问后端的接口获取json数据例如get方法，then和catch是es6的语法，具体的我也解释明白。如果数据获取正常，后端返回的数据放在res.data里面，打印到控制台看看返回结果，post同理，只是参数不同 axios.get(url, { params: { 'key': 'value' } }).then((res)=&gt; { console.log(res.data); }).catch((error)=&gt; { console.log(error); }); 一般来说获取数据可以放在created()或者mounted()里面，看自己需求吧，created要先于mounted，created那时候还没有生成dom，如果需要操作dom那么还是放到mounted里面吧。 算了就写这么多吧，自己都不专业还是不误导别人了","link":"/2018/11/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8Vue%E7%BC%96%E5%86%99%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"},{"title":"从零开始搭建物联网平台（8）：邮箱通知服务","text":"关于触发器的通知，最开始有三种打算 微信公众号、 邮箱、 HTTP，最后发现微信公众号平台无法主动向用户推送消息，所以微信公众号暂时不做了，看看有没有其他的解决方案 搭建SMTP服务 发送邮件可以借助第三方平台如163、QQ等等，但是使用个人账户去做都是有最大发送数量限制的，为了稳妥起见还是决定搭建自己的STMP服务来发送邮件。 以ubuntu 14.04为例：借助于postfix搭建SMTP服务 安装 apt-get install mailutils &lt;p&gt;在设置页面选择Internet site&lt;br /&gt;&lt;img alt=&quot;&quot; class=&quot;has&quot; height=&quot;269&quot; src=&quot;https://img-blog.csdnimg.cn/20181227134333835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70&quot; width=&quot;500&quot; /&gt;&lt;/p&gt; &lt;/li&gt; &lt;li style=&quot;text-indent:0px;&quot;&gt; 配置 &lt;pre class=&quot;has&quot;&gt; vim /etc/postfix/main.cf 修改以下内容myhostname = mail.youraddressmydomain = youraddressmyorigin = admin@youraddress mydestination = $myhostname, localhost.$mydomain, $mydomain &lt;p&gt; &lt;/p&gt; &lt;/li&gt; &lt;li style=&quot;text-indent:0px;&quot;&gt;重启服务 &lt;pre class=&quot;has&quot;&gt; service postfix restart 测试 echo “This is the body of the email” | mail -s “This is the subject line” your_email_address &lt;p&gt;检查是否能够收到邮件，如果没有请检查服务器25端口是否开放，（腾讯云的默认是关闭的需要去申请解封）&lt;/p&gt; &lt;/li&gt; 邮箱服务 python 自带两个模块可以实现发送邮件的功能，email和 smtplib，email负责构造邮件内容，smtplib用来发送邮件 下面是最简单的一个发送示例 import smtplib from email.mime.text import MIMEText from email.header import Header def send(receiver,payload): sender = 'admin@iotforfml.cn' # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码 message = MIMEText(payload, 'plain', 'utf-8') # 邮件标题 subject = '触发器报警通知' message['Subject'] = Header(subject, 'utf-8') try: smtp_obj = smtplib.SMTP('localhost') smtp_obj.sendmail(sender, receiver, message.as_string()) except smtplib.SMTPException: pass send('1193589986@qq.com','aaaa') 结果： 何时发送，怎么判断是否需要发送报警邮件，这个问题会放到持久化服务里面去判断，接受消息后就应该判断是否触发，具体的实现我想放到后面整合的时候在说，这里只是简单的实现一个发送邮件的接口","link":"/2018/12/27/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E9%82%AE%E7%AE%B1%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1/"},{"title":"从零开始搭建物联网平台（9）：快捷指令和指令发送","text":"回来更新了，先说明一下，这个项目没有烂尾，没有烂尾，没有烂尾，第一版其实已经做完几个月了，后来想实现小程序端的部分功能，最后结果就是导致小程序和web两个的接口不兼容，而且第一次设计的时候有很多地方没有设计好，所以又推翻重做了，在这一版本中，会对接入设备的订阅和发布做出严格的限制（无法订阅除系统topic之外的消息，无法发布没有注册的消息），但是为了实现部分设备之间的通信会设置一个自组网络，可将自己的设备添加到这个网络中，在这个网络中进行通信。废话不多说进入正题。 Models 首先需要建立表来存储用户保存的指令内容，这里还是用django的models创建，和user、device表是一对多的关联，其中device_id 会作为消息的topic，所以设备想要接收消息需要订阅device_id的topic from django.db import models class CMD(models.Model): name = models.CharField(max_length=32, null=False) # 指令名称 cmd_id = models.IntegerField(unique=True, null=False, db_index=True) # 指令ID payload = models.CharField(max_length=32, null=False) # 消息内容 qos = models.IntegerField(default=0,choices=[(0, 0), (1, 1), (2, 2),]) # 消息质量 ctime = models.DateTimeField(auto_now_add=True) # 创建时间 token = models.CharField(max_length=64, null=False) # 鉴权信息 introduce = models.TextField(null=True) # 指令介绍 user = models.ForeignKey('user.UserInfo', to_field='uid', on_delete=models.CASCADE) # 用户ID device_id = models.ForeignKey('device.Device', to_field='did', on_delete=None) # 指令接收的设备ID（指令的消息头topic） class Meta: db_table = 'quick_cmd' 获取快捷指令 使用了rest_framework做了全局的认证，request.user就是认证通过后返回的user_id，返回的数据格式为：{'code':0,'msg':'', 'data':[ {指令1}, {指令2}]} class CMDInfo(APIView): \"\"\" 快捷指令信息 \"\"\" @staticmethod def get(request, *args): \"\"\" 获取指令信息（全部） :param request: :param args: 指定cmd_id 获取单个信息 :return: json \"\"\" res = {'code': 0, 'msg': '', 'data': []} try: if not args: cmd_obj = CMD.objects.filter(user_id= request.user).all() else: cmd_obj = CMD.objects.filter(cmd_id=args[0]).all() for i in cmd_obj: res['data'].append(model_to_dict(i)) except Exception as e: res['code'] = 1 res['msg'] = e.__repr__() return JsonResponse(res) 展示指令标签 以小程序端为例：在onLoad函数里请求后台接口，然后在wxml将数据渲染出来，这里使用了iview Weapp的组件 // .js文件 onLoad: function(options) { api.cmdInfo((res) =&gt; { $Toast.hide() if (res.data.code === 0) { //生成随机的颜色 var tagsinfo = res.data.data for (var i = 0; i &lt; tagsinfo.length; i++){ tagsinfo[i].color = this.data.color[Math.floor(Math.random() * 5)] } this.setData({ quickCMD: tagsinfo }) } }) }, // .wxml文件 &lt;view class='tags-pannel'&gt; 快捷指令 &lt;view class='edit'&gt;编辑&lt;/view&gt; &lt;view wx:if='{{quickCMD.length&gt;0}}' style=\"padding-top:20px\"&gt; &lt;i-tag class=\"tags\" color=\"{{item.color}}\" data-cmd=\"{{item}}\" bindtap=\"quickeSend\" wx:for=\"{{quickCMD}}\" wx:key='{{index}}'&gt; {{item.name}} &lt;/i-tag&gt; &lt;/view&gt; &lt;view wx:else&gt; &lt;no-data title='未找到已经保存快捷指令！' /&gt; &lt;/view&gt; &lt;/view&gt; 发送指令 在wxml文件中绑定了点击事件：quickSend事件，通过target.dataset来传递参数，并将需要用到的数据转换为键值对类型，传给后台接口。 quickSend: function(e) { let data = { 'topic': e.target.dataset.cmd.device_id, 'qos': e.target.dataset.cmd.qos, 'payload': e.target.dataset.cmd.payload } api.sendCmd(data,(res)=&gt;{ if (res.data.code === 0) { $Toast({ content: '发送成功', type: 'success', duration: 1 }); } else{ $Toast({ content: '发送失败！', type: 'error', duration: 1 }); } }) }, 后端接收发送过来的data还需要对数据格式进行验证，这里使用了django 的forms实现 from django import forms from django.core.validators import ValidationError class QuickCMDForm(forms.Form): topic = forms.CharField( required=True, # 是否为空 error_messages={ 'required': 'topic不能为空', 'max_length': '用户名长度超过限制' } ) payload = forms.CharField( required=True, max_length=32, # 最长长度 error_messages={ 'required': '消息不能为空', 'max_length': '消息报文超过长度限制' } ) qos = forms.IntegerField( required=True, error_messages={ 'required': 'QoS不能为空', } ) # 自定义校验 # 检查QoS值是否正确 def clean_qos(self): qos = self.cleaned_data['qos'] is_exits = True if qos in [0,1,2] else False if not is_exits: raise ValidationError('QoS设置错误') return qos 对应的view当验证通过之后，还需要对数据进行处理，QoS要为int类型，topic和payload都是str类型的，以免EMQ接收请求失败，再通过HTTP请求EMQ的API实现指令的下发。 class SendCMD(APIView): \"\"\" 发送指令 \"\"\" parser_classes = [JSONParser, FormParser] @staticmethod def post(request): print(request.data) cmd_form = QuickCMDForm(request.data) if cmd_form.is_valid(): # 检查消息格式是否正确 try: data = { 'topic': str(request.data.get('topic')), 'payload': str(request.data.get('payload')), 'qos': int(request.data.get('qos')) # qos必须为整数 } data = json.dumps(data) # Dict转Json print(data) auth = HTTPBasicAuth(settings.MQTT_USER['username'], settings.MQTT_USER['password']) # basicAuth认证 recv = requests.post(url=settings.BASE_EMQ_URL+\"/api/v2/mqtt/publish\" ,auth=auth, data=data) if recv.status_code == 200: return JsonResponse(recv.json()) # return json.loads(res.text) else: return JsonResponse({'code': 1, 'result': []}) except Exception as e: return JsonResponse({\"code\": 1, 'msg': e.__repr__(),'result': []}) else: res = {'code': 1, 'msg': \"\"} for i, error in cmd_form.errors.items(): res['msg'] = error[0] return JsonResponse(res) EMQ提供了HTTP请求的方式来发布消息 API 定义:POST api/v2/mqtt/publish 请求参数:{ \"topic\" : \"/World\", \"payload\": \"hello\", \"qos\": 0, \"retain\" : false, \"client_id\": \"mqttjs_722b4d845f\" } topic 参数必填，其他参数可选。payload 默认值空字符串，qos 默认为 0，retain 默认为 false，client_id 默认为 ‘http’。 请求成功：{ \"code\": 0, \"result\": [] } 总结 主要流程：获取用户的快捷指令信息---&gt; 页面展示 ---&gt;点击发送---&gt;后台验证消息可靠性---&gt;通过HTTP请求EMQ的API实现发布消息---&gt; 将结果返回给前端显示 最后放几张小程序的截图：","link":"/2019/03/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%EF%BC%889%EF%BC%89%EF%BC%9A%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4%E5%92%8C%E6%8C%87%E4%BB%A4%E5%8F%91%E9%80%81/"},{"title":"使用CDN优化首页加载速度","text":"之前使用vue构建的前端页面每次加载都需要十几秒的时间，最初的时候因为浏览器有缓存一直没有发现这个问题，后来换用设备访问的时候才发现。不想花费太多的时间去优化vue的代码，感觉作用不大，毕竟服务器带宽只有1M，再怎么压缩文件大小都需要很长时间传输，所以使用CDN去加速静态资源 先看一下之前的加载速度，简直惨不忍睹 首先需要在云服务商那购买CDN服务，我的服务器是腾讯云的正好腾讯云也有免费的CDN可以试用，购买环节跳过。 要使用CDN服务首先需要在域名管理处添加域名： 域名配置需要按照自己的服务器填写，加速服务的配置看自己的需求了，一般来说选择css、js、和图片资源就够了 提交配置等待几分钟后在域名管理处查看CNAME 接下来需要配置DNS解析服务 在开启的时候如果出现冲突，按照提示关闭另外的一个即可 至此CDN的配置完成了，如果访问还是很慢先去CDN刷新缓存检查一下 最后的成果：1.16秒","link":"/2018/12/17/%E4%BD%BF%E7%94%A8CDN%E4%BC%98%E5%8C%96%E9%A6%96%E9%A1%B5%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/"},{"title":"列表中的陷阱","text":"列表是python中常用的一种数据结构，能够存放任意的其他数据类型，int、str、list 、tuple等，但是最近发现了一个问题，代码如下 123456data = []buff = dict()for i in range(5): buff['d'] = i data.append(buff)print(data) 原本以为打印的结果会是[{‘d’:0},{‘d’:1},{‘d’:2},{‘d’:3},{‘d’:4}]但是最终的结果为[{‘d’:4},{‘d’:4},{‘d’:4},{‘d’:4},{‘d’:4}] 最后发现其实当我们使用列表存储数据的时候，只是把数据的内存地址给存入列表中了而不是数据本身，所以上面的代码就不难理解我们只是在data列表中存了5个buff的内存地址，而且这5个内存地址是指向同一个数据的，当运行到最后一个循环的时候buff里面的数据就变为{‘d’:4},所以data最后的结果就是5个相同的内容。 弄清楚了上面的问题，我们可以做以下更改来实现我们的目的 1234567data = []buff = dict()for i in range(5): buff['d'] = i data.append(buff) buff = dict()print(data) 最终的结果如下[{‘d’:0},{‘d’:1},{‘d’:2},{‘d’:3},{‘d’:4}]因为我们在append之后相当于新建了一个空字典，buff不再指向之前的内存地址了，在下次循环的时候会将数据存档在新的内存空间里面，而列表中其实是存了5个不同的内存地址。 总结：列表并不是直接存放数据对象本身，而是存放数据对象的内存地址，如果内存地址对应的内容被修改了那么列表也会被更改掉。","link":"/2018/04/28/%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%99%B7%E9%98%B1/"},{"title":"在WSL2子系统中安装并使用Hexo","text":"下面以 Ubuntu22.04 子系统为例，介绍如何安装并使用Hexo博客框架。 hexo 依赖 nodejs 和 npm, 需要提前安装。 安装 nvm、node.js 和 npm和 python 一样，在不同的项目里面可能会在多个 nodejs 版本之间来回切换，此时一般需要借助版本管理器来实现，可以选择安装 nvm 1234curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh | bash# 如果没有 curl 命令，需要手动安装# sudo apt-get install curl 安装完成可以通过 nvm ls 命令列出当前安装的所有 nodejs 版本 1234&gt; nvm lsiojs -&gt; N/A (default)node -&gt; stable (-&gt; N/A) (default)unstable -&gt; N/A (default) 此时应该是没有安装任何版本的，可以通过 nvm install --lts 来安装最新的LTS版本 安装完成之后通过 node --version npm --version 查看相应的版本号，在项目目录使用 nvm use &lt;version id&gt; 来切换 nodejs 的版本 安装 Hexo全局安装 1npm install -g hexo-cli 安装成功后通过 hexo --version 即可查看 hexo 的版本 Hexo 的使用常见命令 命令 说明 hexo init folder Hexo 将会在指定文件夹中初始化一个博客项目 hexo new layout title 创建一篇新文章或者新的页面，layout:post文章、page页面、draft草稿 hexo publish layout title 将草稿中的 title 移动到 post 或者 page hexo generate 使用 Hexo 生成静态文件 hexo server 运行服务，本地预览","link":"/2022/12/13/%E5%9C%A8WSL2%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8Hexo/"},{"title":"对Python装饰器的理解","text":"想要弄明白装饰器是什么东西，首先我们需要了解一下什么是闭包，因为装饰器是闭包的一种应用。 闭包闭包的定义： ​ 通俗的来说闭包就是在一个函数内部定义另外一个函数，这个函数又引用了外部函数的变量，并且外函数的返回值是内函数的引用，下面是一个最简单的闭包示例： 12345678def outer(): a = 10 def inner(): print(a) return innerdemo = outer()demo() 那么再回到装饰器上面，我们都知道在python中任何东西都是对象，一个函数也好一个字符串也好都是对象，在传递过程中都是传递其内容的引用，当传递的是函数的时候只需在变量名后边加上()即可调用这个函数。 好了基础知识了解了，那么下面来看一个简单的装饰器应用： 装饰器123456789101112131415def auth(func): print('before run') def wrapper(): func() return wrapper@authdef response(): print('this is a test function') response() ###### result ####### before run# this is a test function 乍一看是不是和闭包一样，只不过把变量替换成函数名了 参数的传递上面的示例中被装饰函数是没有传递参数的，倘若被装饰函数需要传递参数的时候那么就需要稍微做一下调整。 1234567891011121314151617def auth(func): print('before run') def wrapper(*args, **kwargs): func(*args, **kwargs) return wrapper@authdef response(*args, **kwargs): print('this is a test function') print(args) response(1,2) ###### result ####### before run# this is a test function# (1, 2) 装饰器的高级用法有时候实际使用装饰器的时候可能并不会像上面的那样简单，例如我们可能需要给装饰器本身传递参数，来让装饰器更为灵活。先尝试不改代码看看运行的结果 12345678910@auth(1,2)def response(*args, **kwargs): print('this is a test function') print(args)response(1, 2)###### result ####### error:# TypeError: auth() takes 1 positional argument but 2 were given auth只有一个参数，但是传递了两个参数，这是为什么呢？我们需要先看看@auth这行代码是什么意思，@auth其实是response=auth(response)的简写，你看这样的写法就只接收一个参数，那么我们不使用这种简写方式可以吗？ 12345678910111213141516171819def auth(func, *args): print('before run') print(args) def wrapper(*args, **kwargs): func(*args, **kwargs) return wrapperdef response(*args, **kwargs): print('this is a test function') print(args)response = auth(response, 1)response(1, 2)###### result ####### before run# (1,)# this is a test function# (1, 2) 你看还真是实现了这个功能，只不过没办法使用简写来装饰函数了。那有没有更好的解决方法呢，我们再回到装饰器的原理上（一个闭包）那如果我们在闭包函数外面再套一层函数是不是就可以解决了呢。尝试一下 123456789101112131415161718192021def outer(*args, **kwargs): print('before run') print(args) def inner(func): def wrapper(*args, **kwargs): func(*args, **kwargs) return wrapper return inner@outer(1, 2)def response(*args, **kwargs): print('this is a test function') print(args)response(3, 4)###### result ####### before run# (1,)# this is a test function# (1, 2) 实现了和上一个一样的功能，此时的@outer(1,2)还原成本来样子就是 response = outer(1,2)(response)，我们打上断点看看装饰器是如何运行的 多个装饰器同时使用先上代码看结果 123456789101112131415161718192021222324252627def decorator1(func): print('Decorator1') def wrapper(*args,**kwargs): print('----1----') func(*args, **kwargs) return wrapperdef decorator2(func): print('Decorator2') def wrapper(*args,**kwargs): print('----2----') func(*args, **kwargs) return wrapper@decorator1@decorator2def test(*args): print(args)test(1,2)###### result ####### Decorator2# Decorator1# ----1----# ----2----# (1, 2) 执行顺序并不是先执行完装饰器1然后在执行装饰器2，而是交替运行的，我们分析一下具体执行过程一探究竟。就装饰顺序来说还是按照decorator1、decorator2来对原函数装饰的，那么装饰的结果是什么呢，这里需要了解一下@符号的作用，在python中@会将紧跟着的函数名作为参数传给装饰函数，经过两个装饰器作用之后 test变成了 ：test = decorator1(decorator2(test)) 此时在调用test的时候，就会从里往外执行， 即先执行decorator2(test)，会先打印出Decorator2 返回decorator2中的内函数给decorator1，然后打印Decorator1 返回decorator1内函数给test 在调用test函数的时候就会先执行decorator1的内函数，打印出了—-1—- 然后运行decorator2的内函数,打印出—-2—- 最后才会运行test原函数 总结来说，在装饰过程中越靠近被装饰函数越先执行，内函数恰恰相反** 保留原函数的信息回到之前一个最简单的装饰器上，我们看看直接输出被装饰的函数信息是什么? 12345678910111213def auth(func): def wrapper(): func() return wrapper@authdef response(): passprint(response.__name__)###### result ####### wrapper 输出的是装饰器的内函数，原因就不说了，和之前的一样@的作用，难么我们该怎么让打印函数信息能够显示的是被装饰函数本身呢？这里就要用到functools的wraps方法，用法很简单： 123456789101112131415from functools import wrapsdef auth(func): @wraps(func) def wrapper(): func() return wrapper@authdef response(): passprint(response.__name__)###### result ####### response 总结装饰器到此差不多都说完了，其作用就不展开说了，经过这么一连串的分析自己也对装饰器的原理有了更深的了解，算是没白浪费时间。","link":"/2019/03/07/%E5%AF%B9Python%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3/"},{"title":"对于Python闭包的理解","text":"首先看一个面试中非常常见的题目 12345def num(): return [lambda x: x * i for i in range(4)]print([ n(2) for n in num()]) 先看一下num函数的作用，定义了一个匿名函数，返回传入参数乘以列表生成式的每一个元素，所以乍一看结果应该为[0,2,4,6]，如果这样想的话就落入陷阱了。这个题目考察的就是在python中闭包是延迟绑定的，当num()赋值给n的时候就已经完成for循环了，i已经等于3，所以到最后输出值都为 2 *3 也就是[6,6,6,6] 闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包： 在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的 Python中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下：","link":"/2018/11/23/%E5%AF%B9%E4%BA%8EPython%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"},{"title":"常用排序算法：冒泡排序","text":"冒泡排序思路列表中的每两个相邻的数，如果前面比后面的大，则交换这两个数。直到列表变为有序的时候为止，例如下面这个列表[ 2, 1, 3, 0, 7, 6, 5, 4] 第一趟第一步：列表的第一位和第二位比较：如果第一位大于第二位，则交换两者位置。由于2大于1，所以此时列表 为：[1, 2, 3, 0, 7, 6, 5, 4]第二步：再比较第二位和第三位，重复上面的操作，第一趟排序完成之后列表变为 [1, 2, 3, 0, 6, 5, 4 , 7]，第一 趟完成之后最大数7跑到列表最后一位了。 第二趟还是从第一位开始比较，1小于2顺序不变，比较第二位和第三位2 小于3依然不变，比较第三位3大于0交换位 置， 此时列表变为[1, 2, 0, 3, 6, 5, 4 , 7]，这一趟排序完成之后列表最终变为[1, 2, 0, 3, 5, 4, 6, 7] 冒泡排序的思想还是比较简单的，只是反复不断的比较相邻位置大小，并作交换，不再把每一步都交代明白了，只需重复上述的操作即可实现，最终裂变会变为[0,1,2,3,4,5,6,7],也就达到我们的排序目的了 代码实现123456789101112131415161718192021def bubble_sort(nums): for i in range(len(nums) - 1): # i表示第几趟 for j in range(len(nums) - i - 1): # j表示是第几个元素在比较 if nums[j] &amp;gt; nums[j + 1]: # 如果大于则交换位置 nums[j], nums[j + 1] = nums[j + 1], nums[j] print(nums) return numsbubble_sort([2, 1, 3, 0, 7, 6, 5, 4])# [1, 2, 3, 0, 7, 6, 5, 4]# [1, 2, 0, 3, 7, 6, 5, 4]# [1, 2, 0, 3, 6, 7, 5, 4]# [1, 2, 0, 3, 6, 5, 7, 4]# [1, 2, 0, 3, 6, 5, 4, 7]# [1, 0, 2, 3, 6, 5, 4, 7]# [1, 0, 2, 3, 5, 6, 4, 7]# [1, 0, 2, 3, 5, 4, 6, 7]# [0, 1, 2, 3, 5, 4, 6, 7]# [0, 1, 2, 3, 4, 5, 6, 7] 简单优化可以知道的是，如果列表是无序的，那么一趟排序的结果必然最少有一次交换，那么反过来想一下，如果一次完整的一趟没有交换任何位置，那么是不是就表明这个列表已经是有序的呢？按照这个思路我们来改进一下上面的代码。 12345678910def bubble_sort(nums): for i in range(len(nums) - 1): # i表示第几趟 flag = False # 是否发生交换的标志位 for j in range(len(nums) - i - 1): # j表示是第几个元素在比较 if nums[j] &amp;gt; nums[j + 1]: # 如果大于则交换位置 nums[j], nums[j + 1] = nums[j + 1], nums[j] flag = True if not flag: # 一趟排序完成没有发生交换直接返回 return nums return nums","link":"/2018/10/24/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"title":"常用排序算法：基数排序","text":"算法思路步骤： 创建10个队列(0-9) 遍历每个数位，按照位数存入不同的桶中 然后再将桶中的元素依次取出，放回到原有列表中 继续执行上两步操作，直到列表中每个数的每一位都做完成排序 最后取出桶内元素，排序完成 时间复杂度： O(kn) k为最大数位数空间复杂度： O(k+n) 代码实现12345678910111213def radix_sort(nums): max_num = max(nums) bucket = [[] for _ in range(10)] # 创建空桶 i = 0 while 10 ** i &amp;lt; max_num: # 按位数将数组存入桶中 for num in nums: bucket[num // (10 ** i) % 10].append(num) nums.clear() for j in bucket: # 取出桶中元素，顺便情况桶 nums.extend(j) j.clear() i += 1","link":"/2018/10/25/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"title":"常用排序算法：堆排序","text":"算法思路堆：分为大根堆和小根堆 - 大根堆：一棵完全二叉树，满足任意一节点都比其孩子节点大。 - 小根堆：一棵完全二叉树，满足任意一节点都比其孩子节点小。 堆排序流程 构造堆 得到堆顶元素，为最大元素 去掉堆顶，将堆的最后一个元素放到堆顶，然后调整重新使堆有序 堆顶元素为第二大的元素 重复第三步直到堆变空 例如以[4, 5, 3, 6, 1, 2 ]为例： 准备知识在以顺序储存的完全二叉树中，父子节点的关系（下标）： 父节点和左孩子：左孩子下标 = 父节点下标 * 2 + 1 父节点和右孩子：右孩子下标 = 父节点下标 * 2 + 2 子节点和父节点： 父节点下标 = (子节点下标 - 1) // 2 最后一个非叶子节点：n // 2 -1 代码实现12345678910111213141516171819202122232425262728293031323334def sift(nums, low, high): &quot;&quot;&quot; 调整堆，使堆有序 :param nums: list :param low: 根节点 :param high: 尾节点（树的最后一个） :return: &quot;&quot;&quot; temp = nums[low] i = low j = 2 * i + 1 while j &amp;lt;= high: # 当前i位置为叶子节点， j超过high了 # 找更大的子节点 if j + 1 &amp;lt;= high and nums[j+1] &amp;gt; nums[j]: # j = j + 1 if temp &amp;lt; nums[j]: nums[i] = nums[j] i = j j = 2 * i + 1 else: # temp 大于两个子节点 break nums[i] = tempdef heap_sort(nums): # 建堆 l = len(nums) for i in range(l//2-1, -1, -1): # i是建堆时要调整的子树的根节点下标 sift(nums, i, l-1) for i in range(l - 1, -1, -1): # 当前的high值 nums[i], nums[0] = nums[0], nums[i] sift(nums, 0, i-1)&lt;/code&gt;&lt;/pre&gt; 内置函数Python内置模块heapq帮我们实现了堆排序，内置函数用的是小根堆，上面的代码是大根堆，差别不大，heapq模块主要包括三个函数: heapify(list) 建小根堆 把传入的list变成小根堆 heappush(heap_list, item)向已经建好的堆中增加数据 heappop(heap_list) 输出小根堆中最小值 12345678910111213141516import heapqnums = [3, 2, 1, 0, 6]heapq.heapify(nums)print(nums)# [0, 2, 1, 3, 6]heapq.heappush(nums, 4)print(nums)# [0, 2, 1, 3, 6, 4]print(heapq.heappop(nums))# 0print(heapq.heappop(nums))# 1print(heapq.heappop(nums))# 2","link":"/2018/10/23/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"常用排序算法：希尔排序","text":"算法思路希尔排序算是插入排序的一种，是改进版的直接插入排序，和直接插入排序不同的是它是按组进行插入排序的。步骤如下： 取一个整数d1 = n / 2,将元素分成d1个组，每组相邻元素之间距离d1，然后在每组内部进行直接插入排序。 取第二个整数d2 = d1 / 2再将元素分成d2个组，然后再在每组内部进行插入排序。 重复上面的步骤直到d = 1 的时候即所有元素在同一组进行插入排序。 例如数组 [4,3,5,1,6,0,7,2]排序过程如下图所示 希尔排序并每趟并不是使某些元素有序，而是使整体数据越来越有序，只会在最后一趟排序能使得所有元素都有序。 代码实现1234567891011def shell_sort(nums): d = len(nums) // 2 while d &amp;gt; 0: # 分组到一的时候停止 for i in range(d, len(nums)): # 第i个分组 temp = nums[i] #无序区第一位 j = i - d # 有序区最后一位 while j &amp;gt;= 0 and nums[j] &amp;gt; temp: # 如果有序区大于无序区 nums[j + d] = nums[j] j -= d nums[j+d] = temp d //= 2","link":"/2018/11/24/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"title":"常用排序算法：堆排序","text":"算法思路简单来说归并排序就是将两个有序的序列合并成一个完整的有序序列。具体步骤如下： 选取序列1的第一个元素和序列2的第一个元素，较小的存放到新序列的第一位 选序列1的第二个元素再和序列2的第一个元素比较，选较小的存放到新序列的低二位 重复上述步骤直到序列1序列2没有下一个元素为止 那么问题来了，一个无序的序列又是如何分成两个有序序列然后执行上述的步骤呢，这个我们就需要先把原有的序列进行拆分，拆分到每个子序列长度都为1的时候所有子序列不就是有序的吗【手动滑稽】。那么一个完整的递归排序的过程就会分成两部分，第一拆分，第二合并，如下图所示 代码实现1234567891011121314151617181920212223242526def merge(nums, low, mid, high): # 合并 i = low j = mid + 1 array = [] while i &amp;lt;= mid and j &amp;lt;= high: # 循环从两边中取出较小的数放入新的空数组中 if nums[i] &amp;lt;= nums[j]: array.append(nums[i]) i += 1 else: array.append(nums[j]) j += 1 while i &amp;lt;= mid: # 当某一边取完了之后，直接将剩下一边的数据直接存入 array.append(nums[i]) i += 1 while j &amp;lt;= high: array.append(nums[j]) j += 1 nums[low:high + 1] = arraydef merge_sort(nums, left, right): # 拆分 if left &amp;lt; right: mid = (left + right) // 2 merge_sort(nums, left, mid) merge_sort(nums, mid + 1, right) merge(nums, left, mid, right) 补充之前面试遇到一个问题，给一个4G内存的计算机，硬盘大小为1T，设计一种算法将100G的数据从小到大排序，第一个想到的就是归并，但是呢这个归并不同上面说的那种，因为内存太小了，放不下那么多数据啊。所以呢需要做一下改进。4G和100G差别太多，以4G和12G为例，首先先从硬盘中取出3G数据放入内存中使用排序算法构造成有序数据在写回到硬盘中，再取出下一个3G数据排好序，直到所有的数据都取出来并排好序了，这样我们就得到了4个有序的子序列，下一步呢就是用我们刚刚说的归并排序将4个有序序列合并成一个完整的有序序列。","link":"/2018/10/24/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"title":"常用排序算法：快速排序","text":"算法思路快速排序差不多是面试中问的最多的一种排序算法了，快排是比较容易理解的，核心思路就是，选取一个数作为基准，将原来的列表分为两个部分，一部分全部小于这个基准数，另外一部分全部大于这个基准数，然后呢再按照这个方法对划分出来的两部分继续做同样的操作，直到无法划分的时候排序也就完成了。 以数组[3,2,1,5,4,6]为例，其排序过程如下图所示。 关于时间复杂度问题， 平均复杂度n log(n) 最坏情况 n^2，以长度为16的list为例 代码实现方法一：按照上述的思路可分为两个部分来写代码，一部分是使用递归，一部分是调整位置。 123456789101112131415161718def partition(nums, left, right): temp = nums[left] while left &amp;lt; right: while left &amp;lt; right and nums[right] &amp;gt;= temp: # 从右往左搜索比基准值小 right -= 1 # 没有则往右走一位 nums[left] = nums[right] # 找到了比基准值小的则调整顺序 while left &amp;lt; right and nums[left] &amp;lt;= temp: # 从左往右找比基准大的数 left += 1 nums[right] = nums[left] nums[left] = temp # 交换完成之后归位 return left # 返回基准值的位置def quick_sort(nums, left, right): if left &amp;lt; right: mid = partition(nums, left, right) quick_sort(nums, left, mid - 1) # 比基准值小的一部分再次进行快排 quick_sort(nums, mid + 1, right) # 比基准值大的一部分&lt;/code&gt;&lt;/pre&gt; 方法二：上面这种呢是在原有的list进行变换，如果不考虑原有变换还有一种更直观的方法来实现，使用列表生成式来实现，只不过在数据量很大的时候会占用更多的空间。不考虑交换操作，直接简单粗暴的把list分割成两部分。 12345678def quick_sort(nums): if len(nums) &amp;lt;= 1: return nums pivot = nums[len(nums)//2] left = [x for x in nums if x &amp;lt; pivot] middle = [x for x in nums if x == pivot] right = [x for x in nums if x &amp;gt; pivot] return quick_sort(left) + middle + quick_sort(right)","link":"/2018/10/24/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"常用排序算法：桶排序","text":"算法思路我们之前提到过计数排序，计数排序在某些情况下并不太适合，例如元素范围太大的情况，桶排序算是对于计数排序的一种改进，桶排序首先根据元素大小放置到不同的桶中，然后在对每一个桶内元素进行排序。 例如数组[29,25,3,49,9,37,21,43]，可以以10为区间来存放元素，具体操作如下图 关于“桶”这个结构怎么实现，在python里面可以用二位数组来表示[ [ ], [ ], [ ] ….]，总得来说桶排序步骤： 建桶 元素存放到桶里面 桶内元素进行排序（第二步和第三步可以合并到一起，因为初始的桶为空是有序的，每次只需执行一次插入即可保持有序 依次取出每个桶内元素 时间复杂度：平均O(n+k)， 最坏O(n^2 * k)都放到一个桶里面了 空间复杂度：O(nk) 代码实现1234567891011121314151617181920212223242526def bucket_sort(nums, buckets): &quot;&quot;&quot; 桶排序 :param nums: 无序数组 :param buckets: 桶个数 :return: 有序数组 &quot;&quot;&quot; bucket = [[] for x in range(buckets)] # 创建空桶 num = max(nums) - min(nums) + 1 l = num // buckets + 1 if num % buckets else num // buckets # 计算每个桶大小 for i in nums: bucket_num = i // l # 计算元素应该放入到哪一个桶里面 bucket[bucket_num].append(i) # 维护桶内元素有序。 # 因为之前的桶内是有序的，插入一个新的元素可以使用插入排序继续保持桶内有序 tmp = i j = len(bucket[bucket_num]) - 2 while j &amp;gt;= 0 and bucket[bucket_num][j] &amp;gt; tmp: # 执行插入操作 bucket[bucket_num][j + 1] = bucket[bucket_num][j] j -= 1 bucket[bucket_num][j+1] = tmp res = [] # 依次取出桶内元素 for i in bucket: res.extend(i) return res","link":"/2018/11/24/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"title":"常用排序算法：直接插入排序","text":"算法思路插入排序就跟我们打扑克抽牌是一样的形式，每次新抽的牌插入到已有的有序牌中，是牌始终保持有序状态，例如[1,3, 2,4,0] 数组，先将1作为起始牌，下一张牌为3，第一趟完成后变成[1, 3]有序数组和[2,4,0]无序数组，接下来插入2，有序数组变成[1,2,3]，无序数组变成[4,0]，以此类推知道将所有的无序数组都插入完毕就能完成排序操作。 插入排序算法适用于少量数据的排序，时间复杂度为 O(n^2)。是一种稳定的排序方法。 代码实现1234567891011121314151617def insert_sort(nums): for i in range(1,len(nums)): # 无序区[i:] temp = nums[i] # 无序区的第一个数 j = i - 1 # 有序区的最后一个 while j &amp;gt;= 0 and nums[j] &amp;gt; temp: # 执行插入操作 nums[j+1] = nums[j] j -= 1 nums[j+1] = temp print(nums)insert_sort([1,3, 2,4,0])# [1, 3, 2, 4, 0]# [1, 2, 3, 4, 0]# [1, 2, 3, 4, 0]# [0, 1, 2, 3, 4]","link":"/2018/11/24/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"title":"常用排序算法：直接选择排序","text":"算法思路第 1 趟，在待排序记录 r1 ~ r[n]中选出最小的记录，将它与 r1 交换；第 2 趟， 在待排序记录 r2 ~ r[n]中选出最小的记录，将它与 r2 交换；以此类推，第 i 趟在待排序 记录 r[i] ~ r[n]中选出最小的记录，将它与 r[i]交换，使有序序列不断增长直到全部排序 完毕。 例如[2, 4, 3, 1, 0]，第一趟找到最小值为0，将0和第一位交换，得到[0, 4, 3, 1, 2]，第二趟从[4, 3, 1, 2]中找到最小值1，再和第一位交换得到[0, 1, 3, 4, 2]，以此类推知道排序完成。 代码实现1234567891011121314151617def select_sort(nums): for i in range(len(nums)): # 第i趟开始时 无序区为：[i:] min_pos = i # 最小值位置 for j in range(i + 1, len(nums)): # 在无序区里面找最小值，并记录位置 if nums[j] &amp;lt; nums[min_pos]: min_pos = j nums[min_pos], nums[i] = nums[i], nums[min_pos] # 交换 print(nums)select_sort([2, 4, 3, 1, 0])# [0, 4, 3, 1, 2]# [0, 1, 3, 4, 2]# [0, 1, 2, 4, 3]# [0, 1, 2, 3, 4]# [0, 1, 2, 3, 4]","link":"/2018/11/25/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"title":"常用排序算法：计数排序","text":"算法思路顾名思义计数排序就是统计每个数出现的次数，例如给0-20范围内的数排序，首先建立一个长度为21的空数组，然后统计每个数出现的次数，再按照下标存入空数组中，例如1出现10次那么数组中的第二个元素为10 ，统计完所有的数之后呢在新建一个数组，在遍历之前存放次数的数组，按照个数往新数组中添加对应的数。 以一个例子来说明[1,2,3,1,0,4,1,3,4,2,0,1,2,3,4]排序过程如下图所示 计数排序虽然时间复杂度小O(n)，但是局限性很大，首先是需要知道最大数是多少，其次当无序列表分布很分散例如[1,3,1000000]，明明只有三个数但是却需要开辟一个长度为1000000的空列表，会造成空间浪费。所以计数排序只适合在特定的情况下使用。 代码实现1234567891011121314def count_sort(nums, max_num): &quot;&quot;&quot; 计数排序 :param nums: 无序数组 :param max_num: 最大数 &quot;&quot;&quot; count = [0 for x in range(max_num+1)] # 新建一个统计数组 for i in nums: # 计数 count[i] += 1 nums.clear() # 清空原有数组 for c, i in enumerate(count): # 往空数组中添加元素 while i &amp;gt; 0: nums.append(c) i -= 1","link":"/2018/10/24/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"title":"微信公众号实现简易的物联网控制（一）","text":"这篇主要说说如何通过微信公众号来查看室内传感器数据，至于硬件部分和物联网平台以后再详细说明。 准备工作： 1：申请微信公众号 2：搭建云服务器 首先说明一下整体流程：用户发送相应的指令到公众号后台，服务器根据指令的内容调用OneNET的API获取传感器数据在返回给用户 详细步骤： 申请公众号后我们需要启用服务器配置，具体步骤请看微信的开发者文档，这个地方需要注意一下在填写URL的时候不要添加端口号，这样会导致验证不通过的（开发者文档上这个是错误的） 在云服务器上安装运行环境： 安装pip 安装libxml2 安装lxml &nbsp;&nbsp; 安装web.py 我们使用的物联网平台是中国移动的OneNet，它提供了很多API接口可以让我们获取数据、发送指令，在GitHub上有人用python写了常用的API调用示例，这里我们拿来直接使用就好了https://github.com/jiangxiaobai1989/pythonOneNetAPI 首先呢我们需要能够接收用户发过来的消息，使用者发送消息后后台收到的为lxml格式 &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1460541339&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[test]]&gt;&lt;/Content&gt; &lt;/xml&gt; 然后呢我们需要解析这些内容 # -*- coding: utf-8 -*- # filename: receive.py import xml.etree.ElementTree as ET def parse_xml(web_data): if len(web_data) == 0: return None xmlData = ET.fromstring(web_data) msg_type = xmlData.find(‘MsgType’).text if msg_type == ‘text’: return TextMsg(xmlData) elif msg_type == ‘image’: return ImageMsg(xmlData) elif msg_type == ‘voice’: return VoiceMsg(xmlData) class Msg(object): def init(self, xmlData): self.ToUserName = xmlData.find(‘ToUserName’).text self.FromUserName = xmlData.find(‘FromUserName’).text self.CreateTime = xmlData.find(‘CreateTime’).text self.MsgType = xmlData.find(‘MsgType’).text self.MsgId = xmlData.find(‘MsgId’).text class TextMsg(Msg): def init(self, xmlData): Msg.init(self, xmlData) self.Content = xmlData.find(‘Content’).text.encode(&quot;utf-8&quot;) class VoiceMsg(Msg): def init(self, xmlData): Msg.init(self, xmlData) self.Recognition = xmlData.find(‘Recognition’).text.encode(&quot;utf-8&quot;) 获取消息后我们需要服务器做出相应的反应，首先需要判断消息类型和消息内容，然后通过API获取数据后再返回个用户，例如下面这段获取室内温湿度的例子 # -*- coding: utf-8 -*- # filename: handle.py import hashlib import reply import receive import web from getData import * class Handle(object): def POST(self): try: webData = web.data() print &quot;Handle Post webdata is &quot;, webData #后台打日志 recMsg = receive.parse_xml(webData) if isinstance(recMsg, receive.Msg): toUser = recMsg.FromUserName fromUser = recMsg.ToUserName if recMsg.MsgType == 'text': if recMsg.Content == '温度': content = str(getData_time('temperature'))+'\\n室内温度为'+str(getData_value('temperature')) +'℃' elif recMsg.Content == '湿度': content = str(getData_time('humidity'))+'\\n室内湿度为'+str(getData_value('humidity')) +'%' else: content = '抱歉尚未开通这项指令功能，你可以尝试发送‘温度’、‘湿度’来查看最新的室内信息,或者发送相应的语音消息 ' replyMsg = reply.TextMsg(toUser, fromUser, content) return replyMsg.send() if recMsg.MsgType == 'voice': if recMsg.Recognition =='温度。': content = str(getData_time('temperature'))+'\\n室内温度为'+str(getData_value('temperature')) +'℃' elif recMsg.Recognition =='湿度。': content = str(getData_time('humidity'))+'\\n室内湿度为'+str(getData_value('humidity')) +'%' else: content =recMsg.Recognition+'\\n无法识别这条语音消息' replyMsg = reply.TextMsg(toUser, fromUser, content) return replyMsg.send() else: return reply.Msg().send() else: print &quot;暂且不处理&quot; return reply.Msg().send() except Exception, Argment: return Argment 通过API调用我们获取到的json数据，这样是不能直接给用户发送过去的，还需要对json进行处理提取主要的数据，例如提取温湿度数据和数据节点时间 # -*- coding: UTF-8 from OneNetApi import *import json def getData_value(datastreamid): test = OneNetApi(&quot;***************************&quot;) # your API datastream_id = datastreamid limit = 1 res3 = test.datapoint_get(device_id = &quot;6975064&quot;, limit = limit, datastream_id = datastream_id) data = json.loads(res3.content.replace(‘]’,’ ‘).replace(‘[‘,’ ‘)) value = data[‘data’][‘datastreams’][‘datapoints’][‘value’] return value def getData_time(datastreamid): test = OneNetApi(&quot;***************************&quot;) # your API datastream_id = datastreamid limit = 1 res3 = test.datapoint_get(device_id = &quot;6975064&quot;, limit = limit, datastream_id = datastream_id) data = json.loads(res3.content.replace(‘]’,’ ‘).replace(‘[‘,’ ‘)) time = data[‘data’][‘datastreams’][‘datapoints’][‘at’][0:19] return time至于返回用户消息呢，依然是按照lxml&amp;#26684;式，将我们获取到的数据和需要返回的用户信息添加进去就可以了class TextMsg(Msg): def init(self, toUserName, fromUserName, content): self.__dict = dict() self.__dict['ToUserName'] = toUserName self.__dict['FromUserName'] = fromUserName self.__dict['CreateTime'] = int(time.time()) self.__dict['Content'] = content def send(self): XmlForm = &amp;quot;&amp;quot;&amp;quot; &amp;lt;xml&amp;gt; &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[{ToUserName}]]&amp;gt;&amp;lt;/ToUserName&amp;gt; &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[{FromUserName}]]&amp;gt;&amp;lt;/FromUserName&amp;gt; &amp;lt;CreateTime&amp;gt;{CreateTime}&amp;lt;/CreateTime&amp;gt; &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[text]]&amp;gt;&amp;lt;/MsgType&amp;gt; &amp;lt;Content&amp;gt;&amp;lt;![CDATA[{Content}]]&amp;gt;&amp;lt;/Content&amp;gt; &amp;lt;/xml&amp;gt; &amp;quot;&amp;quot;&amp;quot; return XmlForm.format(**self.__dict)&lt;/pre&gt;&lt;br&gt; 微信后天还提供了语音识别接口，默认是打开的，当用户发送的是语音命令的时候后台接收的lxml中会比text消息多出Recognition这项，把识别结果当做text一样处理就能让公众号处理语音消息了，再次不再赘述了。 至此整个流程就结束了，当编写所有的代码后使用 python main.py 80 即可打开这项服务了，下面是效果图 国际惯例：源码","link":"/2018/06/01/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"微信公众号实现简易的物联网控制（二）","text":"命令下发 先来看一段OneNet文档说明： 命令是指应用发送命令数据给OneNet设备云、再由OneNet设备云转发给终端设备、终端设备收到命令后可以向设备云反馈响应的一种工作机制。命令下发后，应用可以通过API查询命令状态和提取命令的响应数据。 命令的执行步骤如下： 1、&nbsp; 应用通过API向设备云发送命令数据； 2、&nbsp; 设备云生成该命令的uuid作为该命令的唯一标识并向应用返回，同时向终端设备转发命令数据； 3、&nbsp; 终端设备收到命令数据后执行命令数据，可以生成响应，也可以不响应； 4、&nbsp; 设备云跟踪记录命令的响应，如果设备有响应，就关联命令uuid和响应结果； 5、&nbsp; 应用通过API向设备云提取命令执行结果(API请求中携带命令uuid标识)。 特别说明： 命令下发到终端设备后，如果终端设备10秒内未收到响应，则此命令的状态将被设置为超时，应用通过API查询命令状态时，会反馈超时。超过10秒后收到的响应会被丢弃。 终端设备针对同一条命令回复多条命令响应，只有在未超时时间内收到的第一条是有效响应，后续的响应包将会被直接丢弃。因此终端设备应该对每个命令只有一个响应包。 下面是请求格式，这个地方有些坑，和官网的公开协议产品指南有所不同，刚开始按照官网的来实现始终报，后来在其他文档里面找到了这个才最终调试通了 HTTP方法 POST URL http://&lt;API_ADDRESS&gt;/cmds HTTP头部 api-key:xxxx-ffff-zzzzz，必须master key URL参数 device_id = //接收该数据的设备ID，必填。 HTTP内容 用户自定义Json或二进制数据（小于64K） 成功返回 { &quot;errno&quot;: 0, &quot;error&quot;:“succ”， &quot;data&quot;:{ //不超过64个字符字符串 &quot;cmd_uuid&quot;:“2302-312-FWs” } } import requests class OneNet(): def init(self,key,dev_id,cmd): self.api_key = key self.dev_id = dev_id self.cmd = cmd self.header = {‘api-key’: self.api_key} def send_cmd(self): params = {‘device_id’:self.dev_id} url = &quot;http://api.heclouds.com/cmds?&quot; r = requests.session() res = r.post(url, headers=self.header, params=params,data=self.cmd) print(res.content) t = OneNet(you api_key,your dec_id, cmd)t.send_cmd()使用自带的requests库来实现post请求 最后的结果 {&quot;errno&quot;:0,&quot;data&quot;:{&quot;cmd_uuid&quot;:&quot;5bdaf1a9-3854-5e5f-b662-b1e3ef57ea6e&quot;},&quot;error&quot;:&quot;succ&quot;}","link":"/2018/06/10/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"微信小程序开发总结","text":"微信小程序开发1.数据绑定 ，和vue不同的是如果直接更改data并不会重新渲染，而是要使用setData({name:data})的方法 2.调用组件的方法： 获取元素： 1const ele = this.selectComponent(id) 调用组建的method中的方法： 1ele.functionName() 3.组件中的properties和data的区别： 首先properties是外部可更改的属性，data外部不能修改 两者用法差不多 都是this.data.name来取值 4.小程序中的传参问题 ​ 首先需要知道的是没有办法和vue中一样 使用函数名(参数)的形式实现，在小程序中如果想要传参数，则需要在绑定的元素中定义属性 data-参数名的形式，在回调函数中通过target.dataset属性获取，例如： 1&lt;view data-streamId='{{stream.id}}' bindtap='test'&gt;&lt;/view&gt; 123test: function (event) { console.log(event.target.dataset.streamid)} 5.嵌套传参的问题： 12345 &lt;view class='new-container' bindtap='update' data-name='{{item.name}}'&gt; &lt;view class='title'&gt;{{item.title}}&lt;/view&gt; &lt;view class='num'&gt;{{item.num}}&lt;/view&gt; &lt;view class='tips'&gt;点击刷新&lt;/view&gt;&lt;/view&gt; 点击内容区域的时候，如果使用target来取值会出现空，而currentTarget则不会 在官方的文档上是这样介绍两者的 6关于setData()修改数组对象的操作， 一般setData()传入的是一个对象,如下name是作为了key的名称 12345678data:{ name:'fa', array:[{name:'aa',num:1},{name:'bb',num:2}]}this.setData({ name:'wx'}) 当我们只是想修改array数组中的num的值，这时候按照上面的就没法实现了， 这时候可以采用’array[0].num’:2来实现 123this.setData({ ['array[0].num']:2}) 但是呢这个’0‘又是不能动态更改的，所以呢还是需要整体修改例如： 123456789for (var i = 0; i &lt; this.data.increase.length; i++) { if (this.data.array[i].name == 'aa'){ this.data.increase[i].num = 2 break }}this.setData({ array: this.data.array})","link":"/2019/02/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"title":"微信小程序组件设计","text":"写在前面 最近有这么一个需求，商城的数量输入框用户点击的时候清空当前的值，如果用户不输入则还原原来的数量，输入新值则替换。需求很简单，但是之前的代码不是自己写的，整个项目一共6处使用到了，大量重复的逻辑，为了以后维护方便决定将数量加减器封装为一个通用组件。 需求分析 有最大值，最小值设置，不可超过范围 加减可以设置步长 点击输入框时清空输入框内容，无输入则还原，否则替换 为增加可复用性，只将最后的结果返回出去，不实现其他业务逻辑部分 考虑到可能会有弹窗提示或者其他的交互，也需要返回输入方式、输入校验结果类型 输入方式分为：点击加号（add）点击减号（reduce）输入框输入（input） 校验结果：超过最大值（overflow_max）超过最小值（overflow_min）有效输入（success） 开始开发组件页面布局首先我们先将组件的样式以及页面布局确定下来 123456&lt;!--wxml--&gt;&lt;view class=&quot;counter-container&quot;&gt; &lt;view class=&quot;reduce-btn {{currentCount&lt;=min? 'disabled' : ''}}&quot;&gt;-&lt;/view&gt; &lt;input type=&quot;number&quot; value=&quot;{{currentCount}}&quot; /&gt; &lt;view class=&quot;add-btn {{currentCount&gt;=max? 'disabled' : ''}}&quot; &gt;+&lt;/view&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* wxss */.counter-container{ width: 164rpx; height: 48rpx; line-height: 48rpx; display: flex; font-size: 24rpx; text-align: center; padding: 8rpx 0;}.counter-container .reduce-btn{ width: 48rpx; height: 100%; border-left: 1rpx solid #ccc; border-bottom: 1rpx solid #ccc; border-top: 1rpx solid #ccc; border-bottom-left-radius: 6rpx; border-top-left-radius: 6rpx;}.counter-container .reduce-btn.disabled{ background-color: #f5f5f9; border-left: 1rpx solid #eee; border-bottom: 1rpx solid #eee; border-top: 1rpx solid #eee; color: #ccc;}.counter-container .add-btn{ width: 48rpx; height: 100%; border-right: 1rpx solid #ccc; border-bottom: 1rpx solid #ccc; border-top: 1rpx solid #ccc; border-bottom-right-radius: 6rpx; border-top-right-radius: 6rpx;}.counter-container .add-btn.disabled{ background-color: #f5f5f9; border-right: 1rpx solid #eee; border-bottom: 1rpx solid #eee; border-top: 1rpx solid #eee; color: #ccc;}.counter-container input{ width: 68rpx; height: 48rpx; min-height: 48rpx; text-align: center; font-size: 24rpx; border: 1rpx solid #ccc;} 最后的效果图 组件逻辑实现通过对需求的分析，需要传入的参数有：步长、最大值、最小值、当前值，另外输入前清空输入框这个也做成一个可选项方便满足其他不必须清空的情况。 123456789101112131415161718192021properties: { count: { type: Number }, min:{ type: Number, value: 0 }, max:{ type: Number, value: 1 }, clear:{ type: Boolean, value: false }, step:{ type: Number, value: 1 }}, 由于有清空的动作，所以在不能直接显示传入的count，需要定义一个内部数据来显示 123data: { currentCount: 0 // 用于显示的数量}, 在组件挂载到页面时候设置currentCount，同时由于不是直接显示count的当我们的页面更新count的时候还需要同步更新currentCount，这时候就需要使用到数据监听器来实现。 1234567891011121314lifetimes: { attached: function () { this.setData({ currentCount: this.data.count }) }},observers: { 'count': function(count) { this.setData({ currentCount: count }) },}, currentCount的计算逻辑，同时通过监听事件触发父组件的逻辑，返回当前count值，输入校验结果类型，以及输入方式。 12345678910111213141516171819202122232425262728addTap: function(){ let {count, check} = this.computeCount(this.data.currentCount + this.data.step) this.changeCount(count, 'add', check)},reduceTap: function(){ let {count, check} = this.computeCount(this.data.currentCount - this.data.step) this.changeCount(count, 'reduce', check)},computeCount: function(count){ // 判断数字是否处在范围之间 if(count &gt; this.data.max){ return {count: this.data.max, check: 'overflow_max'} } else if(count &lt; this.data.min){ return {count: this.data.min, check: 'overflow_min'} } else{ return {count: count , check: 'success'} }},changeCount: function(count, type, check){ // 修改count和currentCount，同时调用父组件的方法 this.setData({ currentCount: count, count: count }) this.triggerEvent('change', {count, type, check})} 输入框的清空与还原，先定义两个方法分别对应输入框的聚焦时和焦点丢失情况 1234567891011121314151617181920focusOn: function(){// 输入框获得焦点 if(this.data.clear){ this.setData({ currentCount: null }) }},focusOut: function(e){// 输入框失去焦点 let value = parseInt(e.detail.value) if (!isNaN(value)) { let {count, check} = this.computeCount(value) this.changeCount(count, 'input', check) } else { this.setData({ currentCount: this.data.count }) }}, 组件的使用12&lt;!--wxml--&gt;&lt;counter count=&quot;1&quot; min=&quot;0&quot; max=&quot;100&quot; clear=&quot;{{true}}&quot; bind:change=&quot;changeNum&quot; /&gt; 1234changeNum: function(e){ // e.detail就是组件返回的所有数据，在这里就是实现各自的业务逻辑了 console.log(e.detail)},","link":"/2021/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/"},{"title":"沛齐的315面试题基础部分解答（一）","text":"原题链接：https://www.cnblogs.com/wupeiqi/p/9078770.html 部分图片是从其他博客上整理出来的，时间有些久了当初是写在word上的忘记参考出路了，有些答案我也不知道是否回答准确，如有错误还请提出，谢谢 基础部分 1.简述解释型和编译型编程语言？ 解释型语言在运行之前不会有编译过程，由解释器在运行的过程中解释运行的常见的解释型语言还有PHP、JS、ruby等等。 编译型语言在运行之前需要使用编译器编译成机器码，计算机就可以直接运行编译过后的文件了。 一般来说编译型语言要比解释型语言运行速度要快的，应为解释型语言每执行一次就需要翻译一次，效率比较慢。 2.Python解释器种类以及特点 常见的解释器有5个CPython、IPython、PyPy、Jython、IronPython. CPython是官方版本的解释器，由C语言编写，运用也是最为广泛的。 IPython是基于CPython的，只是在交互上做出了进一步的改善，例如代码补全。 PyPy采用了JIT技术，可以动态编译python程序，提高其工作效率。 Jython是在Java平台上运行的解释器，可在将python程序编译成Java字节码运行。 IronPython和Jython类似，运行在.NET平台上。 3.位和字节的关系？ 位（bit）是计算机存储中的最小单位。只有0、1两种状态 字节（Byte）一个字节由8个bit组成，是计算机数据处理的最小单位。 4.使用python进制转换 二进制转换成十进制：v = “0b1111011”十进制转换成二进制：v = 18 八进制转换成十进制：v = “011” 十进制转换成八进制：v = 30 十六进制转换成十进制：v = “0x12” 十进制转换成十六进制：v = 87 5.请编写一个函数实现将IP地址转换成一个整数。 如 10.3.9.12 转换规则为： 10 00001010 3 00000011 9 00001001 12 00001100 再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？ 6.python递归的最大层数？ Python默认递归的最大层数为998层。 7.求结果：v1 = 1 or 3v2 = 1 and 3v3 = 0 and 2 and 1v4 = 0 and 2 or 1v5 = 0 and 2 or 1 or 4v6 = 0 or False and 1 V1 = 1 V2 = 3 V3 = 0 V4 = 1 V5 = 1 V6 = False (使用and如果第一个条件满足那么结果为第二个条件，如果第一个不满足结果为第一个条件。使用or如果第一个条件满足那么结果为第一个条件，如果第一个条件不满足结果为第二个条件） 8.ascii、unicode、utf-8、gbk 区别？ Ascii只占一个字节，其中包含英文字母、数字和一些符号。无法表示其他的文字。 Unicode占两个字节，生僻字符占四个字节。但是如果全是英文字母的话会比较浪费空间。 Utf-8中英文占一个字节中文占三个字节，其他的生僻字占4-6个字节。 GBK占两个字节是中国制定的包含大部分汉字和其他的一些符号。 9.三元运算规则以及应用场景？ Python的三元运算格式为res = 值1 if 条件 else 值2 ，当条件满足时返回值1否则返回值2。 可以用于只存在两种结果的if判断语句中。 10.列举 Python2和Python3的区别？ Print函数：2中不需要括号将输出语句括起来，3中需要使用() 编码：Python3源码文件默认使用utf-8编码，支持中文 除法运算：首先是'/' : python3: 1 / 2 = 0.5 python2: 1 / 2 = 0 1.0 / 2.0 = 0.5 其次是’//’ Python3： 1 // 2 = 0 Python2: 1 // 2 = 0 4.不等运算符：2中不等于有两种表示!=和&lt;&gt;,3中只有!= 5.数据类型：3中不支持long类型了只有一种整形int 和2中的long差不多的操作 11.用一行代码实现数值交换：a = 1 ,b = 2 (a, b) = (b, a) 12.Python3和Python2中 int 和 long的区别？ Python3中没有long类型只有int但是3中的int操作包含2中的long操作。 13.xrange和range的区别？ Range([start,]stop[,step])更具指定的范围和步长生成一个序列。 Xrange()和range操作一样，不同的是它返回的是一个生成器。 例如当我们使用range(10)的时候返回的是一个[0,1,2,3,4,5,6,7,8,9]的列表。而xrange(10)不会返回一个列表，而是每次调用的时候返回其中的值。这样在生成一个很大的操作的时候xrange的性能会更好。 14文件操作时：xreadlines和readlines的区别？ 和上面的range和xrange一样的区别，readlines将文件中读取的数据读取出来生成一个列表存放着，而xreadlines返回的是一个迭代器每次调用的时候返回下一个值。所以对于数据量比较大的时候使用迭代器的方法会更好一些。 15.列举布尔值为False的常见值？ 0、None、””、[]、{} 16.字符串、列表、元组、字典每个常用的5个方法？ 字符串：isdigit()判断是否只包含数字 islower()判断是否全为小写 isupper()判断是否全为大写 strip()去掉首尾空格 split()以指定字符切片 列表：append()在列表后面追加 count()统计次数 pop(index=-1)默认移除最后一个元素并返回 sort()排序 reverse()反向列表中的元素 min()、max()返回最小最大值。 元组：cmp(tuple1,tuple2)比较两个元组元素 len()计算元组元素个数 max()返回最大值 min()返回最小值 tuple(list)将列表转为元组。 字典：get(key,default=None)返回指定键的值，没有返回默认值 copy()返回一个字典的浅复制 update(dict2)将dict2更新到原字典中 value()返回所有值 keys()返回所有键 pop(key)删除并返回指定的key的值 popitem()随机删除并返回一个键值对。 17.lambda表达式格式以及应用场景？ Lambda语句中冒号前面的为参数，可以有多个，用逗号隔开。冒号右边的为返回值，如：add = lambda x, y : x + y add(1,3) 结果为4 Lambda表达式通常是在需要一个函数，但是又不想费神去命名一个函数的时候使用，通常应用在函数式编程中、闭包 18.pass的作用？ Pass是空语句，为了保持程序结构的完整性，不做任何操作，一般只用做占位语句。 19.*args和**kwargs作用 如果我们不确定往一个函数中传入多少参数，或者我们希望以元组tuple或者列表list的形式传参数的时候，我们可以使用*args。如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs，args、kwargs两个标识符是约定俗成的用法。另一种答法：当函数的参数前面有一个星号*号的时候表示这是一个可变的位置参数，两个星号**表示这个是一个可变的关键词参数。星号*把序列或者集合解包（unpack）成位置参数，两个星号**把字典解包成关键词参数。 20.is和==的区别 is比较的是两个实例对象是不是完全相同的，他们是不是同一个对象，占用的内存地址是否相同。 ==比较的是两个对象的内容是否相等，内存地址可以不同，内容一样就可以了。 21.简述Python的深浅拷贝以及应用场景？ Python的变量只存储了这个变量的内存地址，而不是值的本身，对于像list set dict这种复杂的数据结构来说里面存储的也仅仅是每个元素的地址而已 赋值：变量的每一次初始化都会在内存里面开辟一个新的空间，并将这个内存地址赋值给变量，例如： 给str1两次赋值，两次的内存地址发生改变，第一次赋值hello的时候将hello在内存中的地址给了str1，第二次赋值world的时候再次将world的内存地址给了str1，但是此时hello并没有从内存中消失，只是现在没有变量指向他。当我们再次赋值的时候str1又指向了hello。 深拷贝： 深拷贝可以完全复制原变量的所有数据，我们修改其中一个的时候不会对复制的那份造成影响。 浅拷贝： 不管多么复杂的数据结构，浅拷贝只会copy一层。对于像int float str这种单一的数据是可以独立出来，但是对于更为复杂的数据结构就会出问题，因为在复制的时候只是将列表 字典等的整个的存放地址给复制过来了，并没有复制里面元素的内存地址，这样导致修改的时候会同时发生变化。例如： 22.Python垃圾回收机制？ Python的垃圾回收机制默认的方式是引用计数法，其原理是为每一个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，有新的引用指向过来的时候计数加一，引用失效时计数减一，当对象的引用计数为0的时候，对象会被回收，释放内存空间。除了这个还有标记清除法和分代回收。 23.Python的可变类型和不可变类型？ 数字、字符串、元组是不可变的，列表字典是可变的，对于不可变类型的变量重新赋值的时候实际上是重新创建一个新的对象，原变量指向新的对象内存地址，除浮点型变量之外，对于值相同的变量可能都会指向同一个内存地址。可变类型例如列表在新增一个元素的时候，变量还是指向原来的那个内存地址，只是其中的元素指向发生了改变。 24.求结果： v = dict.fromkeys(['k1','k2'],[]) v[‘k1’].append(666) print(v) v[‘k1’] = 777 print(v) {'k1': [666], 'k2': [666]} {'k1': 777, 'k2': [666]} 猜测原因是，在创建v这个字典的时候k1 k2 都指向了同一个空列表，当我们修改了这个列表的内容之后两个会同时发生改变，第二次单独修改k1的时候重新开辟了一个空间并指向新的内存地址。 25.求结果： [6, 6, 6, 6] 解释见：https://www.cnblogs.com/imhurley/p/3898289.html 26.列举常见的内置函数？ abs() 绝对值 len()序列长度 divmod()取模 pow()乘方 round()浮点数 27.filter、map、reduce的作用？ filter()函数：filter()函数接收两个参数，一个是bool函数，一个是序列，依次将序列中的每一个元素传入到bool函数中，返回值为非零的元素添加到新的列表中。 map()函数：map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回 reduce()函数：三个参数，一个需要两个参数的函数，一个序列，一个初始值，执行顺序为：将序列中的第一个值和初始值进行func处理，然后将结果和序列第二个值处理直到结束。 28.一行代码实现9*9乘法表 print \"\\n\".join(\"\\t\".join([\"%s*%s=%s\" %(x,y,x*y) for y in range(1, x+1)]) for x in range(1, 10)) 29.re的match和search区别？ Match是从头开始匹配 search从任意位置匹配 30.什么是正则的贪婪匹配？ 贪婪匹配就死趋于最大长度的匹配 非贪婪匹配就是匹配到结果就好 31.def func(a,b=[]) 这种写法有什么坑？ 函数的第二个参数是一个list，当第一次执行的时候实例化了一个list，第二次执行的时候还是用的是第一次实例化的那个list 32.如何实现 “1,2,3” 变成 [‘1’,’2’,’3’] ? 如何实现[‘1’,’2’,’3’]变成[1,2,3] ? 34.比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 c = [(1,),(2,),(3,) ] 的区别？ a是一个列表,其中的元素为整数 a和b 的内容一样但是在内存中的地址不同，也就是 a==b 成立 a is b 不成立 c也是一个列表，只不过其中的元素为元组 35.如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ? 1：list(map(lambda x:x*x ,[1,2,3,4,5,6,7,8,9,10])) 2：list(x*x for x in range(1,11)) 36.一行代码实现删除列表中重复的值 ? list1 = list(set(list1)) 37.如何在函数中设置一个全局变量 ? 使用global声明变量 38.logging模块的作用？以及应用场景？ logging模块是python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、保存路径、日志文件回滚等。可用于记录程序运行状态。 39.请用代码简单实现stack 。 class Stack(object): # 初始化栈为空列表 def __init__(self): self.items = [] # 判断栈是否为空，返回布尔值 def is_empty(self): return self.items == [] # 返回栈顶元素 def peek(self): return self.items[len(self.items) - 1] # 返回栈的大小 def size(self): return len(self.items) # 进栈 def push(self, item): self.items.append(item) # 出栈 def pop(self, item): return self.items.pop() 40.常用字符串格式化哪几种？ 主要有两种 % 和format 示例1：”%s%d” %(‘hello’,1) 示例2：\"i am {} age {} sex:{}\".format('alex',38,'male') \"i am {1} age {1} sex:{2}\".format('alex',38,'male') 41.简述 生成器、迭代器、可迭代对象 以及应用场景？ 生成器：生成器其实是一种特殊的迭代器，生成器一定是迭代器反之不成立，不需要写__iter__()和__next__()方法，只需要一个yield关键字。 例如：斐波那契的例子 def fib(): prev, curr = 0, 1 while True: yield curr prev, curr = curr, curr + prev &gt;&gt;&gt; f = fib() &gt;&gt;&gt; from itertools import islice &gt;&gt;&gt; list(islice(f, 0, 10)) [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] 生成器表达式：是列表推倒式的生成器版本，看起来像列表推导式，但是他返回的是一个生成器对象而不是列表对象 迭代器：可以被next调用并不断返回下一个值的对象称为迭代器，迭代器内部有一个状态，该状态用于记录当前迭代所在的位置，__iter__()返回迭代器本身，__next__()返回容器中的下一个值。 可迭代对象：但凡可以返回一个迭代器的对象都可以称之为可迭代对象，更为直观点可以使用for循环的对象，如列表，元组，字典，集合，字符串，打开的文件，socket等。 42.用Python实现一个二分查找的函数。 43.谈谈你对闭包的理解？ 闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包： 在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。 一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的 Python中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下： 闭包的应用：装饰器、单例模式 44.os和sys模块的作用？ os 模块提供了一种方便的使用操作系统函数的方法。 sys模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。 45.如何生成一个随机数？ 46.如何使用python删除一个文件？ os.remove(file_path) os.rmdir(dir_path) 47.面向对象深度优先和广度优先是什么？ Python 中类的多继承分为深度优先和广度优先，新式类会按照深度优先方法查找，金典类会按照广度优先的方式查找。 48.面向对象中super的作用？ Super()可以保证公共的父类仅被执行一次。按照MRO的顺序执行原理待更新： 49.列举面向对象中带爽下划线的特殊方法，如：__new__、__init__ __doc__ 表示类的描述信息 __module__ 表示当前操作的对象在那个模块 __class__ 表示当前操作的对象的类是什么 __init__ 构造方法，通过类创建对象时，自动触发执行 __del__ 析构方法，当对象在内存中被释放的时候，自动触发执行 __call__ 对象后面加括号，触发执行 __dict__ 类或对象中的所有成员 __str__ 如果一个类中定义了这个方法那么在打印对象的时候默认输出该方法的返回值 __getitem__、__setitem__、__delitem__ 用于索引操作，如字典。分别表示获取、设置、删除数据 __getslice__、__setslice__、__delslice__分别用于切片操作，如列表 __iter__ 用于迭代器 __new__和__metaclass__ 50.如何判断是函数还是方法？ 根据__call__属性判断： if(hasattr(func,’__call__’)): 利用callable判断: if(callable(func)): 利用isfunction判断：if(isfunction(add)): 51.静态方法和类方法区别？ 类方法必须有一个指向类对象的引用作为第一个参数，但是静态方法可以没有任何参数， 52.列举面向对象中的特殊成员以及应用场景 53. 1、2、3、4、5 能组成多少个互不相同且无重复的三位数 A53 = 60个 54. 什么是反射？以及应用场景？ 其实，反射就是通过字符串的形式，导入模块；通过字符串的形式去模块寻找指定的函数并执行。利用字符串的形式去对象（模块）中操作（查找、获取、删除、添加）成员，是一种基于字符串的事件驱动。 getattr(object, name [,defaukt])函数是python内置函数，用于返回一个对象属性值,若不存在且为设置默认值则触发异常，如果设置了默认值则返回默认值。 hasattr(object,name):判断对象object是否包含名为name的特性（hasattr是通过调用getattr()是否抛出异常来实现的）。如果有该属性则返回True否则返回False setattr(object, name, value):对应函数getattr(),用于设置属性值，或者增加某个属性。 delattr(object, name):用于删除属性，操作类似不举示例了。 应用：实现一个简单的url路由器的功能，实现动态导入模块 55.metaclass作用？以及应用场景？ Metaclass 的实例化结果是类。而class实例化结果是instance，metaclass是创建类的模版，所有的类都是通过他来创建的，这使得我们可以自由控制创建类的过程。实现自由的修改、增加、删除 类或者实例中的方法或者属性。可批量对某些方法使用装饰器，而不需要每次都在方法上面增加@decorator_func。等等 56.用尽量多的方法实现单例模式。 单例模式的主要目的是确保某一个类只有一个实例存在，主要的实现方式有以下几种： 1：使用模块。 2：使用装饰器。 3：基于__new__方法实现。 在实例化一个类的时候，首先执行了类的__new__方法，然后执行__init__方法，在实例化的时候先检查有没有已经实例化过，如果有则返回已经实例化候的对象，否则创建新的。 4：基于metaclass方法实现 1.类由type创建，创建类时，type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__ 方法)。 2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 __call__ 方法。 57.装饰器的写法以及应用场景。 python的装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数和闭包一样，所以装饰器是闭包的一种应用，使用装饰器可以不用在更改原函数的前提下给函数增加新的功能，当有多个装饰器的时候从上到下依次执行。 装饰器的原理：和闭包类似 最简单的一个装饰器 主要用户一些认证功能，日志，授权 58.异常处理写法以及如何主动抛出异常（应用场景） 59.什么是面向对象的mro 60.isinstance作用以及应用场景？ 用来判断一个对象是否是一个已知类型，类似type(),和type不同的是type()不会认为子类是一种父类类型，不考虑继承关系，而isinstance（）会认为子类是一种父类类型，会考虑继承关系。如果要判断两个类型是否相同的时候最好使用isinstance 61.写代码并实现： 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1] 62.json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？ 可处理的数据类型有:字符串、列表、元组、字典、整数，不支持集合。定制支持datetime:首先写一个类：将用于判断是否 为datetime类型的数据格式，如果是则将其转换成字符串类型。再交给json处理。使用的时候指定cls参数即可。 63.json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？ 64.什么是断言？应用场景？ assert断言用来检查一个条件，如果为真那么不做任何事，如果错误则会抛出AssertionError错误并且包含错误信息，应用场景：程序常量，检查逻辑，检查文，档检查约定。格式为 assert 语句, 报错输出","link":"/2018/06/23/%E6%B2%9B%E9%BD%90%E7%9A%84315%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E8%A7%A3%E7%AD%94%EF%BC%88%E4%B8%80%EF%BC%89/"}],"tags":[{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"网络请求","slug":"网络请求","link":"/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"},{"name":"硬件","slug":"硬件","link":"/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"Arduino","slug":"Arduino","link":"/tags/Arduino/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"DRF","slug":"DRF","link":"/tags/DRF/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"部署","slug":"部署","link":"/tags/%E9%83%A8%E7%BD%B2/"},{"name":"前后端分离","slug":"前后端分离","link":"/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"web中间件","slug":"web中间件","link":"/tags/web%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"登录","slug":"登录","link":"/tags/%E7%99%BB%E5%BD%95/"},{"name":"邮箱","slug":"邮箱","link":"/tags/%E9%82%AE%E7%AE%B1/"},{"name":"支付","slug":"支付","link":"/tags/%E6%94%AF%E4%BB%98/"},{"name":"后端","slug":"后端","link":"/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Django模版","slug":"Django模版","link":"/tags/Django%E6%A8%A1%E7%89%88/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"文件处理","slug":"文件处理","link":"/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"name":"Excel","slug":"Excel","link":"/tags/Excel/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"分词","slug":"分词","link":"/tags/%E5%88%86%E8%AF%8D/"},{"name":"PyQt","slug":"PyQt","link":"/tags/PyQt/"},{"name":"编程基础","slug":"编程基础","link":"/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"MQ","slug":"MQ","link":"/tags/MQ/"},{"name":"Reids","slug":"Reids","link":"/tags/Reids/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"odoo","slug":"odoo","link":"/tags/odoo/"},{"name":"物联网","slug":"物联网","link":"/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Arduino","slug":"Arduino","link":"/categories/Arduino/"},{"name":"Django","slug":"Django","link":"/categories/Django/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"未分类","slug":"未分类","link":"/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"算法/leetcode","link":"/categories/%E7%AE%97%E6%B3%95/leetcode/"},{"name":"Odoo","slug":"Odoo","link":"/categories/Odoo/"},{"name":"物联网","slug":"物联网","link":"/categories/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"算法","slug":"Python/算法","link":"/categories/Python/%E7%AE%97%E6%B3%95/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]}